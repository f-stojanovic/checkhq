<?php
/**
 * DefaultApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Check API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2023-04-04
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'approveAnExternalPayroll' => [
            'application/json',
        ],
        'approvePayroll' => [
            'application/json',
        ],
        'bulkGetEmployeeTaxParameterSettings' => [
            'application/json',
        ],
        'bulkGetEmployeeTaxParams' => [
            'application/json',
        ],
        'bulkUpdateEmployeeTaxParameters' => [
            'application/json',
        ],
        'cancelAPayment' => [
            'application/json',
        ],
        'cancelImplementation1' => [
            'application/json',
        ],
        'companyAccountingIntegration' => [
            'application/json',
        ],
        'companyAuthorizationDocuments' => [
            'application/json',
        ],
        'companyBusinessDetails' => [
            'application/json',
        ],
        'companyConnectBankAccount' => [
            'application/json',
        ],
        'companyDetails' => [
            'application/json',
        ],
        'companyEmployeeSetup' => [
            'application/json',
        ],
        'companyFilingAuthorization' => [
            'application/json',
        ],
        'companyPayHistory' => [
            'application/json',
        ],
        'companyPaymentSetup' => [
            'application/json',
        ],
        'companyProgressTracker' => [
            'application/json',
        ],
        'companyReports' => [
            'application/json',
        ],
        'companySignatoryAgreements' => [
            'application/json',
        ],
        'companyTaxDocuments' => [
            'application/json',
        ],
        'companyTaxSetup' => [
            'application/json',
        ],
        'companyTeamSetup' => [
            'application/json',
        ],
        'companyTermsOfService' => [
            'application/json',
        ],
        'companyVerificationDocuments' => [
            'application/json',
        ],
        'contractorTaxDocuments' => [
            'application/json',
        ],
        'createABankAccount' => [
            'application/json',
        ],
        'createACompanyBenefit' => [
            'application/json',
        ],
        'createACompanyProvidedDocument' => [
            'application/json',
        ],
        'createAContractor' => [
            'application/json',
        ],
        'createAContractorPayment' => [
            'application/json',
        ],
        'createAPaySchedule' => [
            'application/json',
        ],
        'createAPayrollItem' => [
            'application/json',
        ],
        'createAPostTaxDeduction' => [
            'application/json',
        ],
        'createASignatory' => [
            'application/json',
        ],
        'createAWebhookConfig' => [
            'application/json',
        ],
        'createAWorkplace' => [
            'application/json',
        ],
        'createAnEarningCode' => [
            'application/json',
        ],
        'createAnEarningRate' => [
            'application/json',
        ],
        'createAnEmployee' => [
            'application/json',
        ],
        'createAnEmployeeBenefit' => [
            'application/json',
        ],
        'createAnExternalPayroll' => [
            'application/json',
        ],
        'createCompany' => [
            'application/json',
        ],
        'createCompanyTaxElections' => [
            'application/json',
        ],
        'createNetPaySplit' => [
            'application/json',
        ],
        'createPayroll' => [
            'application/json',
        ],
        'createTheEnrollmentProfile' => [
            'application/json',
        ],
        'deleteABankAccount' => [
            'application/json',
        ],
        'deleteACompanyBenefit' => [
            'application/json',
        ],
        'deleteAContractorPayment' => [
            'application/json',
        ],
        'deleteAPayroll' => [
            'application/json',
        ],
        'deleteAPayrollCopy1' => [
            'application/json',
        ],
        'deleteAPayrollItem' => [
            'application/json',
        ],
        'deleteAPostTaxDeduction' => [
            'application/json',
        ],
        'deleteAWebhookConfig' => [
            'application/json',
        ],
        'deleteAnEmployeeBenefit' => [
            'application/json',
        ],
        'downloadACompanyAuthorizationDocument' => [
            'application/json',
        ],
        'downloadACompanyTaxDocument' => [
            'application/json',
        ],
        'downloadAContractorTaxDocument' => [
            'application/json',
        ],
        'downloadASetupDocument' => [
            'application/json',
        ],
        'downloadAnEmployeeTaxDocument' => [
            'application/json',
        ],
        'earlyEnrollment' => [
            'application/json',
        ],
        'employeeBenefits' => [
            'application/json',
        ],
        'employeePaymentSetup' => [
            'application/json',
        ],
        'employeePaystub' => [
            'application/json',
        ],
        'employeePostTaxDeductions' => [
            'application/json',
        ],
        'employeeProfile' => [
            'application/json',
        ],
        'employeeSsnSetup' => [
            'application/json',
        ],
        'employeeTaxDocuments' => [
            'application/json',
        ],
        'employeeWithholdingsSetup' => [
            'application/json',
        ],
        'fullServiceSetupSubmission' => [
            'application/json',
        ],
        'generateContractorOnboardLink' => [
            'application/json',
        ],
        'generateOnboardLink' => [
            'application/json',
        ],
        'generateOnboardLink1' => [
            'application/json',
        ],
        'getABankAccount' => [
            'application/json',
        ],
        'getACompany' => [
            'application/json',
        ],
        'getACompanyAuthorizationDocument' => [
            'application/json',
        ],
        'getACompanyBenefit' => [
            'application/json',
        ],
        'getACompanyProvidedDocument' => [
            'application/json',
        ],
        'getACompanyTaxDocument' => [
            'application/json',
        ],
        'getACompanysRequirements' => [
            'application/json',
        ],
        'getAContractor' => [
            'application/json',
        ],
        'getAContractorPayment' => [
            'application/json',
        ],
        'getAContractorTaxDocument' => [
            'application/json',
        ],
        'getAFederalEinVerification' => [
            'application/json',
        ],
        'getAForm' => [
            'application/json',
        ],
        'getANetPaySplit' => [
            'application/json',
        ],
        'getAPaperCheck' => [
            'application/json',
        ],
        'getAPaperCheck2' => [
            'application/json',
        ],
        'getAPaySchedule' => [
            'application/json',
        ],
        'getAPayment' => [
            'application/json',
        ],
        'getAPaymentAttempt' => [
            'application/json',
        ],
        'getAPaymentAttemptCopy1' => [
            'application/json',
        ],
        'getAPayrollItem' => [
            'application/json',
        ],
        'getAPaystub' => [
            'application/json',
        ],
        'getAPaystub1' => [
            'application/json',
        ],
        'getAPostTaxDeduction' => [
            'application/json',
        ],
        'getASetupDocument' => [
            'application/json',
        ],
        'getATaxFilingEventCopy' => [
            'application/json',
        ],
        'getAWebhookConfig' => [
            'application/json',
        ],
        'getAWorkplace' => [
            'application/json',
        ],
        'getAWorkplace1' => [
            'application/json',
        ],
        'getAnEarningRate' => [
            'application/json',
        ],
        'getAnEmployee' => [
            'application/json',
        ],
        'getAnEmployeeBenefit' => [
            'application/json',
        ],
        'getAnEmployeeForm' => [
            'application/json',
        ],
        'getAnEmployeeTaxDocument' => [
            'application/json',
        ],
        'getAnEmployeesPaystubs' => [
            'application/json',
        ],
        'getAppliedForTaxIdsReport' => [
            'application/json',
        ],
        'getCashRequirementReport' => [
            'application/json',
        ],
        'getCompanyDefinedAttributes' => [
            'application/json',
        ],
        'getCompanyPaydays' => [
            'application/json',
        ],
        'getCompanyTaxParameterSetting' => [
            'application/json',
        ],
        'getContractorPaymentsReport' => [
            'application/json',
        ],
        'getEmployeeTaxParameterSetting' => [
            'application/json',
        ],
        'getPaperChecks' => [
            'application/json',
        ],
        'getPaperChecksReport' => [
            'application/json',
        ],
        'getPaydays' => [
            'application/json',
        ],
        'getPayroll' => [
            'application/json',
        ],
        'getPayrollJournal' => [
            'application/json',
        ],
        'getPayrollSummary' => [
            'application/json',
        ],
        'getReciprocityElections' => [
            'application/json',
        ],
        'getSignatories' => [
            'application/json',
        ],
        'getTaxLiabilityReport' => [
            'application/json',
        ],
        'getTheEnrollmentProfile' => [
            'application/json',
        ],
        'getW2PreviewReport' => [
            'application/json',
        ],
        'getW4ExemptStatusReport' => [
            'application/json',
        ],
        'listAWebhookConfig' => [
            'application/json',
        ],
        'listBankAccounts' => [
            'application/json',
        ],
        'listBenefits' => [
            'application/json',
        ],
        'listCompanies' => [
            'application/json',
        ],
        'listCompanyAuthorizationDocuments' => [
            'application/json',
        ],
        'listCompanyBenefits' => [
            'application/json',
        ],
        'listCompanyJurisdictions' => [
            'application/json',
        ],
        'listCompanyProvidedDocuments' => [
            'application/json',
        ],
        'listCompanyTaxDocuments' => [
            'application/json',
        ],
        'listCompanyTaxElections' => [
            'application/json',
        ],
        'listCompanyTaxParameterSettings' => [
            'application/json',
        ],
        'listCompanyTaxParameters' => [
            'application/json',
        ],
        'listContractorPayments' => [
            'application/json',
        ],
        'listContractorPayments1' => [
            'application/json',
        ],
        'listContractorTaxDocuments' => [
            'application/json',
        ],
        'listContractors' => [
            'application/json',
        ],
        'listEarningCodes' => [
            'application/json',
        ],
        'listEarningRates' => [
            'application/json',
        ],
        'listEmployeeForms' => [
            'application/json',
        ],
        'listEmployeeJurisdictions' => [
            'application/json',
        ],
        'listEmployeeTaxDocuments' => [
            'application/json',
        ],
        'listEmployeeTaxElections' => [
            'application/json',
        ],
        'listEmployeeTaxParameterSettings' => [
            'application/json',
        ],
        'listEmployees' => [
            'application/json',
        ],
        'listEmployeesTaxParameters' => [
            'application/json',
        ],
        'listFederalEinVerifications' => [
            'application/json',
        ],
        'listForms' => [
            'application/json',
        ],
        'listNetPaySplits' => [
            'application/json',
        ],
        'listPaySchedules' => [
            'application/json',
        ],
        'listPayments' => [
            'application/json',
        ],
        'listPaymentsCopy' => [
            'application/json',
        ],
        'listPayrollItems' => [
            'application/json',
        ],
        'listPayrolls' => [
            'application/json',
        ],
        'listPostTaxDeductions' => [
            'application/json',
        ],
        'listRequirements' => [
            'application/json',
        ],
        'listSetupDocuments' => [
            'application/json',
        ],
        'listTaxDeposits' => [
            'application/json',
        ],
        'listUsageRecords' => [
            'application/json',
        ],
        'listUsageSummaries' => [
            'application/json',
        ],
        'listWorkplaces' => [
            'application/json',
        ],
        'pingAWebhookConfig' => [
            'application/json',
        ],
        'previewPayroll' => [
            'application/json',
        ],
        'previousPayrollProviderAccess' => [
            'application/json',
        ],
        'refundAPayment' => [
            'application/json',
        ],
        'renderAForm' => [
            'application/json',
        ],
        'reopenAPendingPayroll' => [
            'application/json',
        ],
        'reopenPayroll' => [
            'application/json',
        ],
        'requestEmbeddedSetup' => [
            'application/json',
        ],
        'retryAPayment' => [
            'application/json',
        ],
        'retryWebhookEventsInSandbox' => [
            'application/json',
        ],
        'runPayroll' => [
            'application/json',
        ],
        'startImplementation' => [
            'application/json',
        ],
        'submitAnEmployeeForm' => [
            'application/json',
        ],
        'updateABankAccount' => [
            'application/json',
        ],
        'updateACompany' => [
            'application/json',
        ],
        'updateACompanyBenefit' => [
            'application/json',
        ],
        'updateAContractor' => [
            'application/json',
        ],
        'updateAContractorPayment' => [
            'application/json',
        ],
        'updateAPaySchedule' => [
            'application/json',
        ],
        'updateAPayrollItem' => [
            'application/json',
        ],
        'updateAPostTaxDeduction' => [
            'application/json',
        ],
        'updateAWebhookConfig' => [
            'application/json',
        ],
        'updateAWorkplace' => [
            'application/json',
        ],
        'updateAnEarningCode' => [
            'application/json',
        ],
        'updateAnEarningRate' => [
            'application/json',
        ],
        'updateAnEmployee' => [
            'application/json',
        ],
        'updateAnEmployeeBenefit' => [
            'application/json',
        ],
        'updateAnExternalPayroll' => [
            'application/json',
        ],
        'updateCompanyDefinedAttributes' => [
            'application/json',
        ],
        'updateCompanyTaxElections' => [
            'application/json',
        ],
        'updateCompanyTaxParameters' => [
            'application/json',
        ],
        'updateEmployeeTaxElections' => [
            'application/json',
        ],
        'updateEmployeeTaxParameters' => [
            'application/json',
        ],
        'updatePayroll' => [
            'application/json',
        ],
        'updateReciprocityElections' => [
            'application/json',
        ],
        'updateTheEnrollmentProfile' => [
            'application/json',
        ],
        'uploadAFileForACompanyProvidedDocument' => [
            'application/json',
        ],
        'validateAddress' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation approveAnExternalPayroll
     *
     * Approve an external payroll
     *
     * @param  string $payroll payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function approveAnExternalPayroll($payroll, string $contentType = self::contentTypes['approveAnExternalPayroll'][0])
    {
        $this->approveAnExternalPayrollWithHttpInfo($payroll, $contentType);
    }

    /**
     * Operation approveAnExternalPayrollWithHttpInfo
     *
     * Approve an external payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function approveAnExternalPayrollWithHttpInfo($payroll, string $contentType = self::contentTypes['approveAnExternalPayroll'][0])
    {
        $request = $this->approveAnExternalPayrollRequest($payroll, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation approveAnExternalPayrollAsync
     *
     * Approve an external payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveAnExternalPayrollAsync($payroll, string $contentType = self::contentTypes['approveAnExternalPayroll'][0])
    {
        return $this->approveAnExternalPayrollAsyncWithHttpInfo($payroll, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation approveAnExternalPayrollAsyncWithHttpInfo
     *
     * Approve an external payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveAnExternalPayrollAsyncWithHttpInfo($payroll, string $contentType = self::contentTypes['approveAnExternalPayroll'][0])
    {
        $returnType = '';
        $request = $this->approveAnExternalPayrollRequest($payroll, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'approveAnExternalPayroll'
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function approveAnExternalPayrollRequest($payroll, string $contentType = self::contentTypes['approveAnExternalPayroll'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling approveAnExternalPayroll'
            );
        }


        $resourcePath = '/external_payrolls/{payroll}/approve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation approvePayroll
     *
     * Approve a payroll
     *
     * @param  string $payroll payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approvePayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function approvePayroll($payroll, string $contentType = self::contentTypes['approvePayroll'][0])
    {
        $this->approvePayrollWithHttpInfo($payroll, $contentType);
    }

    /**
     * Operation approvePayrollWithHttpInfo
     *
     * Approve a payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approvePayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function approvePayrollWithHttpInfo($payroll, string $contentType = self::contentTypes['approvePayroll'][0])
    {
        $request = $this->approvePayrollRequest($payroll, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation approvePayrollAsync
     *
     * Approve a payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approvePayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approvePayrollAsync($payroll, string $contentType = self::contentTypes['approvePayroll'][0])
    {
        return $this->approvePayrollAsyncWithHttpInfo($payroll, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation approvePayrollAsyncWithHttpInfo
     *
     * Approve a payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approvePayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approvePayrollAsyncWithHttpInfo($payroll, string $contentType = self::contentTypes['approvePayroll'][0])
    {
        $returnType = '';
        $request = $this->approvePayrollRequest($payroll, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'approvePayroll'
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approvePayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function approvePayrollRequest($payroll, string $contentType = self::contentTypes['approvePayroll'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling approvePayroll'
            );
        }


        $resourcePath = '/payrolls/{payroll}/approve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkGetEmployeeTaxParameterSettings
     *
     * Bulk get employee tax parameter settings
     *
     * @param  string $company Unique ID of the company. (required)
     * @param  string $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkGetEmployeeTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function bulkGetEmployeeTaxParameterSettings($company, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['bulkGetEmployeeTaxParameterSettings'][0])
    {
        list($response) = $this->bulkGetEmployeeTaxParameterSettingsWithHttpInfo($company, $as_of, $jurisdiction, $contentType);
        return $response;
    }

    /**
     * Operation bulkGetEmployeeTaxParameterSettingsWithHttpInfo
     *
     * Bulk get employee tax parameter settings
     *
     * @param  string $company Unique ID of the company. (required)
     * @param  string $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkGetEmployeeTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkGetEmployeeTaxParameterSettingsWithHttpInfo($company, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['bulkGetEmployeeTaxParameterSettings'][0])
    {
        $request = $this->bulkGetEmployeeTaxParameterSettingsRequest($company, $as_of, $jurisdiction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bulkGetEmployeeTaxParameterSettingsAsync
     *
     * Bulk get employee tax parameter settings
     *
     * @param  string $company Unique ID of the company. (required)
     * @param  string $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkGetEmployeeTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkGetEmployeeTaxParameterSettingsAsync($company, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['bulkGetEmployeeTaxParameterSettings'][0])
    {
        return $this->bulkGetEmployeeTaxParameterSettingsAsyncWithHttpInfo($company, $as_of, $jurisdiction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkGetEmployeeTaxParameterSettingsAsyncWithHttpInfo
     *
     * Bulk get employee tax parameter settings
     *
     * @param  string $company Unique ID of the company. (required)
     * @param  string $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkGetEmployeeTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkGetEmployeeTaxParameterSettingsAsyncWithHttpInfo($company, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['bulkGetEmployeeTaxParameterSettings'][0])
    {
        $returnType = 'object';
        $request = $this->bulkGetEmployeeTaxParameterSettingsRequest($company, $as_of, $jurisdiction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkGetEmployeeTaxParameterSettings'
     *
     * @param  string $company Unique ID of the company. (required)
     * @param  string $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkGetEmployeeTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkGetEmployeeTaxParameterSettingsRequest($company, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['bulkGetEmployeeTaxParameterSettings'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling bulkGetEmployeeTaxParameterSettings'
            );
        }




        $resourcePath = '/employee_tax_params/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_of,
            'as_of', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $jurisdiction,
            'jurisdiction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkGetEmployeeTaxParams
     *
     * Bulk get employee tax parameters
     *
     * @param  string $company Unique ID of the company. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkGetEmployeeTaxParams'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function bulkGetEmployeeTaxParams($company, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['bulkGetEmployeeTaxParams'][0])
    {
        list($response) = $this->bulkGetEmployeeTaxParamsWithHttpInfo($company, $as_of, $jurisdiction, $contentType);
        return $response;
    }

    /**
     * Operation bulkGetEmployeeTaxParamsWithHttpInfo
     *
     * Bulk get employee tax parameters
     *
     * @param  string $company Unique ID of the company. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkGetEmployeeTaxParams'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkGetEmployeeTaxParamsWithHttpInfo($company, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['bulkGetEmployeeTaxParams'][0])
    {
        $request = $this->bulkGetEmployeeTaxParamsRequest($company, $as_of, $jurisdiction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bulkGetEmployeeTaxParamsAsync
     *
     * Bulk get employee tax parameters
     *
     * @param  string $company Unique ID of the company. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkGetEmployeeTaxParams'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkGetEmployeeTaxParamsAsync($company, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['bulkGetEmployeeTaxParams'][0])
    {
        return $this->bulkGetEmployeeTaxParamsAsyncWithHttpInfo($company, $as_of, $jurisdiction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkGetEmployeeTaxParamsAsyncWithHttpInfo
     *
     * Bulk get employee tax parameters
     *
     * @param  string $company Unique ID of the company. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkGetEmployeeTaxParams'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkGetEmployeeTaxParamsAsyncWithHttpInfo($company, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['bulkGetEmployeeTaxParams'][0])
    {
        $returnType = 'object';
        $request = $this->bulkGetEmployeeTaxParamsRequest($company, $as_of, $jurisdiction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkGetEmployeeTaxParams'
     *
     * @param  string $company Unique ID of the company. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkGetEmployeeTaxParams'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkGetEmployeeTaxParamsRequest($company, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['bulkGetEmployeeTaxParams'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling bulkGetEmployeeTaxParams'
            );
        }




        $resourcePath = '/employee_tax_params';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_of,
            'as_of', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $jurisdiction,
            'jurisdiction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkUpdateEmployeeTaxParameters
     *
     * Bulk update employee tax parameters
     *
     * @param  \OpenAPI\Client\Model\BulkUpdateEmployeeTaxParametersRequest $bulk_update_employee_tax_parameters_request bulk_update_employee_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateEmployeeTaxParameters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function bulkUpdateEmployeeTaxParameters($bulk_update_employee_tax_parameters_request = null, string $contentType = self::contentTypes['bulkUpdateEmployeeTaxParameters'][0])
    {
        list($response) = $this->bulkUpdateEmployeeTaxParametersWithHttpInfo($bulk_update_employee_tax_parameters_request, $contentType);
        return $response;
    }

    /**
     * Operation bulkUpdateEmployeeTaxParametersWithHttpInfo
     *
     * Bulk update employee tax parameters
     *
     * @param  \OpenAPI\Client\Model\BulkUpdateEmployeeTaxParametersRequest $bulk_update_employee_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateEmployeeTaxParameters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkUpdateEmployeeTaxParametersWithHttpInfo($bulk_update_employee_tax_parameters_request = null, string $contentType = self::contentTypes['bulkUpdateEmployeeTaxParameters'][0])
    {
        $request = $this->bulkUpdateEmployeeTaxParametersRequest($bulk_update_employee_tax_parameters_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bulkUpdateEmployeeTaxParametersAsync
     *
     * Bulk update employee tax parameters
     *
     * @param  \OpenAPI\Client\Model\BulkUpdateEmployeeTaxParametersRequest $bulk_update_employee_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateEmployeeTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkUpdateEmployeeTaxParametersAsync($bulk_update_employee_tax_parameters_request = null, string $contentType = self::contentTypes['bulkUpdateEmployeeTaxParameters'][0])
    {
        return $this->bulkUpdateEmployeeTaxParametersAsyncWithHttpInfo($bulk_update_employee_tax_parameters_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkUpdateEmployeeTaxParametersAsyncWithHttpInfo
     *
     * Bulk update employee tax parameters
     *
     * @param  \OpenAPI\Client\Model\BulkUpdateEmployeeTaxParametersRequest $bulk_update_employee_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateEmployeeTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkUpdateEmployeeTaxParametersAsyncWithHttpInfo($bulk_update_employee_tax_parameters_request = null, string $contentType = self::contentTypes['bulkUpdateEmployeeTaxParameters'][0])
    {
        $returnType = 'object';
        $request = $this->bulkUpdateEmployeeTaxParametersRequest($bulk_update_employee_tax_parameters_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkUpdateEmployeeTaxParameters'
     *
     * @param  \OpenAPI\Client\Model\BulkUpdateEmployeeTaxParametersRequest $bulk_update_employee_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateEmployeeTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkUpdateEmployeeTaxParametersRequest($bulk_update_employee_tax_parameters_request = null, string $contentType = self::contentTypes['bulkUpdateEmployeeTaxParameters'][0])
    {



        $resourcePath = '/employee_tax_params/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_update_employee_tax_parameters_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_update_employee_tax_parameters_request));
            } else {
                $httpBody = $bulk_update_employee_tax_parameters_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelAPayment
     *
     * Cancel a payment
     *
     * @param  string $payment payment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelAPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CancelAPayment200Response|object
     */
    public function cancelAPayment($payment, string $contentType = self::contentTypes['cancelAPayment'][0])
    {
        list($response) = $this->cancelAPaymentWithHttpInfo($payment, $contentType);
        return $response;
    }

    /**
     * Operation cancelAPaymentWithHttpInfo
     *
     * Cancel a payment
     *
     * @param  string $payment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelAPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CancelAPayment200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelAPaymentWithHttpInfo($payment, string $contentType = self::contentTypes['cancelAPayment'][0])
    {
        $request = $this->cancelAPaymentRequest($payment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CancelAPayment200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CancelAPayment200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CancelAPayment200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CancelAPayment200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CancelAPayment200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelAPaymentAsync
     *
     * Cancel a payment
     *
     * @param  string $payment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelAPaymentAsync($payment, string $contentType = self::contentTypes['cancelAPayment'][0])
    {
        return $this->cancelAPaymentAsyncWithHttpInfo($payment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelAPaymentAsyncWithHttpInfo
     *
     * Cancel a payment
     *
     * @param  string $payment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelAPaymentAsyncWithHttpInfo($payment, string $contentType = self::contentTypes['cancelAPayment'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CancelAPayment200Response';
        $request = $this->cancelAPaymentRequest($payment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelAPayment'
     *
     * @param  string $payment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelAPaymentRequest($payment, string $contentType = self::contentTypes['cancelAPayment'][0])
    {

        // verify the required parameter 'payment' is set
        if ($payment === null || (is_array($payment) && count($payment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment when calling cancelAPayment'
            );
        }


        $resourcePath = '/payments/{payment}/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment !== null) {
            $resourcePath = str_replace(
                '{' . 'payment' . '}',
                ObjectSerializer::toPathValue($payment),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelImplementation1
     *
     * Cancel implementation
     *
     * @param  string $company ID of the company to cancel implementation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelImplementation1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cancelImplementation1($company, string $contentType = self::contentTypes['cancelImplementation1'][0])
    {
        $this->cancelImplementation1WithHttpInfo($company, $contentType);
    }

    /**
     * Operation cancelImplementation1WithHttpInfo
     *
     * Cancel implementation
     *
     * @param  string $company ID of the company to cancel implementation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelImplementation1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelImplementation1WithHttpInfo($company, string $contentType = self::contentTypes['cancelImplementation1'][0])
    {
        $request = $this->cancelImplementation1Request($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelImplementation1Async
     *
     * Cancel implementation
     *
     * @param  string $company ID of the company to cancel implementation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelImplementation1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelImplementation1Async($company, string $contentType = self::contentTypes['cancelImplementation1'][0])
    {
        return $this->cancelImplementation1AsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelImplementation1AsyncWithHttpInfo
     *
     * Cancel implementation
     *
     * @param  string $company ID of the company to cancel implementation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelImplementation1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelImplementation1AsyncWithHttpInfo($company, string $contentType = self::contentTypes['cancelImplementation1'][0])
    {
        $returnType = '';
        $request = $this->cancelImplementation1Request($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelImplementation1'
     *
     * @param  string $company ID of the company to cancel implementation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelImplementation1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelImplementation1Request($company, string $contentType = self::contentTypes['cancelImplementation1'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling cancelImplementation1'
            );
        }


        $resourcePath = '/companies/{company}/cancel_implementation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyAccountingIntegration
     *
     * Company Accounting Integration
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyAccountingIntegration'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyAccountingIntegration($company, string $contentType = self::contentTypes['companyAccountingIntegration'][0])
    {
        list($response) = $this->companyAccountingIntegrationWithHttpInfo($company, $contentType);
        return $response;
    }

    /**
     * Operation companyAccountingIntegrationWithHttpInfo
     *
     * Company Accounting Integration
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyAccountingIntegration'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyAccountingIntegrationWithHttpInfo($company, string $contentType = self::contentTypes['companyAccountingIntegration'][0])
    {
        $request = $this->companyAccountingIntegrationRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyAccountingIntegrationAsync
     *
     * Company Accounting Integration
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyAccountingIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyAccountingIntegrationAsync($company, string $contentType = self::contentTypes['companyAccountingIntegration'][0])
    {
        return $this->companyAccountingIntegrationAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyAccountingIntegrationAsyncWithHttpInfo
     *
     * Company Accounting Integration
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyAccountingIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyAccountingIntegrationAsyncWithHttpInfo($company, string $contentType = self::contentTypes['companyAccountingIntegration'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyAccountingIntegrationRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyAccountingIntegration'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyAccountingIntegration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyAccountingIntegrationRequest($company, string $contentType = self::contentTypes['companyAccountingIntegration'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyAccountingIntegration'
            );
        }


        $resourcePath = '/companies/{company}/components/accounting_integration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyAuthorizationDocuments
     *
     * Company Authorization Documents
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyAuthorizationDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyAuthorizationDocuments($company, string $contentType = self::contentTypes['companyAuthorizationDocuments'][0])
    {
        list($response) = $this->companyAuthorizationDocumentsWithHttpInfo($company, $contentType);
        return $response;
    }

    /**
     * Operation companyAuthorizationDocumentsWithHttpInfo
     *
     * Company Authorization Documents
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyAuthorizationDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyAuthorizationDocumentsWithHttpInfo($company, string $contentType = self::contentTypes['companyAuthorizationDocuments'][0])
    {
        $request = $this->companyAuthorizationDocumentsRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyAuthorizationDocumentsAsync
     *
     * Company Authorization Documents
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyAuthorizationDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyAuthorizationDocumentsAsync($company, string $contentType = self::contentTypes['companyAuthorizationDocuments'][0])
    {
        return $this->companyAuthorizationDocumentsAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyAuthorizationDocumentsAsyncWithHttpInfo
     *
     * Company Authorization Documents
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyAuthorizationDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyAuthorizationDocumentsAsyncWithHttpInfo($company, string $contentType = self::contentTypes['companyAuthorizationDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyAuthorizationDocumentsRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyAuthorizationDocuments'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyAuthorizationDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyAuthorizationDocumentsRequest($company, string $contentType = self::contentTypes['companyAuthorizationDocuments'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyAuthorizationDocuments'
            );
        }


        $resourcePath = '/companies/{company}/components/authorization_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyBusinessDetails
     *
     * Company Business Details Component
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyBusinessDetails'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyBusinessDetails($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['companyBusinessDetails'][0])
    {
        list($response) = $this->companyBusinessDetailsWithHttpInfo($company, $company_signatory_agreements_request, $contentType);
        return $response;
    }

    /**
     * Operation companyBusinessDetailsWithHttpInfo
     *
     * Company Business Details Component
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyBusinessDetails'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyBusinessDetailsWithHttpInfo($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['companyBusinessDetails'][0])
    {
        $request = $this->companyBusinessDetailsRequest($company, $company_signatory_agreements_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyBusinessDetailsAsync
     *
     * Company Business Details Component
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyBusinessDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyBusinessDetailsAsync($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['companyBusinessDetails'][0])
    {
        return $this->companyBusinessDetailsAsyncWithHttpInfo($company, $company_signatory_agreements_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyBusinessDetailsAsyncWithHttpInfo
     *
     * Company Business Details Component
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyBusinessDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyBusinessDetailsAsyncWithHttpInfo($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['companyBusinessDetails'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyBusinessDetailsRequest($company, $company_signatory_agreements_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyBusinessDetails'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyBusinessDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyBusinessDetailsRequest($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['companyBusinessDetails'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyBusinessDetails'
            );
        }



        $resourcePath = '/companies/{company}/components/business_details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($company_signatory_agreements_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($company_signatory_agreements_request));
            } else {
                $httpBody = $company_signatory_agreements_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyConnectBankAccount
     *
     * Company Connect Bank Account
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyConnectBankAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyConnectBankAccount($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyConnectBankAccount'][0])
    {
        list($response) = $this->companyConnectBankAccountWithHttpInfo($company, $company_verification_documents_request, $contentType);
        return $response;
    }

    /**
     * Operation companyConnectBankAccountWithHttpInfo
     *
     * Company Connect Bank Account
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyConnectBankAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyConnectBankAccountWithHttpInfo($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyConnectBankAccount'][0])
    {
        $request = $this->companyConnectBankAccountRequest($company, $company_verification_documents_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyConnectBankAccountAsync
     *
     * Company Connect Bank Account
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyConnectBankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyConnectBankAccountAsync($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyConnectBankAccount'][0])
    {
        return $this->companyConnectBankAccountAsyncWithHttpInfo($company, $company_verification_documents_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyConnectBankAccountAsyncWithHttpInfo
     *
     * Company Connect Bank Account
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyConnectBankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyConnectBankAccountAsyncWithHttpInfo($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyConnectBankAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyConnectBankAccountRequest($company, $company_verification_documents_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyConnectBankAccount'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyConnectBankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyConnectBankAccountRequest($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyConnectBankAccount'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyConnectBankAccount'
            );
        }



        $resourcePath = '/companies/{company}/components/connect_bank_account';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($company_verification_documents_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($company_verification_documents_request));
            } else {
                $httpBody = $company_verification_documents_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyDetails
     *
     * Company Details
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyDetails'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyDetails($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyDetails'][0])
    {
        list($response) = $this->companyDetailsWithHttpInfo($company, $generate_onboard_link_request, $contentType);
        return $response;
    }

    /**
     * Operation companyDetailsWithHttpInfo
     *
     * Company Details
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyDetails'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyDetailsWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyDetails'][0])
    {
        $request = $this->companyDetailsRequest($company, $generate_onboard_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyDetailsAsync
     *
     * Company Details
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyDetailsAsync($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyDetails'][0])
    {
        return $this->companyDetailsAsyncWithHttpInfo($company, $generate_onboard_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyDetailsAsyncWithHttpInfo
     *
     * Company Details
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyDetailsAsyncWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyDetails'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyDetailsRequest($company, $generate_onboard_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyDetails'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyDetailsRequest($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyDetails'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyDetails'
            );
        }



        $resourcePath = '/companies/{company}/components/details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($generate_onboard_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($generate_onboard_link_request));
            } else {
                $httpBody = $generate_onboard_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyEmployeeSetup
     *
     * Company-Defined Employee Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyEmployeeSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyEmployeeSetup($company, string $contentType = self::contentTypes['companyEmployeeSetup'][0])
    {
        list($response) = $this->companyEmployeeSetupWithHttpInfo($company, $contentType);
        return $response;
    }

    /**
     * Operation companyEmployeeSetupWithHttpInfo
     *
     * Company-Defined Employee Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyEmployeeSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyEmployeeSetupWithHttpInfo($company, string $contentType = self::contentTypes['companyEmployeeSetup'][0])
    {
        $request = $this->companyEmployeeSetupRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyEmployeeSetupAsync
     *
     * Company-Defined Employee Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyEmployeeSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEmployeeSetupAsync($company, string $contentType = self::contentTypes['companyEmployeeSetup'][0])
    {
        return $this->companyEmployeeSetupAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyEmployeeSetupAsyncWithHttpInfo
     *
     * Company-Defined Employee Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyEmployeeSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyEmployeeSetupAsyncWithHttpInfo($company, string $contentType = self::contentTypes['companyEmployeeSetup'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyEmployeeSetupRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyEmployeeSetup'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyEmployeeSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyEmployeeSetupRequest($company, string $contentType = self::contentTypes['companyEmployeeSetup'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyEmployeeSetup'
            );
        }


        $resourcePath = '/companies/{company}/components/employee_setup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyFilingAuthorization
     *
     * Company Filing Authorization
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyFilingAuthorizationRequest $company_filing_authorization_request company_filing_authorization_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyFilingAuthorization'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyFilingAuthorization($company, $company_filing_authorization_request = null, string $contentType = self::contentTypes['companyFilingAuthorization'][0])
    {
        list($response) = $this->companyFilingAuthorizationWithHttpInfo($company, $company_filing_authorization_request, $contentType);
        return $response;
    }

    /**
     * Operation companyFilingAuthorizationWithHttpInfo
     *
     * Company Filing Authorization
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyFilingAuthorizationRequest $company_filing_authorization_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyFilingAuthorization'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyFilingAuthorizationWithHttpInfo($company, $company_filing_authorization_request = null, string $contentType = self::contentTypes['companyFilingAuthorization'][0])
    {
        $request = $this->companyFilingAuthorizationRequest($company, $company_filing_authorization_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyFilingAuthorizationAsync
     *
     * Company Filing Authorization
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyFilingAuthorizationRequest $company_filing_authorization_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyFilingAuthorization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyFilingAuthorizationAsync($company, $company_filing_authorization_request = null, string $contentType = self::contentTypes['companyFilingAuthorization'][0])
    {
        return $this->companyFilingAuthorizationAsyncWithHttpInfo($company, $company_filing_authorization_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyFilingAuthorizationAsyncWithHttpInfo
     *
     * Company Filing Authorization
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyFilingAuthorizationRequest $company_filing_authorization_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyFilingAuthorization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyFilingAuthorizationAsyncWithHttpInfo($company, $company_filing_authorization_request = null, string $contentType = self::contentTypes['companyFilingAuthorization'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyFilingAuthorizationRequest($company, $company_filing_authorization_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyFilingAuthorization'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyFilingAuthorizationRequest $company_filing_authorization_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyFilingAuthorization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyFilingAuthorizationRequest($company, $company_filing_authorization_request = null, string $contentType = self::contentTypes['companyFilingAuthorization'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyFilingAuthorization'
            );
        }



        $resourcePath = '/companies/{company}/components/filing_authorization';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($company_filing_authorization_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($company_filing_authorization_request));
            } else {
                $httpBody = $company_filing_authorization_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyPayHistory
     *
     * Company Pay History
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyPayHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyPayHistory($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyPayHistory'][0])
    {
        list($response) = $this->companyPayHistoryWithHttpInfo($company, $company_verification_documents_request, $contentType);
        return $response;
    }

    /**
     * Operation companyPayHistoryWithHttpInfo
     *
     * Company Pay History
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyPayHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyPayHistoryWithHttpInfo($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyPayHistory'][0])
    {
        $request = $this->companyPayHistoryRequest($company, $company_verification_documents_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyPayHistoryAsync
     *
     * Company Pay History
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyPayHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyPayHistoryAsync($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyPayHistory'][0])
    {
        return $this->companyPayHistoryAsyncWithHttpInfo($company, $company_verification_documents_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyPayHistoryAsyncWithHttpInfo
     *
     * Company Pay History
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyPayHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyPayHistoryAsyncWithHttpInfo($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyPayHistory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyPayHistoryRequest($company, $company_verification_documents_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyPayHistory'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyPayHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyPayHistoryRequest($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyPayHistory'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyPayHistory'
            );
        }



        $resourcePath = '/companies/{company}/components/pay_history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($company_verification_documents_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($company_verification_documents_request));
            } else {
                $httpBody = $company_verification_documents_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyPaymentSetup
     *
     * Company Payment Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyPaymentSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyPaymentSetup($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyPaymentSetup'][0])
    {
        list($response) = $this->companyPaymentSetupWithHttpInfo($company, $generate_onboard_link_request, $contentType);
        return $response;
    }

    /**
     * Operation companyPaymentSetupWithHttpInfo
     *
     * Company Payment Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyPaymentSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyPaymentSetupWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyPaymentSetup'][0])
    {
        $request = $this->companyPaymentSetupRequest($company, $generate_onboard_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyPaymentSetupAsync
     *
     * Company Payment Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyPaymentSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyPaymentSetupAsync($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyPaymentSetup'][0])
    {
        return $this->companyPaymentSetupAsyncWithHttpInfo($company, $generate_onboard_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyPaymentSetupAsyncWithHttpInfo
     *
     * Company Payment Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyPaymentSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyPaymentSetupAsyncWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyPaymentSetup'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyPaymentSetupRequest($company, $generate_onboard_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyPaymentSetup'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyPaymentSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyPaymentSetupRequest($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyPaymentSetup'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyPaymentSetup'
            );
        }



        $resourcePath = '/companies/{company}/components/payment_setup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($generate_onboard_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($generate_onboard_link_request));
            } else {
                $httpBody = $generate_onboard_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyProgressTracker
     *
     * Company Progress Tracker Component
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyProgressTracker'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object
     */
    public function companyProgressTracker($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyProgressTracker'][0])
    {
        list($response) = $this->companyProgressTrackerWithHttpInfo($company, $company_verification_documents_request, $contentType);
        return $response;
    }

    /**
     * Operation companyProgressTrackerWithHttpInfo
     *
     * Company Progress Tracker Component
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyProgressTracker'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyProgressTrackerWithHttpInfo($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyProgressTracker'][0])
    {
        $request = $this->companyProgressTrackerRequest($company, $company_verification_documents_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GenerateOnboardLink1200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GenerateOnboardLink1200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyProgressTrackerAsync
     *
     * Company Progress Tracker Component
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyProgressTracker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyProgressTrackerAsync($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyProgressTracker'][0])
    {
        return $this->companyProgressTrackerAsyncWithHttpInfo($company, $company_verification_documents_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyProgressTrackerAsyncWithHttpInfo
     *
     * Company Progress Tracker Component
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyProgressTracker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyProgressTrackerAsyncWithHttpInfo($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyProgressTracker'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
        $request = $this->companyProgressTrackerRequest($company, $company_verification_documents_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyProgressTracker'
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyProgressTracker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyProgressTrackerRequest($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyProgressTracker'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyProgressTracker'
            );
        }



        $resourcePath = '/companies/{company}/components/progress_tracker';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($company_verification_documents_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($company_verification_documents_request));
            } else {
                $httpBody = $company_verification_documents_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyReports
     *
     * Company Reports
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyReports'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyReports($company, string $contentType = self::contentTypes['companyReports'][0])
    {
        list($response) = $this->companyReportsWithHttpInfo($company, $contentType);
        return $response;
    }

    /**
     * Operation companyReportsWithHttpInfo
     *
     * Company Reports
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyReports'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyReportsWithHttpInfo($company, string $contentType = self::contentTypes['companyReports'][0])
    {
        $request = $this->companyReportsRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyReportsAsync
     *
     * Company Reports
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyReports'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyReportsAsync($company, string $contentType = self::contentTypes['companyReports'][0])
    {
        return $this->companyReportsAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyReportsAsyncWithHttpInfo
     *
     * Company Reports
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyReports'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyReportsAsyncWithHttpInfo($company, string $contentType = self::contentTypes['companyReports'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyReportsRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyReports'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyReports'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyReportsRequest($company, string $contentType = self::contentTypes['companyReports'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyReports'
            );
        }


        $resourcePath = '/companies/{company}/components/company_reports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companySignatoryAgreements
     *
     * Company Signatory Agreements
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companySignatoryAgreements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companySignatoryAgreements($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['companySignatoryAgreements'][0])
    {
        list($response) = $this->companySignatoryAgreementsWithHttpInfo($company, $company_signatory_agreements_request, $contentType);
        return $response;
    }

    /**
     * Operation companySignatoryAgreementsWithHttpInfo
     *
     * Company Signatory Agreements
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companySignatoryAgreements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companySignatoryAgreementsWithHttpInfo($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['companySignatoryAgreements'][0])
    {
        $request = $this->companySignatoryAgreementsRequest($company, $company_signatory_agreements_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companySignatoryAgreementsAsync
     *
     * Company Signatory Agreements
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companySignatoryAgreements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companySignatoryAgreementsAsync($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['companySignatoryAgreements'][0])
    {
        return $this->companySignatoryAgreementsAsyncWithHttpInfo($company, $company_signatory_agreements_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companySignatoryAgreementsAsyncWithHttpInfo
     *
     * Company Signatory Agreements
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companySignatoryAgreements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companySignatoryAgreementsAsyncWithHttpInfo($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['companySignatoryAgreements'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companySignatoryAgreementsRequest($company, $company_signatory_agreements_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companySignatoryAgreements'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companySignatoryAgreements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companySignatoryAgreementsRequest($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['companySignatoryAgreements'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companySignatoryAgreements'
            );
        }



        $resourcePath = '/companies/{company}/components/signatory_agreements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($company_signatory_agreements_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($company_signatory_agreements_request));
            } else {
                $httpBody = $company_signatory_agreements_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyTaxDocuments
     *
     * Company Tax Documents
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyTaxDocuments($company, string $contentType = self::contentTypes['companyTaxDocuments'][0])
    {
        list($response) = $this->companyTaxDocumentsWithHttpInfo($company, $contentType);
        return $response;
    }

    /**
     * Operation companyTaxDocumentsWithHttpInfo
     *
     * Company Tax Documents
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyTaxDocumentsWithHttpInfo($company, string $contentType = self::contentTypes['companyTaxDocuments'][0])
    {
        $request = $this->companyTaxDocumentsRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyTaxDocumentsAsync
     *
     * Company Tax Documents
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyTaxDocumentsAsync($company, string $contentType = self::contentTypes['companyTaxDocuments'][0])
    {
        return $this->companyTaxDocumentsAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyTaxDocumentsAsyncWithHttpInfo
     *
     * Company Tax Documents
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyTaxDocumentsAsyncWithHttpInfo($company, string $contentType = self::contentTypes['companyTaxDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyTaxDocumentsRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyTaxDocuments'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyTaxDocumentsRequest($company, string $contentType = self::contentTypes['companyTaxDocuments'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyTaxDocuments'
            );
        }


        $resourcePath = '/companies/{company}/components/tax_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyTaxSetup
     *
     * Company Tax Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyTaxSetupRequest $company_tax_setup_request company_tax_setup_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTaxSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyTaxSetup($company, $company_tax_setup_request = null, string $contentType = self::contentTypes['companyTaxSetup'][0])
    {
        list($response) = $this->companyTaxSetupWithHttpInfo($company, $company_tax_setup_request, $contentType);
        return $response;
    }

    /**
     * Operation companyTaxSetupWithHttpInfo
     *
     * Company Tax Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyTaxSetupRequest $company_tax_setup_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTaxSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyTaxSetupWithHttpInfo($company, $company_tax_setup_request = null, string $contentType = self::contentTypes['companyTaxSetup'][0])
    {
        $request = $this->companyTaxSetupRequest($company, $company_tax_setup_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyTaxSetupAsync
     *
     * Company Tax Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyTaxSetupRequest $company_tax_setup_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTaxSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyTaxSetupAsync($company, $company_tax_setup_request = null, string $contentType = self::contentTypes['companyTaxSetup'][0])
    {
        return $this->companyTaxSetupAsyncWithHttpInfo($company, $company_tax_setup_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyTaxSetupAsyncWithHttpInfo
     *
     * Company Tax Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyTaxSetupRequest $company_tax_setup_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTaxSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyTaxSetupAsyncWithHttpInfo($company, $company_tax_setup_request = null, string $contentType = self::contentTypes['companyTaxSetup'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyTaxSetupRequest($company, $company_tax_setup_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyTaxSetup'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyTaxSetupRequest $company_tax_setup_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTaxSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyTaxSetupRequest($company, $company_tax_setup_request = null, string $contentType = self::contentTypes['companyTaxSetup'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyTaxSetup'
            );
        }



        $resourcePath = '/companies/{company}/components/tax_setup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($company_tax_setup_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($company_tax_setup_request));
            } else {
                $httpBody = $company_tax_setup_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyTeamSetup
     *
     * Company Team Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTeamSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyTeamSetup($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyTeamSetup'][0])
    {
        list($response) = $this->companyTeamSetupWithHttpInfo($company, $company_verification_documents_request, $contentType);
        return $response;
    }

    /**
     * Operation companyTeamSetupWithHttpInfo
     *
     * Company Team Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTeamSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyTeamSetupWithHttpInfo($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyTeamSetup'][0])
    {
        $request = $this->companyTeamSetupRequest($company, $company_verification_documents_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyTeamSetupAsync
     *
     * Company Team Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTeamSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyTeamSetupAsync($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyTeamSetup'][0])
    {
        return $this->companyTeamSetupAsyncWithHttpInfo($company, $company_verification_documents_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyTeamSetupAsyncWithHttpInfo
     *
     * Company Team Setup
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTeamSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyTeamSetupAsyncWithHttpInfo($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyTeamSetup'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyTeamSetupRequest($company, $company_verification_documents_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyTeamSetup'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTeamSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyTeamSetupRequest($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyTeamSetup'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyTeamSetup'
            );
        }



        $resourcePath = '/companies/{company}/components/team_setup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($company_verification_documents_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($company_verification_documents_request));
            } else {
                $httpBody = $company_verification_documents_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyTermsOfService
     *
     * Company Terms of Service
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTermsOfService'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function companyTermsOfService($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyTermsOfService'][0])
    {
        list($response) = $this->companyTermsOfServiceWithHttpInfo($company, $generate_onboard_link_request, $contentType);
        return $response;
    }

    /**
     * Operation companyTermsOfServiceWithHttpInfo
     *
     * Company Terms of Service
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTermsOfService'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyTermsOfServiceWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyTermsOfService'][0])
    {
        $request = $this->companyTermsOfServiceRequest($company, $generate_onboard_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyTermsOfServiceAsync
     *
     * Company Terms of Service
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTermsOfService'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyTermsOfServiceAsync($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyTermsOfService'][0])
    {
        return $this->companyTermsOfServiceAsyncWithHttpInfo($company, $generate_onboard_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyTermsOfServiceAsyncWithHttpInfo
     *
     * Company Terms of Service
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTermsOfService'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyTermsOfServiceAsyncWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyTermsOfService'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->companyTermsOfServiceRequest($company, $generate_onboard_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyTermsOfService'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyTermsOfService'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyTermsOfServiceRequest($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['companyTermsOfService'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyTermsOfService'
            );
        }



        $resourcePath = '/companies/{company}/components/terms_of_service';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($generate_onboard_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($generate_onboard_link_request));
            } else {
                $httpBody = $generate_onboard_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation companyVerificationDocuments
     *
     * Company Verification Documents
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyVerificationDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object
     */
    public function companyVerificationDocuments($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyVerificationDocuments'][0])
    {
        list($response) = $this->companyVerificationDocumentsWithHttpInfo($company, $company_verification_documents_request, $contentType);
        return $response;
    }

    /**
     * Operation companyVerificationDocumentsWithHttpInfo
     *
     * Company Verification Documents
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyVerificationDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function companyVerificationDocumentsWithHttpInfo($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyVerificationDocuments'][0])
    {
        $request = $this->companyVerificationDocumentsRequest($company, $company_verification_documents_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GenerateOnboardLink1200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GenerateOnboardLink1200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation companyVerificationDocumentsAsync
     *
     * Company Verification Documents
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyVerificationDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyVerificationDocumentsAsync($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyVerificationDocuments'][0])
    {
        return $this->companyVerificationDocumentsAsyncWithHttpInfo($company, $company_verification_documents_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation companyVerificationDocumentsAsyncWithHttpInfo
     *
     * Company Verification Documents
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyVerificationDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function companyVerificationDocumentsAsyncWithHttpInfo($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyVerificationDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
        $request = $this->companyVerificationDocumentsRequest($company, $company_verification_documents_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'companyVerificationDocuments'
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanyVerificationDocumentsRequest $company_verification_documents_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['companyVerificationDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function companyVerificationDocumentsRequest($company, $company_verification_documents_request = null, string $contentType = self::contentTypes['companyVerificationDocuments'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling companyVerificationDocuments'
            );
        }



        $resourcePath = '/companies/{company}/components/verification_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($company_verification_documents_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($company_verification_documents_request));
            } else {
                $httpBody = $company_verification_documents_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation contractorTaxDocuments
     *
     * Contractor Tax Documents
     *
     * @param  string $contractor ID of the contractor for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['contractorTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function contractorTaxDocuments($contractor, string $contentType = self::contentTypes['contractorTaxDocuments'][0])
    {
        list($response) = $this->contractorTaxDocumentsWithHttpInfo($contractor, $contentType);
        return $response;
    }

    /**
     * Operation contractorTaxDocumentsWithHttpInfo
     *
     * Contractor Tax Documents
     *
     * @param  string $contractor ID of the contractor for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['contractorTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function contractorTaxDocumentsWithHttpInfo($contractor, string $contentType = self::contentTypes['contractorTaxDocuments'][0])
    {
        $request = $this->contractorTaxDocumentsRequest($contractor, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation contractorTaxDocumentsAsync
     *
     * Contractor Tax Documents
     *
     * @param  string $contractor ID of the contractor for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['contractorTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contractorTaxDocumentsAsync($contractor, string $contentType = self::contentTypes['contractorTaxDocuments'][0])
    {
        return $this->contractorTaxDocumentsAsyncWithHttpInfo($contractor, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation contractorTaxDocumentsAsyncWithHttpInfo
     *
     * Contractor Tax Documents
     *
     * @param  string $contractor ID of the contractor for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['contractorTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contractorTaxDocumentsAsyncWithHttpInfo($contractor, string $contentType = self::contentTypes['contractorTaxDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->contractorTaxDocumentsRequest($contractor, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'contractorTaxDocuments'
     *
     * @param  string $contractor ID of the contractor for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['contractorTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function contractorTaxDocumentsRequest($contractor, string $contentType = self::contentTypes['contractorTaxDocuments'][0])
    {

        // verify the required parameter 'contractor' is set
        if ($contractor === null || (is_array($contractor) && count($contractor) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractor when calling contractorTaxDocuments'
            );
        }


        $resourcePath = '/contractors/{contractor}/components/tax_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contractor !== null) {
            $resourcePath = str_replace(
                '{' . 'contractor' . '}',
                ObjectSerializer::toPathValue($contractor),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createABankAccount
     *
     * Create a bank account
     *
     * @param  \OpenAPI\Client\Model\CreateABankAccountRequest $create_a_bank_account_request create_a_bank_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createABankAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createABankAccount($create_a_bank_account_request = null, string $contentType = self::contentTypes['createABankAccount'][0])
    {
        $this->createABankAccountWithHttpInfo($create_a_bank_account_request, $contentType);
    }

    /**
     * Operation createABankAccountWithHttpInfo
     *
     * Create a bank account
     *
     * @param  \OpenAPI\Client\Model\CreateABankAccountRequest $create_a_bank_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createABankAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createABankAccountWithHttpInfo($create_a_bank_account_request = null, string $contentType = self::contentTypes['createABankAccount'][0])
    {
        $request = $this->createABankAccountRequest($create_a_bank_account_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createABankAccountAsync
     *
     * Create a bank account
     *
     * @param  \OpenAPI\Client\Model\CreateABankAccountRequest $create_a_bank_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createABankAccountAsync($create_a_bank_account_request = null, string $contentType = self::contentTypes['createABankAccount'][0])
    {
        return $this->createABankAccountAsyncWithHttpInfo($create_a_bank_account_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createABankAccountAsyncWithHttpInfo
     *
     * Create a bank account
     *
     * @param  \OpenAPI\Client\Model\CreateABankAccountRequest $create_a_bank_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createABankAccountAsyncWithHttpInfo($create_a_bank_account_request = null, string $contentType = self::contentTypes['createABankAccount'][0])
    {
        $returnType = '';
        $request = $this->createABankAccountRequest($create_a_bank_account_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createABankAccount'
     *
     * @param  \OpenAPI\Client\Model\CreateABankAccountRequest $create_a_bank_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createABankAccountRequest($create_a_bank_account_request = null, string $contentType = self::contentTypes['createABankAccount'][0])
    {



        $resourcePath = '/bank_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_a_bank_account_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_a_bank_account_request));
            } else {
                $httpBody = $create_a_bank_account_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createACompanyBenefit
     *
     * Create a company benefit
     *
     * @param  \OpenAPI\Client\Model\CreateACompanyBenefitRequest $create_a_company_benefit_request create_a_company_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createACompanyBenefit($create_a_company_benefit_request = null, string $contentType = self::contentTypes['createACompanyBenefit'][0])
    {
        $this->createACompanyBenefitWithHttpInfo($create_a_company_benefit_request, $contentType);
    }

    /**
     * Operation createACompanyBenefitWithHttpInfo
     *
     * Create a company benefit
     *
     * @param  \OpenAPI\Client\Model\CreateACompanyBenefitRequest $create_a_company_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createACompanyBenefitWithHttpInfo($create_a_company_benefit_request = null, string $contentType = self::contentTypes['createACompanyBenefit'][0])
    {
        $request = $this->createACompanyBenefitRequest($create_a_company_benefit_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createACompanyBenefitAsync
     *
     * Create a company benefit
     *
     * @param  \OpenAPI\Client\Model\CreateACompanyBenefitRequest $create_a_company_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createACompanyBenefitAsync($create_a_company_benefit_request = null, string $contentType = self::contentTypes['createACompanyBenefit'][0])
    {
        return $this->createACompanyBenefitAsyncWithHttpInfo($create_a_company_benefit_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createACompanyBenefitAsyncWithHttpInfo
     *
     * Create a company benefit
     *
     * @param  \OpenAPI\Client\Model\CreateACompanyBenefitRequest $create_a_company_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createACompanyBenefitAsyncWithHttpInfo($create_a_company_benefit_request = null, string $contentType = self::contentTypes['createACompanyBenefit'][0])
    {
        $returnType = '';
        $request = $this->createACompanyBenefitRequest($create_a_company_benefit_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createACompanyBenefit'
     *
     * @param  \OpenAPI\Client\Model\CreateACompanyBenefitRequest $create_a_company_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createACompanyBenefitRequest($create_a_company_benefit_request = null, string $contentType = self::contentTypes['createACompanyBenefit'][0])
    {



        $resourcePath = '/company_benefits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_a_company_benefit_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_a_company_benefit_request));
            } else {
                $httpBody = $create_a_company_benefit_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createACompanyProvidedDocument
     *
     * Create a company provided document
     *
     * @param  \OpenAPI\Client\Model\CreateACompanyProvidedDocumentRequest $create_a_company_provided_document_request create_a_company_provided_document_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner|object
     */
    public function createACompanyProvidedDocument($create_a_company_provided_document_request = null, string $contentType = self::contentTypes['createACompanyProvidedDocument'][0])
    {
        list($response) = $this->createACompanyProvidedDocumentWithHttpInfo($create_a_company_provided_document_request, $contentType);
        return $response;
    }

    /**
     * Operation createACompanyProvidedDocumentWithHttpInfo
     *
     * Create a company provided document
     *
     * @param  \OpenAPI\Client\Model\CreateACompanyProvidedDocumentRequest $create_a_company_provided_document_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createACompanyProvidedDocumentWithHttpInfo($create_a_company_provided_document_request = null, string $contentType = self::contentTypes['createACompanyProvidedDocument'][0])
    {
        $request = $this->createACompanyProvidedDocumentRequest($create_a_company_provided_document_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createACompanyProvidedDocumentAsync
     *
     * Create a company provided document
     *
     * @param  \OpenAPI\Client\Model\CreateACompanyProvidedDocumentRequest $create_a_company_provided_document_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createACompanyProvidedDocumentAsync($create_a_company_provided_document_request = null, string $contentType = self::contentTypes['createACompanyProvidedDocument'][0])
    {
        return $this->createACompanyProvidedDocumentAsyncWithHttpInfo($create_a_company_provided_document_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createACompanyProvidedDocumentAsyncWithHttpInfo
     *
     * Create a company provided document
     *
     * @param  \OpenAPI\Client\Model\CreateACompanyProvidedDocumentRequest $create_a_company_provided_document_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createACompanyProvidedDocumentAsyncWithHttpInfo($create_a_company_provided_document_request = null, string $contentType = self::contentTypes['createACompanyProvidedDocument'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner';
        $request = $this->createACompanyProvidedDocumentRequest($create_a_company_provided_document_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createACompanyProvidedDocument'
     *
     * @param  \OpenAPI\Client\Model\CreateACompanyProvidedDocumentRequest $create_a_company_provided_document_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createACompanyProvidedDocumentRequest($create_a_company_provided_document_request = null, string $contentType = self::contentTypes['createACompanyProvidedDocument'][0])
    {



        $resourcePath = '/company_provided_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_a_company_provided_document_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_a_company_provided_document_request));
            } else {
                $httpBody = $create_a_company_provided_document_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAContractor
     *
     * Create a contractor
     *
     * @param  \OpenAPI\Client\Model\CreateAContractorRequest $create_a_contractor_request create_a_contractor_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAContractor'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function createAContractor($create_a_contractor_request = null, string $contentType = self::contentTypes['createAContractor'][0])
    {
        list($response) = $this->createAContractorWithHttpInfo($create_a_contractor_request, $contentType);
        return $response;
    }

    /**
     * Operation createAContractorWithHttpInfo
     *
     * Create a contractor
     *
     * @param  \OpenAPI\Client\Model\CreateAContractorRequest $create_a_contractor_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAContractor'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAContractorWithHttpInfo($create_a_contractor_request = null, string $contentType = self::contentTypes['createAContractor'][0])
    {
        $request = $this->createAContractorRequest($create_a_contractor_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAContractorAsync
     *
     * Create a contractor
     *
     * @param  \OpenAPI\Client\Model\CreateAContractorRequest $create_a_contractor_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAContractor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAContractorAsync($create_a_contractor_request = null, string $contentType = self::contentTypes['createAContractor'][0])
    {
        return $this->createAContractorAsyncWithHttpInfo($create_a_contractor_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAContractorAsyncWithHttpInfo
     *
     * Create a contractor
     *
     * @param  \OpenAPI\Client\Model\CreateAContractorRequest $create_a_contractor_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAContractor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAContractorAsyncWithHttpInfo($create_a_contractor_request = null, string $contentType = self::contentTypes['createAContractor'][0])
    {
        $returnType = 'object';
        $request = $this->createAContractorRequest($create_a_contractor_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAContractor'
     *
     * @param  \OpenAPI\Client\Model\CreateAContractorRequest $create_a_contractor_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAContractor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAContractorRequest($create_a_contractor_request = null, string $contentType = self::contentTypes['createAContractor'][0])
    {



        $resourcePath = '/contractors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_a_contractor_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_a_contractor_request));
            } else {
                $httpBody = $create_a_contractor_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAContractorPayment
     *
     * Create a contractor payment
     *
     * @param  \OpenAPI\Client\Model\CreateAContractorPaymentRequest $create_a_contractor_payment_request create_a_contractor_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAContractorPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function createAContractorPayment($create_a_contractor_payment_request = null, string $contentType = self::contentTypes['createAContractorPayment'][0])
    {
        list($response) = $this->createAContractorPaymentWithHttpInfo($create_a_contractor_payment_request, $contentType);
        return $response;
    }

    /**
     * Operation createAContractorPaymentWithHttpInfo
     *
     * Create a contractor payment
     *
     * @param  \OpenAPI\Client\Model\CreateAContractorPaymentRequest $create_a_contractor_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAContractorPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAContractorPaymentWithHttpInfo($create_a_contractor_payment_request = null, string $contentType = self::contentTypes['createAContractorPayment'][0])
    {
        $request = $this->createAContractorPaymentRequest($create_a_contractor_payment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAContractorPaymentAsync
     *
     * Create a contractor payment
     *
     * @param  \OpenAPI\Client\Model\CreateAContractorPaymentRequest $create_a_contractor_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAContractorPaymentAsync($create_a_contractor_payment_request = null, string $contentType = self::contentTypes['createAContractorPayment'][0])
    {
        return $this->createAContractorPaymentAsyncWithHttpInfo($create_a_contractor_payment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAContractorPaymentAsyncWithHttpInfo
     *
     * Create a contractor payment
     *
     * @param  \OpenAPI\Client\Model\CreateAContractorPaymentRequest $create_a_contractor_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAContractorPaymentAsyncWithHttpInfo($create_a_contractor_payment_request = null, string $contentType = self::contentTypes['createAContractorPayment'][0])
    {
        $returnType = 'object';
        $request = $this->createAContractorPaymentRequest($create_a_contractor_payment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAContractorPayment'
     *
     * @param  \OpenAPI\Client\Model\CreateAContractorPaymentRequest $create_a_contractor_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAContractorPaymentRequest($create_a_contractor_payment_request = null, string $contentType = self::contentTypes['createAContractorPayment'][0])
    {



        $resourcePath = '/contractor_payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_a_contractor_payment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_a_contractor_payment_request));
            } else {
                $httpBody = $create_a_contractor_payment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAPaySchedule
     *
     * Create a pay schedule
     *
     * @param  \OpenAPI\Client\Model\CreateAPayScheduleRequest $create_a_pay_schedule_request create_a_pay_schedule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPaySchedule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAPaySchedule200Response|object
     */
    public function createAPaySchedule($create_a_pay_schedule_request = null, string $contentType = self::contentTypes['createAPaySchedule'][0])
    {
        list($response) = $this->createAPayScheduleWithHttpInfo($create_a_pay_schedule_request, $contentType);
        return $response;
    }

    /**
     * Operation createAPayScheduleWithHttpInfo
     *
     * Create a pay schedule
     *
     * @param  \OpenAPI\Client\Model\CreateAPayScheduleRequest $create_a_pay_schedule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPaySchedule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAPaySchedule200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAPayScheduleWithHttpInfo($create_a_pay_schedule_request = null, string $contentType = self::contentTypes['createAPaySchedule'][0])
    {
        $request = $this->createAPayScheduleRequest($create_a_pay_schedule_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAPaySchedule200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAPaySchedule200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAPaySchedule200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAPaySchedule200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAPaySchedule200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAPayScheduleAsync
     *
     * Create a pay schedule
     *
     * @param  \OpenAPI\Client\Model\CreateAPayScheduleRequest $create_a_pay_schedule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPaySchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAPayScheduleAsync($create_a_pay_schedule_request = null, string $contentType = self::contentTypes['createAPaySchedule'][0])
    {
        return $this->createAPayScheduleAsyncWithHttpInfo($create_a_pay_schedule_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAPayScheduleAsyncWithHttpInfo
     *
     * Create a pay schedule
     *
     * @param  \OpenAPI\Client\Model\CreateAPayScheduleRequest $create_a_pay_schedule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPaySchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAPayScheduleAsyncWithHttpInfo($create_a_pay_schedule_request = null, string $contentType = self::contentTypes['createAPaySchedule'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAPaySchedule200Response';
        $request = $this->createAPayScheduleRequest($create_a_pay_schedule_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAPaySchedule'
     *
     * @param  \OpenAPI\Client\Model\CreateAPayScheduleRequest $create_a_pay_schedule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPaySchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAPayScheduleRequest($create_a_pay_schedule_request = null, string $contentType = self::contentTypes['createAPaySchedule'][0])
    {



        $resourcePath = '/pay_schedules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_a_pay_schedule_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_a_pay_schedule_request));
            } else {
                $httpBody = $create_a_pay_schedule_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAPayrollItem
     *
     * Create a payroll item
     *
     * @param  \OpenAPI\Client\Model\CreateAPayrollItemRequest $create_a_payroll_item_request create_a_payroll_item_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPayrollItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createAPayrollItem($create_a_payroll_item_request = null, string $contentType = self::contentTypes['createAPayrollItem'][0])
    {
        $this->createAPayrollItemWithHttpInfo($create_a_payroll_item_request, $contentType);
    }

    /**
     * Operation createAPayrollItemWithHttpInfo
     *
     * Create a payroll item
     *
     * @param  \OpenAPI\Client\Model\CreateAPayrollItemRequest $create_a_payroll_item_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPayrollItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAPayrollItemWithHttpInfo($create_a_payroll_item_request = null, string $contentType = self::contentTypes['createAPayrollItem'][0])
    {
        $request = $this->createAPayrollItemRequest($create_a_payroll_item_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createAPayrollItemAsync
     *
     * Create a payroll item
     *
     * @param  \OpenAPI\Client\Model\CreateAPayrollItemRequest $create_a_payroll_item_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAPayrollItemAsync($create_a_payroll_item_request = null, string $contentType = self::contentTypes['createAPayrollItem'][0])
    {
        return $this->createAPayrollItemAsyncWithHttpInfo($create_a_payroll_item_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAPayrollItemAsyncWithHttpInfo
     *
     * Create a payroll item
     *
     * @param  \OpenAPI\Client\Model\CreateAPayrollItemRequest $create_a_payroll_item_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAPayrollItemAsyncWithHttpInfo($create_a_payroll_item_request = null, string $contentType = self::contentTypes['createAPayrollItem'][0])
    {
        $returnType = '';
        $request = $this->createAPayrollItemRequest($create_a_payroll_item_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAPayrollItem'
     *
     * @param  \OpenAPI\Client\Model\CreateAPayrollItemRequest $create_a_payroll_item_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAPayrollItemRequest($create_a_payroll_item_request = null, string $contentType = self::contentTypes['createAPayrollItem'][0])
    {



        $resourcePath = '/payroll_items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_a_payroll_item_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_a_payroll_item_request));
            } else {
                $httpBody = $create_a_payroll_item_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAPostTaxDeduction
     *
     * Create a post-tax deduction
     *
     * @param  \OpenAPI\Client\Model\CreateAPostTaxDeductionRequest $create_a_post_tax_deduction_request create_a_post_tax_deduction_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createAPostTaxDeduction($create_a_post_tax_deduction_request = null, string $contentType = self::contentTypes['createAPostTaxDeduction'][0])
    {
        $this->createAPostTaxDeductionWithHttpInfo($create_a_post_tax_deduction_request, $contentType);
    }

    /**
     * Operation createAPostTaxDeductionWithHttpInfo
     *
     * Create a post-tax deduction
     *
     * @param  \OpenAPI\Client\Model\CreateAPostTaxDeductionRequest $create_a_post_tax_deduction_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAPostTaxDeductionWithHttpInfo($create_a_post_tax_deduction_request = null, string $contentType = self::contentTypes['createAPostTaxDeduction'][0])
    {
        $request = $this->createAPostTaxDeductionRequest($create_a_post_tax_deduction_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createAPostTaxDeductionAsync
     *
     * Create a post-tax deduction
     *
     * @param  \OpenAPI\Client\Model\CreateAPostTaxDeductionRequest $create_a_post_tax_deduction_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAPostTaxDeductionAsync($create_a_post_tax_deduction_request = null, string $contentType = self::contentTypes['createAPostTaxDeduction'][0])
    {
        return $this->createAPostTaxDeductionAsyncWithHttpInfo($create_a_post_tax_deduction_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAPostTaxDeductionAsyncWithHttpInfo
     *
     * Create a post-tax deduction
     *
     * @param  \OpenAPI\Client\Model\CreateAPostTaxDeductionRequest $create_a_post_tax_deduction_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAPostTaxDeductionAsyncWithHttpInfo($create_a_post_tax_deduction_request = null, string $contentType = self::contentTypes['createAPostTaxDeduction'][0])
    {
        $returnType = '';
        $request = $this->createAPostTaxDeductionRequest($create_a_post_tax_deduction_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAPostTaxDeduction'
     *
     * @param  \OpenAPI\Client\Model\CreateAPostTaxDeductionRequest $create_a_post_tax_deduction_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAPostTaxDeductionRequest($create_a_post_tax_deduction_request = null, string $contentType = self::contentTypes['createAPostTaxDeduction'][0])
    {



        $resourcePath = '/post_tax_deductions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_a_post_tax_deduction_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_a_post_tax_deduction_request));
            } else {
                $httpBody = $create_a_post_tax_deduction_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createASignatory
     *
     * Create a signatory
     *
     * @param  string $company The unique identifier of the company (required)
     * @param  \OpenAPI\Client\Model\CreateASignatoryRequest $create_a_signatory_request create_a_signatory_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createASignatory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CreateASignatory200Response|object
     */
    public function createASignatory($company, $create_a_signatory_request = null, string $contentType = self::contentTypes['createASignatory'][0])
    {
        list($response) = $this->createASignatoryWithHttpInfo($company, $create_a_signatory_request, $contentType);
        return $response;
    }

    /**
     * Operation createASignatoryWithHttpInfo
     *
     * Create a signatory
     *
     * @param  string $company The unique identifier of the company (required)
     * @param  \OpenAPI\Client\Model\CreateASignatoryRequest $create_a_signatory_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createASignatory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CreateASignatory200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createASignatoryWithHttpInfo($company, $create_a_signatory_request = null, string $contentType = self::contentTypes['createASignatory'][0])
    {
        $request = $this->createASignatoryRequest($company, $create_a_signatory_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CreateASignatory200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CreateASignatory200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CreateASignatory200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CreateASignatory200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreateASignatory200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createASignatoryAsync
     *
     * Create a signatory
     *
     * @param  string $company The unique identifier of the company (required)
     * @param  \OpenAPI\Client\Model\CreateASignatoryRequest $create_a_signatory_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createASignatory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createASignatoryAsync($company, $create_a_signatory_request = null, string $contentType = self::contentTypes['createASignatory'][0])
    {
        return $this->createASignatoryAsyncWithHttpInfo($company, $create_a_signatory_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createASignatoryAsyncWithHttpInfo
     *
     * Create a signatory
     *
     * @param  string $company The unique identifier of the company (required)
     * @param  \OpenAPI\Client\Model\CreateASignatoryRequest $create_a_signatory_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createASignatory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createASignatoryAsyncWithHttpInfo($company, $create_a_signatory_request = null, string $contentType = self::contentTypes['createASignatory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CreateASignatory200Response';
        $request = $this->createASignatoryRequest($company, $create_a_signatory_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createASignatory'
     *
     * @param  string $company The unique identifier of the company (required)
     * @param  \OpenAPI\Client\Model\CreateASignatoryRequest $create_a_signatory_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createASignatory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createASignatoryRequest($company, $create_a_signatory_request = null, string $contentType = self::contentTypes['createASignatory'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling createASignatory'
            );
        }



        $resourcePath = '/companies/{company}/signatories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_a_signatory_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_a_signatory_request));
            } else {
                $httpBody = $create_a_signatory_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAWebhookConfig
     *
     * Create a webhook config
     *
     * @param  \OpenAPI\Client\Model\UpdateAWebhookConfigRequest $update_a_webhook_config_request update_a_webhook_config_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createAWebhookConfig($update_a_webhook_config_request = null, string $contentType = self::contentTypes['createAWebhookConfig'][0])
    {
        $this->createAWebhookConfigWithHttpInfo($update_a_webhook_config_request, $contentType);
    }

    /**
     * Operation createAWebhookConfigWithHttpInfo
     *
     * Create a webhook config
     *
     * @param  \OpenAPI\Client\Model\UpdateAWebhookConfigRequest $update_a_webhook_config_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAWebhookConfigWithHttpInfo($update_a_webhook_config_request = null, string $contentType = self::contentTypes['createAWebhookConfig'][0])
    {
        $request = $this->createAWebhookConfigRequest($update_a_webhook_config_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createAWebhookConfigAsync
     *
     * Create a webhook config
     *
     * @param  \OpenAPI\Client\Model\UpdateAWebhookConfigRequest $update_a_webhook_config_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAWebhookConfigAsync($update_a_webhook_config_request = null, string $contentType = self::contentTypes['createAWebhookConfig'][0])
    {
        return $this->createAWebhookConfigAsyncWithHttpInfo($update_a_webhook_config_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAWebhookConfigAsyncWithHttpInfo
     *
     * Create a webhook config
     *
     * @param  \OpenAPI\Client\Model\UpdateAWebhookConfigRequest $update_a_webhook_config_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAWebhookConfigAsyncWithHttpInfo($update_a_webhook_config_request = null, string $contentType = self::contentTypes['createAWebhookConfig'][0])
    {
        $returnType = '';
        $request = $this->createAWebhookConfigRequest($update_a_webhook_config_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAWebhookConfig'
     *
     * @param  \OpenAPI\Client\Model\UpdateAWebhookConfigRequest $update_a_webhook_config_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAWebhookConfigRequest($update_a_webhook_config_request = null, string $contentType = self::contentTypes['createAWebhookConfig'][0])
    {



        $resourcePath = '/webhook_configs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_a_webhook_config_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_a_webhook_config_request));
            } else {
                $httpBody = $update_a_webhook_config_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAWorkplace
     *
     * Create a workplace
     *
     * @param  \OpenAPI\Client\Model\CreateAWorkplaceRequest $create_a_workplace_request create_a_workplace_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAWorkplace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListWorkplaces200ResponseInner
     */
    public function createAWorkplace($create_a_workplace_request = null, string $contentType = self::contentTypes['createAWorkplace'][0])
    {
        list($response) = $this->createAWorkplaceWithHttpInfo($create_a_workplace_request, $contentType);
        return $response;
    }

    /**
     * Operation createAWorkplaceWithHttpInfo
     *
     * Create a workplace
     *
     * @param  \OpenAPI\Client\Model\CreateAWorkplaceRequest $create_a_workplace_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAWorkplace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListWorkplaces200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAWorkplaceWithHttpInfo($create_a_workplace_request = null, string $contentType = self::contentTypes['createAWorkplace'][0])
    {
        $request = $this->createAWorkplaceRequest($create_a_workplace_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ListWorkplaces200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListWorkplaces200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAWorkplaceAsync
     *
     * Create a workplace
     *
     * @param  \OpenAPI\Client\Model\CreateAWorkplaceRequest $create_a_workplace_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAWorkplace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAWorkplaceAsync($create_a_workplace_request = null, string $contentType = self::contentTypes['createAWorkplace'][0])
    {
        return $this->createAWorkplaceAsyncWithHttpInfo($create_a_workplace_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAWorkplaceAsyncWithHttpInfo
     *
     * Create a workplace
     *
     * @param  \OpenAPI\Client\Model\CreateAWorkplaceRequest $create_a_workplace_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAWorkplace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAWorkplaceAsyncWithHttpInfo($create_a_workplace_request = null, string $contentType = self::contentTypes['createAWorkplace'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner';
        $request = $this->createAWorkplaceRequest($create_a_workplace_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAWorkplace'
     *
     * @param  \OpenAPI\Client\Model\CreateAWorkplaceRequest $create_a_workplace_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAWorkplace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAWorkplaceRequest($create_a_workplace_request = null, string $contentType = self::contentTypes['createAWorkplace'][0])
    {



        $resourcePath = '/workplaces';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_a_workplace_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_a_workplace_request));
            } else {
                $httpBody = $create_a_workplace_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAnEarningCode
     *
     * Create an earning code
     *
     * @param  \OpenAPI\Client\Model\CreateAnEarningCodeRequest $create_an_earning_code_request create_an_earning_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEarningCode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function createAnEarningCode($create_an_earning_code_request = null, string $contentType = self::contentTypes['createAnEarningCode'][0])
    {
        list($response) = $this->createAnEarningCodeWithHttpInfo($create_an_earning_code_request, $contentType);
        return $response;
    }

    /**
     * Operation createAnEarningCodeWithHttpInfo
     *
     * Create an earning code
     *
     * @param  \OpenAPI\Client\Model\CreateAnEarningCodeRequest $create_an_earning_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEarningCode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAnEarningCodeWithHttpInfo($create_an_earning_code_request = null, string $contentType = self::contentTypes['createAnEarningCode'][0])
    {
        $request = $this->createAnEarningCodeRequest($create_an_earning_code_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAnEarningCodeAsync
     *
     * Create an earning code
     *
     * @param  \OpenAPI\Client\Model\CreateAnEarningCodeRequest $create_an_earning_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEarningCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnEarningCodeAsync($create_an_earning_code_request = null, string $contentType = self::contentTypes['createAnEarningCode'][0])
    {
        return $this->createAnEarningCodeAsyncWithHttpInfo($create_an_earning_code_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAnEarningCodeAsyncWithHttpInfo
     *
     * Create an earning code
     *
     * @param  \OpenAPI\Client\Model\CreateAnEarningCodeRequest $create_an_earning_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEarningCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnEarningCodeAsyncWithHttpInfo($create_an_earning_code_request = null, string $contentType = self::contentTypes['createAnEarningCode'][0])
    {
        $returnType = 'object';
        $request = $this->createAnEarningCodeRequest($create_an_earning_code_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAnEarningCode'
     *
     * @param  \OpenAPI\Client\Model\CreateAnEarningCodeRequest $create_an_earning_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEarningCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAnEarningCodeRequest($create_an_earning_code_request = null, string $contentType = self::contentTypes['createAnEarningCode'][0])
    {



        $resourcePath = '/earning_codes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_an_earning_code_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_an_earning_code_request));
            } else {
                $httpBody = $create_an_earning_code_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAnEarningRate
     *
     * Create an earning rate
     *
     * @param  \OpenAPI\Client\Model\CreateAnEarningRateRequest $create_an_earning_rate_request create_an_earning_rate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEarningRate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function createAnEarningRate($create_an_earning_rate_request = null, string $contentType = self::contentTypes['createAnEarningRate'][0])
    {
        list($response) = $this->createAnEarningRateWithHttpInfo($create_an_earning_rate_request, $contentType);
        return $response;
    }

    /**
     * Operation createAnEarningRateWithHttpInfo
     *
     * Create an earning rate
     *
     * @param  \OpenAPI\Client\Model\CreateAnEarningRateRequest $create_an_earning_rate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEarningRate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAnEarningRateWithHttpInfo($create_an_earning_rate_request = null, string $contentType = self::contentTypes['createAnEarningRate'][0])
    {
        $request = $this->createAnEarningRateRequest($create_an_earning_rate_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAnEarningRateAsync
     *
     * Create an earning rate
     *
     * @param  \OpenAPI\Client\Model\CreateAnEarningRateRequest $create_an_earning_rate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEarningRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnEarningRateAsync($create_an_earning_rate_request = null, string $contentType = self::contentTypes['createAnEarningRate'][0])
    {
        return $this->createAnEarningRateAsyncWithHttpInfo($create_an_earning_rate_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAnEarningRateAsyncWithHttpInfo
     *
     * Create an earning rate
     *
     * @param  \OpenAPI\Client\Model\CreateAnEarningRateRequest $create_an_earning_rate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEarningRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnEarningRateAsyncWithHttpInfo($create_an_earning_rate_request = null, string $contentType = self::contentTypes['createAnEarningRate'][0])
    {
        $returnType = 'object';
        $request = $this->createAnEarningRateRequest($create_an_earning_rate_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAnEarningRate'
     *
     * @param  \OpenAPI\Client\Model\CreateAnEarningRateRequest $create_an_earning_rate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEarningRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAnEarningRateRequest($create_an_earning_rate_request = null, string $contentType = self::contentTypes['createAnEarningRate'][0])
    {



        $resourcePath = '/earning_rates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_an_earning_rate_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_an_earning_rate_request));
            } else {
                $httpBody = $create_an_earning_rate_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAnEmployee
     *
     * Create an employee
     *
     * @param  \OpenAPI\Client\Model\CreateAnEmployeeRequest $create_an_employee_request create_an_employee_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEmployee'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createAnEmployee($create_an_employee_request = null, string $contentType = self::contentTypes['createAnEmployee'][0])
    {
        $this->createAnEmployeeWithHttpInfo($create_an_employee_request, $contentType);
    }

    /**
     * Operation createAnEmployeeWithHttpInfo
     *
     * Create an employee
     *
     * @param  \OpenAPI\Client\Model\CreateAnEmployeeRequest $create_an_employee_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEmployee'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAnEmployeeWithHttpInfo($create_an_employee_request = null, string $contentType = self::contentTypes['createAnEmployee'][0])
    {
        $request = $this->createAnEmployeeRequest($create_an_employee_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createAnEmployeeAsync
     *
     * Create an employee
     *
     * @param  \OpenAPI\Client\Model\CreateAnEmployeeRequest $create_an_employee_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEmployee'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnEmployeeAsync($create_an_employee_request = null, string $contentType = self::contentTypes['createAnEmployee'][0])
    {
        return $this->createAnEmployeeAsyncWithHttpInfo($create_an_employee_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAnEmployeeAsyncWithHttpInfo
     *
     * Create an employee
     *
     * @param  \OpenAPI\Client\Model\CreateAnEmployeeRequest $create_an_employee_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEmployee'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnEmployeeAsyncWithHttpInfo($create_an_employee_request = null, string $contentType = self::contentTypes['createAnEmployee'][0])
    {
        $returnType = '';
        $request = $this->createAnEmployeeRequest($create_an_employee_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAnEmployee'
     *
     * @param  \OpenAPI\Client\Model\CreateAnEmployeeRequest $create_an_employee_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEmployee'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAnEmployeeRequest($create_an_employee_request = null, string $contentType = self::contentTypes['createAnEmployee'][0])
    {



        $resourcePath = '/employees';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_an_employee_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_an_employee_request));
            } else {
                $httpBody = $create_an_employee_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAnEmployeeBenefit
     *
     * Create a benefit
     *
     * @param  \OpenAPI\Client\Model\CreateAnEmployeeBenefitRequest $create_an_employee_benefit_request create_an_employee_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createAnEmployeeBenefit($create_an_employee_benefit_request = null, string $contentType = self::contentTypes['createAnEmployeeBenefit'][0])
    {
        $this->createAnEmployeeBenefitWithHttpInfo($create_an_employee_benefit_request, $contentType);
    }

    /**
     * Operation createAnEmployeeBenefitWithHttpInfo
     *
     * Create a benefit
     *
     * @param  \OpenAPI\Client\Model\CreateAnEmployeeBenefitRequest $create_an_employee_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAnEmployeeBenefitWithHttpInfo($create_an_employee_benefit_request = null, string $contentType = self::contentTypes['createAnEmployeeBenefit'][0])
    {
        $request = $this->createAnEmployeeBenefitRequest($create_an_employee_benefit_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createAnEmployeeBenefitAsync
     *
     * Create a benefit
     *
     * @param  \OpenAPI\Client\Model\CreateAnEmployeeBenefitRequest $create_an_employee_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnEmployeeBenefitAsync($create_an_employee_benefit_request = null, string $contentType = self::contentTypes['createAnEmployeeBenefit'][0])
    {
        return $this->createAnEmployeeBenefitAsyncWithHttpInfo($create_an_employee_benefit_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAnEmployeeBenefitAsyncWithHttpInfo
     *
     * Create a benefit
     *
     * @param  \OpenAPI\Client\Model\CreateAnEmployeeBenefitRequest $create_an_employee_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnEmployeeBenefitAsyncWithHttpInfo($create_an_employee_benefit_request = null, string $contentType = self::contentTypes['createAnEmployeeBenefit'][0])
    {
        $returnType = '';
        $request = $this->createAnEmployeeBenefitRequest($create_an_employee_benefit_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAnEmployeeBenefit'
     *
     * @param  \OpenAPI\Client\Model\CreateAnEmployeeBenefitRequest $create_an_employee_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAnEmployeeBenefitRequest($create_an_employee_benefit_request = null, string $contentType = self::contentTypes['createAnEmployeeBenefit'][0])
    {



        $resourcePath = '/benefits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_an_employee_benefit_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_an_employee_benefit_request));
            } else {
                $httpBody = $create_an_employee_benefit_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAnExternalPayroll
     *
     * Create an external payroll
     *
     * @param  \OpenAPI\Client\Model\CreateAnExternalPayrollRequest $create_an_external_payroll_request create_an_external_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createAnExternalPayroll($create_an_external_payroll_request = null, string $contentType = self::contentTypes['createAnExternalPayroll'][0])
    {
        $this->createAnExternalPayrollWithHttpInfo($create_an_external_payroll_request, $contentType);
    }

    /**
     * Operation createAnExternalPayrollWithHttpInfo
     *
     * Create an external payroll
     *
     * @param  \OpenAPI\Client\Model\CreateAnExternalPayrollRequest $create_an_external_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAnExternalPayrollWithHttpInfo($create_an_external_payroll_request = null, string $contentType = self::contentTypes['createAnExternalPayroll'][0])
    {
        $request = $this->createAnExternalPayrollRequest($create_an_external_payroll_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createAnExternalPayrollAsync
     *
     * Create an external payroll
     *
     * @param  \OpenAPI\Client\Model\CreateAnExternalPayrollRequest $create_an_external_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnExternalPayrollAsync($create_an_external_payroll_request = null, string $contentType = self::contentTypes['createAnExternalPayroll'][0])
    {
        return $this->createAnExternalPayrollAsyncWithHttpInfo($create_an_external_payroll_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAnExternalPayrollAsyncWithHttpInfo
     *
     * Create an external payroll
     *
     * @param  \OpenAPI\Client\Model\CreateAnExternalPayrollRequest $create_an_external_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAnExternalPayrollAsyncWithHttpInfo($create_an_external_payroll_request = null, string $contentType = self::contentTypes['createAnExternalPayroll'][0])
    {
        $returnType = '';
        $request = $this->createAnExternalPayrollRequest($create_an_external_payroll_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAnExternalPayroll'
     *
     * @param  \OpenAPI\Client\Model\CreateAnExternalPayrollRequest $create_an_external_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAnExternalPayrollRequest($create_an_external_payroll_request = null, string $contentType = self::contentTypes['createAnExternalPayroll'][0])
    {



        $resourcePath = '/external_payrolls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_an_external_payroll_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_an_external_payroll_request));
            } else {
                $httpBody = $create_an_external_payroll_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCompany
     *
     * Create a company
     *
     * @param  \OpenAPI\Client\Model\CreateCompanyRequest $create_company_request create_company_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCompany'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createCompany($create_company_request = null, string $contentType = self::contentTypes['createCompany'][0])
    {
        $this->createCompanyWithHttpInfo($create_company_request, $contentType);
    }

    /**
     * Operation createCompanyWithHttpInfo
     *
     * Create a company
     *
     * @param  \OpenAPI\Client\Model\CreateCompanyRequest $create_company_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCompany'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCompanyWithHttpInfo($create_company_request = null, string $contentType = self::contentTypes['createCompany'][0])
    {
        $request = $this->createCompanyRequest($create_company_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createCompanyAsync
     *
     * Create a company
     *
     * @param  \OpenAPI\Client\Model\CreateCompanyRequest $create_company_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCompany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCompanyAsync($create_company_request = null, string $contentType = self::contentTypes['createCompany'][0])
    {
        return $this->createCompanyAsyncWithHttpInfo($create_company_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCompanyAsyncWithHttpInfo
     *
     * Create a company
     *
     * @param  \OpenAPI\Client\Model\CreateCompanyRequest $create_company_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCompany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCompanyAsyncWithHttpInfo($create_company_request = null, string $contentType = self::contentTypes['createCompany'][0])
    {
        $returnType = '';
        $request = $this->createCompanyRequest($create_company_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCompany'
     *
     * @param  \OpenAPI\Client\Model\CreateCompanyRequest $create_company_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCompany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCompanyRequest($create_company_request = null, string $contentType = self::contentTypes['createCompany'][0])
    {



        $resourcePath = '/companies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_company_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_company_request));
            } else {
                $httpBody = $create_company_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCompanyTaxElections
     *
     * Create company tax elections
     *
     * @param  \OpenAPI\Client\Model\CreateCompanyTaxElectionsRequest $create_company_tax_elections_request create_company_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createCompanyTaxElections($create_company_tax_elections_request = null, string $contentType = self::contentTypes['createCompanyTaxElections'][0])
    {
        $this->createCompanyTaxElectionsWithHttpInfo($create_company_tax_elections_request, $contentType);
    }

    /**
     * Operation createCompanyTaxElectionsWithHttpInfo
     *
     * Create company tax elections
     *
     * @param  \OpenAPI\Client\Model\CreateCompanyTaxElectionsRequest $create_company_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCompanyTaxElectionsWithHttpInfo($create_company_tax_elections_request = null, string $contentType = self::contentTypes['createCompanyTaxElections'][0])
    {
        $request = $this->createCompanyTaxElectionsRequest($create_company_tax_elections_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCompanyTaxElectionsAsync
     *
     * Create company tax elections
     *
     * @param  \OpenAPI\Client\Model\CreateCompanyTaxElectionsRequest $create_company_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCompanyTaxElectionsAsync($create_company_tax_elections_request = null, string $contentType = self::contentTypes['createCompanyTaxElections'][0])
    {
        return $this->createCompanyTaxElectionsAsyncWithHttpInfo($create_company_tax_elections_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCompanyTaxElectionsAsyncWithHttpInfo
     *
     * Create company tax elections
     *
     * @param  \OpenAPI\Client\Model\CreateCompanyTaxElectionsRequest $create_company_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCompanyTaxElectionsAsyncWithHttpInfo($create_company_tax_elections_request = null, string $contentType = self::contentTypes['createCompanyTaxElections'][0])
    {
        $returnType = '';
        $request = $this->createCompanyTaxElectionsRequest($create_company_tax_elections_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCompanyTaxElections'
     *
     * @param  \OpenAPI\Client\Model\CreateCompanyTaxElectionsRequest $create_company_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCompanyTaxElectionsRequest($create_company_tax_elections_request = null, string $contentType = self::contentTypes['createCompanyTaxElections'][0])
    {



        $resourcePath = '/company_tax_elections/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_company_tax_elections_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_company_tax_elections_request));
            } else {
                $httpBody = $create_company_tax_elections_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetPaySplit
     *
     * Create a net pay split
     *
     * @param  \OpenAPI\Client\Model\CreateNetPaySplitRequest $create_net_pay_split_request create_net_pay_split_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetPaySplit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListNetPaySplits200ResponseInner
     */
    public function createNetPaySplit($create_net_pay_split_request = null, string $contentType = self::contentTypes['createNetPaySplit'][0])
    {
        list($response) = $this->createNetPaySplitWithHttpInfo($create_net_pay_split_request, $contentType);
        return $response;
    }

    /**
     * Operation createNetPaySplitWithHttpInfo
     *
     * Create a net pay split
     *
     * @param  \OpenAPI\Client\Model\CreateNetPaySplitRequest $create_net_pay_split_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetPaySplit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListNetPaySplits200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetPaySplitWithHttpInfo($create_net_pay_split_request = null, string $contentType = self::contentTypes['createNetPaySplit'][0])
    {
        $request = $this->createNetPaySplitRequest($create_net_pay_split_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetPaySplitAsync
     *
     * Create a net pay split
     *
     * @param  \OpenAPI\Client\Model\CreateNetPaySplitRequest $create_net_pay_split_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetPaySplit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetPaySplitAsync($create_net_pay_split_request = null, string $contentType = self::contentTypes['createNetPaySplit'][0])
    {
        return $this->createNetPaySplitAsyncWithHttpInfo($create_net_pay_split_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetPaySplitAsyncWithHttpInfo
     *
     * Create a net pay split
     *
     * @param  \OpenAPI\Client\Model\CreateNetPaySplitRequest $create_net_pay_split_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetPaySplit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetPaySplitAsyncWithHttpInfo($create_net_pay_split_request = null, string $contentType = self::contentTypes['createNetPaySplit'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner';
        $request = $this->createNetPaySplitRequest($create_net_pay_split_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetPaySplit'
     *
     * @param  \OpenAPI\Client\Model\CreateNetPaySplitRequest $create_net_pay_split_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNetPaySplit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNetPaySplitRequest($create_net_pay_split_request = null, string $contentType = self::contentTypes['createNetPaySplit'][0])
    {



        $resourcePath = '/net_pay_splits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_net_pay_split_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_net_pay_split_request));
            } else {
                $httpBody = $create_net_pay_split_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPayroll
     *
     * Create a payroll
     *
     * @param  \OpenAPI\Client\Model\CreatePayrollRequest $create_payroll_request create_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetPayroll200Response
     */
    public function createPayroll($create_payroll_request = null, string $contentType = self::contentTypes['createPayroll'][0])
    {
        list($response) = $this->createPayrollWithHttpInfo($create_payroll_request, $contentType);
        return $response;
    }

    /**
     * Operation createPayrollWithHttpInfo
     *
     * Create a payroll
     *
     * @param  \OpenAPI\Client\Model\CreatePayrollRequest $create_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetPayroll200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPayrollWithHttpInfo($create_payroll_request = null, string $contentType = self::contentTypes['createPayroll'][0])
    {
        $request = $this->createPayrollRequest($create_payroll_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetPayroll200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetPayroll200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetPayroll200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetPayroll200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetPayroll200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPayrollAsync
     *
     * Create a payroll
     *
     * @param  \OpenAPI\Client\Model\CreatePayrollRequest $create_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPayrollAsync($create_payroll_request = null, string $contentType = self::contentTypes['createPayroll'][0])
    {
        return $this->createPayrollAsyncWithHttpInfo($create_payroll_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPayrollAsyncWithHttpInfo
     *
     * Create a payroll
     *
     * @param  \OpenAPI\Client\Model\CreatePayrollRequest $create_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPayrollAsyncWithHttpInfo($create_payroll_request = null, string $contentType = self::contentTypes['createPayroll'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetPayroll200Response';
        $request = $this->createPayrollRequest($create_payroll_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPayroll'
     *
     * @param  \OpenAPI\Client\Model\CreatePayrollRequest $create_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createPayrollRequest($create_payroll_request = null, string $contentType = self::contentTypes['createPayroll'][0])
    {



        $resourcePath = '/payrolls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_payroll_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_payroll_request));
            } else {
                $httpBody = $create_payroll_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTheEnrollmentProfile
     *
     * Create the enrollment profile
     *
     * @param  \OpenAPI\Client\Model\CreateTheEnrollmentProfileRequest $create_the_enrollment_profile_request create_the_enrollment_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createTheEnrollmentProfile($create_the_enrollment_profile_request = null, string $contentType = self::contentTypes['createTheEnrollmentProfile'][0])
    {
        $this->createTheEnrollmentProfileWithHttpInfo($create_the_enrollment_profile_request, $contentType);
    }

    /**
     * Operation createTheEnrollmentProfileWithHttpInfo
     *
     * Create the enrollment profile
     *
     * @param  \OpenAPI\Client\Model\CreateTheEnrollmentProfileRequest $create_the_enrollment_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTheEnrollmentProfileWithHttpInfo($create_the_enrollment_profile_request = null, string $contentType = self::contentTypes['createTheEnrollmentProfile'][0])
    {
        $request = $this->createTheEnrollmentProfileRequest($create_the_enrollment_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTheEnrollmentProfileAsync
     *
     * Create the enrollment profile
     *
     * @param  \OpenAPI\Client\Model\CreateTheEnrollmentProfileRequest $create_the_enrollment_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTheEnrollmentProfileAsync($create_the_enrollment_profile_request = null, string $contentType = self::contentTypes['createTheEnrollmentProfile'][0])
    {
        return $this->createTheEnrollmentProfileAsyncWithHttpInfo($create_the_enrollment_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTheEnrollmentProfileAsyncWithHttpInfo
     *
     * Create the enrollment profile
     *
     * @param  \OpenAPI\Client\Model\CreateTheEnrollmentProfileRequest $create_the_enrollment_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTheEnrollmentProfileAsyncWithHttpInfo($create_the_enrollment_profile_request = null, string $contentType = self::contentTypes['createTheEnrollmentProfile'][0])
    {
        $returnType = '';
        $request = $this->createTheEnrollmentProfileRequest($create_the_enrollment_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTheEnrollmentProfile'
     *
     * @param  \OpenAPI\Client\Model\CreateTheEnrollmentProfileRequest $create_the_enrollment_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTheEnrollmentProfileRequest($create_the_enrollment_profile_request = null, string $contentType = self::contentTypes['createTheEnrollmentProfile'][0])
    {



        $resourcePath = '/companies/{company}/enrollment_profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_the_enrollment_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_the_enrollment_profile_request));
            } else {
                $httpBody = $create_the_enrollment_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteABankAccount
     *
     * Delete a bank account
     *
     * @param  string $bank_account ID of the bank account to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteABankAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteABankAccount($bank_account, string $contentType = self::contentTypes['deleteABankAccount'][0])
    {
        $this->deleteABankAccountWithHttpInfo($bank_account, $contentType);
    }

    /**
     * Operation deleteABankAccountWithHttpInfo
     *
     * Delete a bank account
     *
     * @param  string $bank_account ID of the bank account to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteABankAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteABankAccountWithHttpInfo($bank_account, string $contentType = self::contentTypes['deleteABankAccount'][0])
    {
        $request = $this->deleteABankAccountRequest($bank_account, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteABankAccountAsync
     *
     * Delete a bank account
     *
     * @param  string $bank_account ID of the bank account to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteABankAccountAsync($bank_account, string $contentType = self::contentTypes['deleteABankAccount'][0])
    {
        return $this->deleteABankAccountAsyncWithHttpInfo($bank_account, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteABankAccountAsyncWithHttpInfo
     *
     * Delete a bank account
     *
     * @param  string $bank_account ID of the bank account to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteABankAccountAsyncWithHttpInfo($bank_account, string $contentType = self::contentTypes['deleteABankAccount'][0])
    {
        $returnType = '';
        $request = $this->deleteABankAccountRequest($bank_account, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteABankAccount'
     *
     * @param  string $bank_account ID of the bank account to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteABankAccountRequest($bank_account, string $contentType = self::contentTypes['deleteABankAccount'][0])
    {

        // verify the required parameter 'bank_account' is set
        if ($bank_account === null || (is_array($bank_account) && count($bank_account) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bank_account when calling deleteABankAccount'
            );
        }


        $resourcePath = '/bank_accounts/{bank_account}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($bank_account !== null) {
            $resourcePath = str_replace(
                '{' . 'bank_account' . '}',
                ObjectSerializer::toPathValue($bank_account),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteACompanyBenefit
     *
     * Delete a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function deleteACompanyBenefit($company_benefit, string $contentType = self::contentTypes['deleteACompanyBenefit'][0])
    {
        list($response) = $this->deleteACompanyBenefitWithHttpInfo($company_benefit, $contentType);
        return $response;
    }

    /**
     * Operation deleteACompanyBenefitWithHttpInfo
     *
     * Delete a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteACompanyBenefitWithHttpInfo($company_benefit, string $contentType = self::contentTypes['deleteACompanyBenefit'][0])
    {
        $request = $this->deleteACompanyBenefitRequest($company_benefit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 204:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteACompanyBenefitAsync
     *
     * Delete a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteACompanyBenefitAsync($company_benefit, string $contentType = self::contentTypes['deleteACompanyBenefit'][0])
    {
        return $this->deleteACompanyBenefitAsyncWithHttpInfo($company_benefit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteACompanyBenefitAsyncWithHttpInfo
     *
     * Delete a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteACompanyBenefitAsyncWithHttpInfo($company_benefit, string $contentType = self::contentTypes['deleteACompanyBenefit'][0])
    {
        $returnType = 'object';
        $request = $this->deleteACompanyBenefitRequest($company_benefit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteACompanyBenefit'
     *
     * @param  string $company_benefit ID of the company benefit to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteACompanyBenefitRequest($company_benefit, string $contentType = self::contentTypes['deleteACompanyBenefit'][0])
    {

        // verify the required parameter 'company_benefit' is set
        if ($company_benefit === null || (is_array($company_benefit) && count($company_benefit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company_benefit when calling deleteACompanyBenefit'
            );
        }


        $resourcePath = '/company_benefits/{company_benefit}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company_benefit !== null) {
            $resourcePath = str_replace(
                '{' . 'company_benefit' . '}',
                ObjectSerializer::toPathValue($company_benefit),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAContractorPayment
     *
     * Delete a contractor payment
     *
     * @param  string $contractor_payment contractor_payment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAContractorPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function deleteAContractorPayment($contractor_payment, string $contentType = self::contentTypes['deleteAContractorPayment'][0])
    {
        list($response) = $this->deleteAContractorPaymentWithHttpInfo($contractor_payment, $contentType);
        return $response;
    }

    /**
     * Operation deleteAContractorPaymentWithHttpInfo
     *
     * Delete a contractor payment
     *
     * @param  string $contractor_payment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAContractorPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAContractorPaymentWithHttpInfo($contractor_payment, string $contentType = self::contentTypes['deleteAContractorPayment'][0])
    {
        $request = $this->deleteAContractorPaymentRequest($contractor_payment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 204:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAContractorPaymentAsync
     *
     * Delete a contractor payment
     *
     * @param  string $contractor_payment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAContractorPaymentAsync($contractor_payment, string $contentType = self::contentTypes['deleteAContractorPayment'][0])
    {
        return $this->deleteAContractorPaymentAsyncWithHttpInfo($contractor_payment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAContractorPaymentAsyncWithHttpInfo
     *
     * Delete a contractor payment
     *
     * @param  string $contractor_payment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAContractorPaymentAsyncWithHttpInfo($contractor_payment, string $contentType = self::contentTypes['deleteAContractorPayment'][0])
    {
        $returnType = 'object';
        $request = $this->deleteAContractorPaymentRequest($contractor_payment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAContractorPayment'
     *
     * @param  string $contractor_payment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAContractorPaymentRequest($contractor_payment, string $contentType = self::contentTypes['deleteAContractorPayment'][0])
    {

        // verify the required parameter 'contractor_payment' is set
        if ($contractor_payment === null || (is_array($contractor_payment) && count($contractor_payment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractor_payment when calling deleteAContractorPayment'
            );
        }


        $resourcePath = '/contractor_payments/{contractor_payment}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contractor_payment !== null) {
            $resourcePath = str_replace(
                '{' . 'contractor_payment' . '}',
                ObjectSerializer::toPathValue($contractor_payment),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAPayroll
     *
     * Delete a payroll
     *
     * @param  string $payroll payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAPayroll($payroll, string $contentType = self::contentTypes['deleteAPayroll'][0])
    {
        $this->deleteAPayrollWithHttpInfo($payroll, $contentType);
    }

    /**
     * Operation deleteAPayrollWithHttpInfo
     *
     * Delete a payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAPayrollWithHttpInfo($payroll, string $contentType = self::contentTypes['deleteAPayroll'][0])
    {
        $request = $this->deleteAPayrollRequest($payroll, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAPayrollAsync
     *
     * Delete a payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAPayrollAsync($payroll, string $contentType = self::contentTypes['deleteAPayroll'][0])
    {
        return $this->deleteAPayrollAsyncWithHttpInfo($payroll, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAPayrollAsyncWithHttpInfo
     *
     * Delete a payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAPayrollAsyncWithHttpInfo($payroll, string $contentType = self::contentTypes['deleteAPayroll'][0])
    {
        $returnType = '';
        $request = $this->deleteAPayrollRequest($payroll, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAPayroll'
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAPayrollRequest($payroll, string $contentType = self::contentTypes['deleteAPayroll'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling deleteAPayroll'
            );
        }


        $resourcePath = '/payrolls/{payroll}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAPayrollCopy1
     *
     * Delete an external payroll
     *
     * @param  string $payroll payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayrollCopy1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAPayrollCopy1($payroll, string $contentType = self::contentTypes['deleteAPayrollCopy1'][0])
    {
        $this->deleteAPayrollCopy1WithHttpInfo($payroll, $contentType);
    }

    /**
     * Operation deleteAPayrollCopy1WithHttpInfo
     *
     * Delete an external payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayrollCopy1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAPayrollCopy1WithHttpInfo($payroll, string $contentType = self::contentTypes['deleteAPayrollCopy1'][0])
    {
        $request = $this->deleteAPayrollCopy1Request($payroll, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAPayrollCopy1Async
     *
     * Delete an external payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayrollCopy1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAPayrollCopy1Async($payroll, string $contentType = self::contentTypes['deleteAPayrollCopy1'][0])
    {
        return $this->deleteAPayrollCopy1AsyncWithHttpInfo($payroll, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAPayrollCopy1AsyncWithHttpInfo
     *
     * Delete an external payroll
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayrollCopy1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAPayrollCopy1AsyncWithHttpInfo($payroll, string $contentType = self::contentTypes['deleteAPayrollCopy1'][0])
    {
        $returnType = '';
        $request = $this->deleteAPayrollCopy1Request($payroll, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAPayrollCopy1'
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayrollCopy1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAPayrollCopy1Request($payroll, string $contentType = self::contentTypes['deleteAPayrollCopy1'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling deleteAPayrollCopy1'
            );
        }


        $resourcePath = '/external_payrolls/{payroll}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAPayrollItem
     *
     * Delete a payroll item
     *
     * @param  string $payroll_item payroll_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayrollItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAPayrollItem($payroll_item, string $contentType = self::contentTypes['deleteAPayrollItem'][0])
    {
        $this->deleteAPayrollItemWithHttpInfo($payroll_item, $contentType);
    }

    /**
     * Operation deleteAPayrollItemWithHttpInfo
     *
     * Delete a payroll item
     *
     * @param  string $payroll_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayrollItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAPayrollItemWithHttpInfo($payroll_item, string $contentType = self::contentTypes['deleteAPayrollItem'][0])
    {
        $request = $this->deleteAPayrollItemRequest($payroll_item, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAPayrollItemAsync
     *
     * Delete a payroll item
     *
     * @param  string $payroll_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAPayrollItemAsync($payroll_item, string $contentType = self::contentTypes['deleteAPayrollItem'][0])
    {
        return $this->deleteAPayrollItemAsyncWithHttpInfo($payroll_item, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAPayrollItemAsyncWithHttpInfo
     *
     * Delete a payroll item
     *
     * @param  string $payroll_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAPayrollItemAsyncWithHttpInfo($payroll_item, string $contentType = self::contentTypes['deleteAPayrollItem'][0])
    {
        $returnType = '';
        $request = $this->deleteAPayrollItemRequest($payroll_item, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAPayrollItem'
     *
     * @param  string $payroll_item (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAPayrollItemRequest($payroll_item, string $contentType = self::contentTypes['deleteAPayrollItem'][0])
    {

        // verify the required parameter 'payroll_item' is set
        if ($payroll_item === null || (is_array($payroll_item) && count($payroll_item) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll_item when calling deleteAPayrollItem'
            );
        }


        $resourcePath = '/payroll_items/{payroll_item}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll_item !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll_item' . '}',
                ObjectSerializer::toPathValue($payroll_item),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAPostTaxDeduction
     *
     * Delete a post-tax deduction
     *
     * @param  string $post_tax_deduction post_tax_deduction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function deleteAPostTaxDeduction($post_tax_deduction, string $contentType = self::contentTypes['deleteAPostTaxDeduction'][0])
    {
        list($response) = $this->deleteAPostTaxDeductionWithHttpInfo($post_tax_deduction, $contentType);
        return $response;
    }

    /**
     * Operation deleteAPostTaxDeductionWithHttpInfo
     *
     * Delete a post-tax deduction
     *
     * @param  string $post_tax_deduction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAPostTaxDeductionWithHttpInfo($post_tax_deduction, string $contentType = self::contentTypes['deleteAPostTaxDeduction'][0])
    {
        $request = $this->deleteAPostTaxDeductionRequest($post_tax_deduction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 204:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAPostTaxDeductionAsync
     *
     * Delete a post-tax deduction
     *
     * @param  string $post_tax_deduction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAPostTaxDeductionAsync($post_tax_deduction, string $contentType = self::contentTypes['deleteAPostTaxDeduction'][0])
    {
        return $this->deleteAPostTaxDeductionAsyncWithHttpInfo($post_tax_deduction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAPostTaxDeductionAsyncWithHttpInfo
     *
     * Delete a post-tax deduction
     *
     * @param  string $post_tax_deduction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAPostTaxDeductionAsyncWithHttpInfo($post_tax_deduction, string $contentType = self::contentTypes['deleteAPostTaxDeduction'][0])
    {
        $returnType = 'object';
        $request = $this->deleteAPostTaxDeductionRequest($post_tax_deduction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAPostTaxDeduction'
     *
     * @param  string $post_tax_deduction (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAPostTaxDeductionRequest($post_tax_deduction, string $contentType = self::contentTypes['deleteAPostTaxDeduction'][0])
    {

        // verify the required parameter 'post_tax_deduction' is set
        if ($post_tax_deduction === null || (is_array($post_tax_deduction) && count($post_tax_deduction) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_tax_deduction when calling deleteAPostTaxDeduction'
            );
        }


        $resourcePath = '/post_tax_deductions/{post_tax_deduction}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($post_tax_deduction !== null) {
            $resourcePath = str_replace(
                '{' . 'post_tax_deduction' . '}',
                ObjectSerializer::toPathValue($post_tax_deduction),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAWebhookConfig
     *
     * Delete a webhook config
     *
     * @param  string $webhook_config webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAWebhookConfig($webhook_config, string $contentType = self::contentTypes['deleteAWebhookConfig'][0])
    {
        $this->deleteAWebhookConfigWithHttpInfo($webhook_config, $contentType);
    }

    /**
     * Operation deleteAWebhookConfigWithHttpInfo
     *
     * Delete a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAWebhookConfigWithHttpInfo($webhook_config, string $contentType = self::contentTypes['deleteAWebhookConfig'][0])
    {
        $request = $this->deleteAWebhookConfigRequest($webhook_config, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAWebhookConfigAsync
     *
     * Delete a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAWebhookConfigAsync($webhook_config, string $contentType = self::contentTypes['deleteAWebhookConfig'][0])
    {
        return $this->deleteAWebhookConfigAsyncWithHttpInfo($webhook_config, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAWebhookConfigAsyncWithHttpInfo
     *
     * Delete a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAWebhookConfigAsyncWithHttpInfo($webhook_config, string $contentType = self::contentTypes['deleteAWebhookConfig'][0])
    {
        $returnType = '';
        $request = $this->deleteAWebhookConfigRequest($webhook_config, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAWebhookConfig'
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAWebhookConfigRequest($webhook_config, string $contentType = self::contentTypes['deleteAWebhookConfig'][0])
    {

        // verify the required parameter 'webhook_config' is set
        if ($webhook_config === null || (is_array($webhook_config) && count($webhook_config) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_config when calling deleteAWebhookConfig'
            );
        }


        $resourcePath = '/webhook_configs/{webhook_config}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_config !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_config' . '}',
                ObjectSerializer::toPathValue($webhook_config),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAnEmployeeBenefit
     *
     * Delete a benefit
     *
     * @param  string $benefit ID of the benefit to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function deleteAnEmployeeBenefit($benefit, string $contentType = self::contentTypes['deleteAnEmployeeBenefit'][0])
    {
        list($response) = $this->deleteAnEmployeeBenefitWithHttpInfo($benefit, $contentType);
        return $response;
    }

    /**
     * Operation deleteAnEmployeeBenefitWithHttpInfo
     *
     * Delete a benefit
     *
     * @param  string $benefit ID of the benefit to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAnEmployeeBenefitWithHttpInfo($benefit, string $contentType = self::contentTypes['deleteAnEmployeeBenefit'][0])
    {
        $request = $this->deleteAnEmployeeBenefitRequest($benefit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 204:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAnEmployeeBenefitAsync
     *
     * Delete a benefit
     *
     * @param  string $benefit ID of the benefit to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnEmployeeBenefitAsync($benefit, string $contentType = self::contentTypes['deleteAnEmployeeBenefit'][0])
    {
        return $this->deleteAnEmployeeBenefitAsyncWithHttpInfo($benefit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAnEmployeeBenefitAsyncWithHttpInfo
     *
     * Delete a benefit
     *
     * @param  string $benefit ID of the benefit to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAnEmployeeBenefitAsyncWithHttpInfo($benefit, string $contentType = self::contentTypes['deleteAnEmployeeBenefit'][0])
    {
        $returnType = 'object';
        $request = $this->deleteAnEmployeeBenefitRequest($benefit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAnEmployeeBenefit'
     *
     * @param  string $benefit ID of the benefit to delete (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAnEmployeeBenefitRequest($benefit, string $contentType = self::contentTypes['deleteAnEmployeeBenefit'][0])
    {

        // verify the required parameter 'benefit' is set
        if ($benefit === null || (is_array($benefit) && count($benefit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $benefit when calling deleteAnEmployeeBenefit'
            );
        }


        $resourcePath = '/benefits/{benefit}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($benefit !== null) {
            $resourcePath = str_replace(
                '{' . 'benefit' . '}',
                ObjectSerializer::toPathValue($benefit),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadACompanyAuthorizationDocument
     *
     * Download a company authorization document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadACompanyAuthorizationDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function downloadACompanyAuthorizationDocument($document, $accept = null, string $contentType = self::contentTypes['downloadACompanyAuthorizationDocument'][0])
    {
        list($response) = $this->downloadACompanyAuthorizationDocumentWithHttpInfo($document, $accept, $contentType);
        return $response;
    }

    /**
     * Operation downloadACompanyAuthorizationDocumentWithHttpInfo
     *
     * Download a company authorization document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadACompanyAuthorizationDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadACompanyAuthorizationDocumentWithHttpInfo($document, $accept = null, string $contentType = self::contentTypes['downloadACompanyAuthorizationDocument'][0])
    {
        $request = $this->downloadACompanyAuthorizationDocumentRequest($document, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadACompanyAuthorizationDocumentAsync
     *
     * Download a company authorization document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadACompanyAuthorizationDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadACompanyAuthorizationDocumentAsync($document, $accept = null, string $contentType = self::contentTypes['downloadACompanyAuthorizationDocument'][0])
    {
        return $this->downloadACompanyAuthorizationDocumentAsyncWithHttpInfo($document, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadACompanyAuthorizationDocumentAsyncWithHttpInfo
     *
     * Download a company authorization document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadACompanyAuthorizationDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadACompanyAuthorizationDocumentAsyncWithHttpInfo($document, $accept = null, string $contentType = self::contentTypes['downloadACompanyAuthorizationDocument'][0])
    {
        $returnType = 'object';
        $request = $this->downloadACompanyAuthorizationDocumentRequest($document, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadACompanyAuthorizationDocument'
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadACompanyAuthorizationDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadACompanyAuthorizationDocumentRequest($document, $accept = null, string $contentType = self::contentTypes['downloadACompanyAuthorizationDocument'][0])
    {

        // verify the required parameter 'document' is set
        if ($document === null || (is_array($document) && count($document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document when calling downloadACompanyAuthorizationDocument'
            );
        }



        $resourcePath = '/documents/company_authorization_documents/{document}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($document !== null) {
            $resourcePath = str_replace(
                '{' . 'document' . '}',
                ObjectSerializer::toPathValue($document),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadACompanyTaxDocument
     *
     * Download a company tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadACompanyTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function downloadACompanyTaxDocument($document, $accept = null, string $contentType = self::contentTypes['downloadACompanyTaxDocument'][0])
    {
        list($response) = $this->downloadACompanyTaxDocumentWithHttpInfo($document, $accept, $contentType);
        return $response;
    }

    /**
     * Operation downloadACompanyTaxDocumentWithHttpInfo
     *
     * Download a company tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadACompanyTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadACompanyTaxDocumentWithHttpInfo($document, $accept = null, string $contentType = self::contentTypes['downloadACompanyTaxDocument'][0])
    {
        $request = $this->downloadACompanyTaxDocumentRequest($document, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadACompanyTaxDocumentAsync
     *
     * Download a company tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadACompanyTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadACompanyTaxDocumentAsync($document, $accept = null, string $contentType = self::contentTypes['downloadACompanyTaxDocument'][0])
    {
        return $this->downloadACompanyTaxDocumentAsyncWithHttpInfo($document, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadACompanyTaxDocumentAsyncWithHttpInfo
     *
     * Download a company tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadACompanyTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadACompanyTaxDocumentAsyncWithHttpInfo($document, $accept = null, string $contentType = self::contentTypes['downloadACompanyTaxDocument'][0])
    {
        $returnType = 'object';
        $request = $this->downloadACompanyTaxDocumentRequest($document, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadACompanyTaxDocument'
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadACompanyTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadACompanyTaxDocumentRequest($document, $accept = null, string $contentType = self::contentTypes['downloadACompanyTaxDocument'][0])
    {

        // verify the required parameter 'document' is set
        if ($document === null || (is_array($document) && count($document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document when calling downloadACompanyTaxDocument'
            );
        }



        $resourcePath = '/documents/company_tax_documents/{document}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($document !== null) {
            $resourcePath = str_replace(
                '{' . 'document' . '}',
                ObjectSerializer::toPathValue($document),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadAContractorTaxDocument
     *
     * Download a contractor tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAContractorTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function downloadAContractorTaxDocument($document, $accept = null, string $contentType = self::contentTypes['downloadAContractorTaxDocument'][0])
    {
        list($response) = $this->downloadAContractorTaxDocumentWithHttpInfo($document, $accept, $contentType);
        return $response;
    }

    /**
     * Operation downloadAContractorTaxDocumentWithHttpInfo
     *
     * Download a contractor tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAContractorTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadAContractorTaxDocumentWithHttpInfo($document, $accept = null, string $contentType = self::contentTypes['downloadAContractorTaxDocument'][0])
    {
        $request = $this->downloadAContractorTaxDocumentRequest($document, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadAContractorTaxDocumentAsync
     *
     * Download a contractor tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAContractorTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadAContractorTaxDocumentAsync($document, $accept = null, string $contentType = self::contentTypes['downloadAContractorTaxDocument'][0])
    {
        return $this->downloadAContractorTaxDocumentAsyncWithHttpInfo($document, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadAContractorTaxDocumentAsyncWithHttpInfo
     *
     * Download a contractor tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAContractorTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadAContractorTaxDocumentAsyncWithHttpInfo($document, $accept = null, string $contentType = self::contentTypes['downloadAContractorTaxDocument'][0])
    {
        $returnType = 'object';
        $request = $this->downloadAContractorTaxDocumentRequest($document, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadAContractorTaxDocument'
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAContractorTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadAContractorTaxDocumentRequest($document, $accept = null, string $contentType = self::contentTypes['downloadAContractorTaxDocument'][0])
    {

        // verify the required parameter 'document' is set
        if ($document === null || (is_array($document) && count($document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document when calling downloadAContractorTaxDocument'
            );
        }



        $resourcePath = '/documents/contractor_tax_documents/{document}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($document !== null) {
            $resourcePath = str_replace(
                '{' . 'document' . '}',
                ObjectSerializer::toPathValue($document),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadASetupDocument
     *
     * Download a setup document
     *
     * @param  string $document Document ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadASetupDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function downloadASetupDocument($document, string $contentType = self::contentTypes['downloadASetupDocument'][0])
    {
        list($response) = $this->downloadASetupDocumentWithHttpInfo($document, $contentType);
        return $response;
    }

    /**
     * Operation downloadASetupDocumentWithHttpInfo
     *
     * Download a setup document
     *
     * @param  string $document Document ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadASetupDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadASetupDocumentWithHttpInfo($document, string $contentType = self::contentTypes['downloadASetupDocument'][0])
    {
        $request = $this->downloadASetupDocumentRequest($document, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadASetupDocumentAsync
     *
     * Download a setup document
     *
     * @param  string $document Document ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadASetupDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadASetupDocumentAsync($document, string $contentType = self::contentTypes['downloadASetupDocument'][0])
    {
        return $this->downloadASetupDocumentAsyncWithHttpInfo($document, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadASetupDocumentAsyncWithHttpInfo
     *
     * Download a setup document
     *
     * @param  string $document Document ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadASetupDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadASetupDocumentAsyncWithHttpInfo($document, string $contentType = self::contentTypes['downloadASetupDocument'][0])
    {
        $returnType = 'object';
        $request = $this->downloadASetupDocumentRequest($document, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadASetupDocument'
     *
     * @param  string $document Document ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadASetupDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadASetupDocumentRequest($document, string $contentType = self::contentTypes['downloadASetupDocument'][0])
    {

        // verify the required parameter 'document' is set
        if ($document === null || (is_array($document) && count($document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document when calling downloadASetupDocument'
            );
        }


        $resourcePath = '/documents/setup_documents/{document}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($document !== null) {
            $resourcePath = str_replace(
                '{' . 'document' . '}',
                ObjectSerializer::toPathValue($document),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadAnEmployeeTaxDocument
     *
     * Download an employee tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAnEmployeeTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function downloadAnEmployeeTaxDocument($document, $accept = null, string $contentType = self::contentTypes['downloadAnEmployeeTaxDocument'][0])
    {
        list($response) = $this->downloadAnEmployeeTaxDocumentWithHttpInfo($document, $accept, $contentType);
        return $response;
    }

    /**
     * Operation downloadAnEmployeeTaxDocumentWithHttpInfo
     *
     * Download an employee tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAnEmployeeTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadAnEmployeeTaxDocumentWithHttpInfo($document, $accept = null, string $contentType = self::contentTypes['downloadAnEmployeeTaxDocument'][0])
    {
        $request = $this->downloadAnEmployeeTaxDocumentRequest($document, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadAnEmployeeTaxDocumentAsync
     *
     * Download an employee tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAnEmployeeTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadAnEmployeeTaxDocumentAsync($document, $accept = null, string $contentType = self::contentTypes['downloadAnEmployeeTaxDocument'][0])
    {
        return $this->downloadAnEmployeeTaxDocumentAsyncWithHttpInfo($document, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadAnEmployeeTaxDocumentAsyncWithHttpInfo
     *
     * Download an employee tax document
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAnEmployeeTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadAnEmployeeTaxDocumentAsyncWithHttpInfo($document, $accept = null, string $contentType = self::contentTypes['downloadAnEmployeeTaxDocument'][0])
    {
        $returnType = 'object';
        $request = $this->downloadAnEmployeeTaxDocumentRequest($document, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadAnEmployeeTaxDocument'
     *
     * @param  string $document ID of the document to download (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadAnEmployeeTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadAnEmployeeTaxDocumentRequest($document, $accept = null, string $contentType = self::contentTypes['downloadAnEmployeeTaxDocument'][0])
    {

        // verify the required parameter 'document' is set
        if ($document === null || (is_array($document) && count($document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document when calling downloadAnEmployeeTaxDocument'
            );
        }



        $resourcePath = '/documents/employee_tax_documents/{document}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($document !== null) {
            $resourcePath = str_replace(
                '{' . 'document' . '}',
                ObjectSerializer::toPathValue($document),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation earlyEnrollment
     *
     * Company Early Enrollment
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['earlyEnrollment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function earlyEnrollment($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['earlyEnrollment'][0])
    {
        list($response) = $this->earlyEnrollmentWithHttpInfo($company, $generate_onboard_link_request, $contentType);
        return $response;
    }

    /**
     * Operation earlyEnrollmentWithHttpInfo
     *
     * Company Early Enrollment
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['earlyEnrollment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function earlyEnrollmentWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['earlyEnrollment'][0])
    {
        $request = $this->earlyEnrollmentRequest($company, $generate_onboard_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation earlyEnrollmentAsync
     *
     * Company Early Enrollment
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['earlyEnrollment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function earlyEnrollmentAsync($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['earlyEnrollment'][0])
    {
        return $this->earlyEnrollmentAsyncWithHttpInfo($company, $generate_onboard_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation earlyEnrollmentAsyncWithHttpInfo
     *
     * Company Early Enrollment
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['earlyEnrollment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function earlyEnrollmentAsyncWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['earlyEnrollment'][0])
    {
        $returnType = 'object';
        $request = $this->earlyEnrollmentRequest($company, $generate_onboard_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'earlyEnrollment'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['earlyEnrollment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function earlyEnrollmentRequest($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['earlyEnrollment'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling earlyEnrollment'
            );
        }



        $resourcePath = '/companies/{company}/components/early_enrollment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($generate_onboard_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($generate_onboard_link_request));
            } else {
                $httpBody = $generate_onboard_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation employeeBenefits
     *
     * Employee Benefits
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeBenefits'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function employeeBenefits($employee, string $contentType = self::contentTypes['employeeBenefits'][0])
    {
        list($response) = $this->employeeBenefitsWithHttpInfo($employee, $contentType);
        return $response;
    }

    /**
     * Operation employeeBenefitsWithHttpInfo
     *
     * Employee Benefits
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeBenefits'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function employeeBenefitsWithHttpInfo($employee, string $contentType = self::contentTypes['employeeBenefits'][0])
    {
        $request = $this->employeeBenefitsRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation employeeBenefitsAsync
     *
     * Employee Benefits
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeBenefits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeeBenefitsAsync($employee, string $contentType = self::contentTypes['employeeBenefits'][0])
    {
        return $this->employeeBenefitsAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation employeeBenefitsAsyncWithHttpInfo
     *
     * Employee Benefits
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeBenefits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeeBenefitsAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['employeeBenefits'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->employeeBenefitsRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'employeeBenefits'
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeBenefits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function employeeBenefitsRequest($employee, string $contentType = self::contentTypes['employeeBenefits'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling employeeBenefits'
            );
        }


        $resourcePath = '/employees/{employee}/components/benefits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation employeePaymentSetup
     *
     * Employee Payment Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePaymentSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function employeePaymentSetup($employee, string $contentType = self::contentTypes['employeePaymentSetup'][0])
    {
        list($response) = $this->employeePaymentSetupWithHttpInfo($employee, $contentType);
        return $response;
    }

    /**
     * Operation employeePaymentSetupWithHttpInfo
     *
     * Employee Payment Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePaymentSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function employeePaymentSetupWithHttpInfo($employee, string $contentType = self::contentTypes['employeePaymentSetup'][0])
    {
        $request = $this->employeePaymentSetupRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation employeePaymentSetupAsync
     *
     * Employee Payment Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePaymentSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeePaymentSetupAsync($employee, string $contentType = self::contentTypes['employeePaymentSetup'][0])
    {
        return $this->employeePaymentSetupAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation employeePaymentSetupAsyncWithHttpInfo
     *
     * Employee Payment Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePaymentSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeePaymentSetupAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['employeePaymentSetup'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->employeePaymentSetupRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'employeePaymentSetup'
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePaymentSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function employeePaymentSetupRequest($employee, string $contentType = self::contentTypes['employeePaymentSetup'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling employeePaymentSetup'
            );
        }


        $resourcePath = '/employees/{employee}/components/payment_setup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation employeePaystub
     *
     * Employee Paystubs
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePaystub'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function employeePaystub($employee, string $contentType = self::contentTypes['employeePaystub'][0])
    {
        list($response) = $this->employeePaystubWithHttpInfo($employee, $contentType);
        return $response;
    }

    /**
     * Operation employeePaystubWithHttpInfo
     *
     * Employee Paystubs
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePaystub'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function employeePaystubWithHttpInfo($employee, string $contentType = self::contentTypes['employeePaystub'][0])
    {
        $request = $this->employeePaystubRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation employeePaystubAsync
     *
     * Employee Paystubs
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePaystub'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeePaystubAsync($employee, string $contentType = self::contentTypes['employeePaystub'][0])
    {
        return $this->employeePaystubAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation employeePaystubAsyncWithHttpInfo
     *
     * Employee Paystubs
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePaystub'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeePaystubAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['employeePaystub'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->employeePaystubRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'employeePaystub'
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePaystub'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function employeePaystubRequest($employee, string $contentType = self::contentTypes['employeePaystub'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling employeePaystub'
            );
        }


        $resourcePath = '/employees/{employee}/components/paystubs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation employeePostTaxDeductions
     *
     * Employee Post-Tax Deductions
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePostTaxDeductions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function employeePostTaxDeductions($employee, string $contentType = self::contentTypes['employeePostTaxDeductions'][0])
    {
        list($response) = $this->employeePostTaxDeductionsWithHttpInfo($employee, $contentType);
        return $response;
    }

    /**
     * Operation employeePostTaxDeductionsWithHttpInfo
     *
     * Employee Post-Tax Deductions
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePostTaxDeductions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function employeePostTaxDeductionsWithHttpInfo($employee, string $contentType = self::contentTypes['employeePostTaxDeductions'][0])
    {
        $request = $this->employeePostTaxDeductionsRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation employeePostTaxDeductionsAsync
     *
     * Employee Post-Tax Deductions
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePostTaxDeductions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeePostTaxDeductionsAsync($employee, string $contentType = self::contentTypes['employeePostTaxDeductions'][0])
    {
        return $this->employeePostTaxDeductionsAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation employeePostTaxDeductionsAsyncWithHttpInfo
     *
     * Employee Post-Tax Deductions
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePostTaxDeductions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeePostTaxDeductionsAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['employeePostTaxDeductions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->employeePostTaxDeductionsRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'employeePostTaxDeductions'
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeePostTaxDeductions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function employeePostTaxDeductionsRequest($employee, string $contentType = self::contentTypes['employeePostTaxDeductions'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling employeePostTaxDeductions'
            );
        }


        $resourcePath = '/employees/{employee}/components/post_tax_deductions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation employeeProfile
     *
     * Employee Profile
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function employeeProfile($employee, string $contentType = self::contentTypes['employeeProfile'][0])
    {
        list($response) = $this->employeeProfileWithHttpInfo($employee, $contentType);
        return $response;
    }

    /**
     * Operation employeeProfileWithHttpInfo
     *
     * Employee Profile
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function employeeProfileWithHttpInfo($employee, string $contentType = self::contentTypes['employeeProfile'][0])
    {
        $request = $this->employeeProfileRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation employeeProfileAsync
     *
     * Employee Profile
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeeProfileAsync($employee, string $contentType = self::contentTypes['employeeProfile'][0])
    {
        return $this->employeeProfileAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation employeeProfileAsyncWithHttpInfo
     *
     * Employee Profile
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeeProfileAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['employeeProfile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->employeeProfileRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'employeeProfile'
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function employeeProfileRequest($employee, string $contentType = self::contentTypes['employeeProfile'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling employeeProfile'
            );
        }


        $resourcePath = '/employees/{employee}/components/profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation employeeSsnSetup
     *
     * Employee SSN Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeSsnSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function employeeSsnSetup($employee, string $contentType = self::contentTypes['employeeSsnSetup'][0])
    {
        list($response) = $this->employeeSsnSetupWithHttpInfo($employee, $contentType);
        return $response;
    }

    /**
     * Operation employeeSsnSetupWithHttpInfo
     *
     * Employee SSN Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeSsnSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function employeeSsnSetupWithHttpInfo($employee, string $contentType = self::contentTypes['employeeSsnSetup'][0])
    {
        $request = $this->employeeSsnSetupRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation employeeSsnSetupAsync
     *
     * Employee SSN Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeSsnSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeeSsnSetupAsync($employee, string $contentType = self::contentTypes['employeeSsnSetup'][0])
    {
        return $this->employeeSsnSetupAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation employeeSsnSetupAsyncWithHttpInfo
     *
     * Employee SSN Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeSsnSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeeSsnSetupAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['employeeSsnSetup'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->employeeSsnSetupRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'employeeSsnSetup'
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeSsnSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function employeeSsnSetupRequest($employee, string $contentType = self::contentTypes['employeeSsnSetup'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling employeeSsnSetup'
            );
        }


        $resourcePath = '/employees/{employee}/components/ssn_setup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation employeeTaxDocuments
     *
     * Employee Tax Documents
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function employeeTaxDocuments($employee, string $contentType = self::contentTypes['employeeTaxDocuments'][0])
    {
        list($response) = $this->employeeTaxDocumentsWithHttpInfo($employee, $contentType);
        return $response;
    }

    /**
     * Operation employeeTaxDocumentsWithHttpInfo
     *
     * Employee Tax Documents
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function employeeTaxDocumentsWithHttpInfo($employee, string $contentType = self::contentTypes['employeeTaxDocuments'][0])
    {
        $request = $this->employeeTaxDocumentsRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation employeeTaxDocumentsAsync
     *
     * Employee Tax Documents
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeeTaxDocumentsAsync($employee, string $contentType = self::contentTypes['employeeTaxDocuments'][0])
    {
        return $this->employeeTaxDocumentsAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation employeeTaxDocumentsAsyncWithHttpInfo
     *
     * Employee Tax Documents
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeeTaxDocumentsAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['employeeTaxDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->employeeTaxDocumentsRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'employeeTaxDocuments'
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function employeeTaxDocumentsRequest($employee, string $contentType = self::contentTypes['employeeTaxDocuments'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling employeeTaxDocuments'
            );
        }


        $resourcePath = '/employees/{employee}/components/tax_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation employeeWithholdingsSetup
     *
     * Employee Withholdings Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeWithholdingsSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function employeeWithholdingsSetup($employee, string $contentType = self::contentTypes['employeeWithholdingsSetup'][0])
    {
        list($response) = $this->employeeWithholdingsSetupWithHttpInfo($employee, $contentType);
        return $response;
    }

    /**
     * Operation employeeWithholdingsSetupWithHttpInfo
     *
     * Employee Withholdings Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeWithholdingsSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function employeeWithholdingsSetupWithHttpInfo($employee, string $contentType = self::contentTypes['employeeWithholdingsSetup'][0])
    {
        $request = $this->employeeWithholdingsSetupRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation employeeWithholdingsSetupAsync
     *
     * Employee Withholdings Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeWithholdingsSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeeWithholdingsSetupAsync($employee, string $contentType = self::contentTypes['employeeWithholdingsSetup'][0])
    {
        return $this->employeeWithholdingsSetupAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation employeeWithholdingsSetupAsyncWithHttpInfo
     *
     * Employee Withholdings Setup
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeWithholdingsSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function employeeWithholdingsSetupAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['employeeWithholdingsSetup'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->employeeWithholdingsSetupRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'employeeWithholdingsSetup'
     *
     * @param  string $employee ID of the employee for which a component link will be generated (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeWithholdingsSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function employeeWithholdingsSetupRequest($employee, string $contentType = self::contentTypes['employeeWithholdingsSetup'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling employeeWithholdingsSetup'
            );
        }


        $resourcePath = '/employees/{employee}/components/withholdings_setup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fullServiceSetupSubmission
     *
     * Company Full Service Setup Submission Component
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullServiceSetupSubmission'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function fullServiceSetupSubmission($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['fullServiceSetupSubmission'][0])
    {
        list($response) = $this->fullServiceSetupSubmissionWithHttpInfo($company, $company_signatory_agreements_request, $contentType);
        return $response;
    }

    /**
     * Operation fullServiceSetupSubmissionWithHttpInfo
     *
     * Company Full Service Setup Submission Component
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullServiceSetupSubmission'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function fullServiceSetupSubmissionWithHttpInfo($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['fullServiceSetupSubmission'][0])
    {
        $request = $this->fullServiceSetupSubmissionRequest($company, $company_signatory_agreements_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fullServiceSetupSubmissionAsync
     *
     * Company Full Service Setup Submission Component
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullServiceSetupSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullServiceSetupSubmissionAsync($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['fullServiceSetupSubmission'][0])
    {
        return $this->fullServiceSetupSubmissionAsyncWithHttpInfo($company, $company_signatory_agreements_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fullServiceSetupSubmissionAsyncWithHttpInfo
     *
     * Company Full Service Setup Submission Component
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullServiceSetupSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullServiceSetupSubmissionAsyncWithHttpInfo($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['fullServiceSetupSubmission'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->fullServiceSetupSubmissionRequest($company, $company_signatory_agreements_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fullServiceSetupSubmission'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  \OpenAPI\Client\Model\CompanySignatoryAgreementsRequest $company_signatory_agreements_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullServiceSetupSubmission'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fullServiceSetupSubmissionRequest($company, $company_signatory_agreements_request = null, string $contentType = self::contentTypes['fullServiceSetupSubmission'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling fullServiceSetupSubmission'
            );
        }



        $resourcePath = '/companies/{company}/components/full_service_setup_submission';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($company_signatory_agreements_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($company_signatory_agreements_request));
            } else {
                $httpBody = $company_signatory_agreements_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateContractorOnboardLink
     *
     * Contractor Onboard
     *
     * @param  string $contractor Generate an onboard link for this contractor ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateContractorOnboardLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object
     */
    public function generateContractorOnboardLink($contractor, string $contentType = self::contentTypes['generateContractorOnboardLink'][0])
    {
        list($response) = $this->generateContractorOnboardLinkWithHttpInfo($contractor, $contentType);
        return $response;
    }

    /**
     * Operation generateContractorOnboardLinkWithHttpInfo
     *
     * Contractor Onboard
     *
     * @param  string $contractor Generate an onboard link for this contractor ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateContractorOnboardLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateContractorOnboardLinkWithHttpInfo($contractor, string $contentType = self::contentTypes['generateContractorOnboardLink'][0])
    {
        $request = $this->generateContractorOnboardLinkRequest($contractor, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GenerateOnboardLink1200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GenerateOnboardLink1200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateContractorOnboardLinkAsync
     *
     * Contractor Onboard
     *
     * @param  string $contractor Generate an onboard link for this contractor ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateContractorOnboardLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateContractorOnboardLinkAsync($contractor, string $contentType = self::contentTypes['generateContractorOnboardLink'][0])
    {
        return $this->generateContractorOnboardLinkAsyncWithHttpInfo($contractor, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateContractorOnboardLinkAsyncWithHttpInfo
     *
     * Contractor Onboard
     *
     * @param  string $contractor Generate an onboard link for this contractor ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateContractorOnboardLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateContractorOnboardLinkAsyncWithHttpInfo($contractor, string $contentType = self::contentTypes['generateContractorOnboardLink'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
        $request = $this->generateContractorOnboardLinkRequest($contractor, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateContractorOnboardLink'
     *
     * @param  string $contractor Generate an onboard link for this contractor ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateContractorOnboardLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generateContractorOnboardLinkRequest($contractor, string $contentType = self::contentTypes['generateContractorOnboardLink'][0])
    {

        // verify the required parameter 'contractor' is set
        if ($contractor === null || (is_array($contractor) && count($contractor) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractor when calling generateContractorOnboardLink'
            );
        }


        $resourcePath = '/contractors/{contractor}/onboard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contractor !== null) {
            $resourcePath = str_replace(
                '{' . 'contractor' . '}',
                ObjectSerializer::toPathValue($contractor),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateOnboardLink
     *
     * Company Onboard
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateOnboardLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object
     */
    public function generateOnboardLink($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['generateOnboardLink'][0])
    {
        list($response) = $this->generateOnboardLinkWithHttpInfo($company, $generate_onboard_link_request, $contentType);
        return $response;
    }

    /**
     * Operation generateOnboardLinkWithHttpInfo
     *
     * Company Onboard
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateOnboardLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateOnboardLinkWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['generateOnboardLink'][0])
    {
        $request = $this->generateOnboardLinkRequest($company, $generate_onboard_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GenerateOnboardLink1200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GenerateOnboardLink1200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateOnboardLinkAsync
     *
     * Company Onboard
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateOnboardLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateOnboardLinkAsync($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['generateOnboardLink'][0])
    {
        return $this->generateOnboardLinkAsyncWithHttpInfo($company, $generate_onboard_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateOnboardLinkAsyncWithHttpInfo
     *
     * Company Onboard
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateOnboardLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateOnboardLinkAsyncWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['generateOnboardLink'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
        $request = $this->generateOnboardLinkRequest($company, $generate_onboard_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateOnboardLink'
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateOnboardLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generateOnboardLinkRequest($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['generateOnboardLink'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling generateOnboardLink'
            );
        }



        $resourcePath = '/companies/{company}/onboard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($generate_onboard_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($generate_onboard_link_request));
            } else {
                $httpBody = $generate_onboard_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateOnboardLink1
     *
     * Employee Onboard
     *
     * @param  string $employee Generate an onboard link for this employee ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateOnboardLink1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object
     */
    public function generateOnboardLink1($employee, string $contentType = self::contentTypes['generateOnboardLink1'][0])
    {
        list($response) = $this->generateOnboardLink1WithHttpInfo($employee, $contentType);
        return $response;
    }

    /**
     * Operation generateOnboardLink1WithHttpInfo
     *
     * Employee Onboard
     *
     * @param  string $employee Generate an onboard link for this employee ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateOnboardLink1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateOnboardLink1WithHttpInfo($employee, string $contentType = self::contentTypes['generateOnboardLink1'][0])
    {
        $request = $this->generateOnboardLink1Request($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GenerateOnboardLink1200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GenerateOnboardLink1200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateOnboardLink1Async
     *
     * Employee Onboard
     *
     * @param  string $employee Generate an onboard link for this employee ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateOnboardLink1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateOnboardLink1Async($employee, string $contentType = self::contentTypes['generateOnboardLink1'][0])
    {
        return $this->generateOnboardLink1AsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateOnboardLink1AsyncWithHttpInfo
     *
     * Employee Onboard
     *
     * @param  string $employee Generate an onboard link for this employee ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateOnboardLink1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateOnboardLink1AsyncWithHttpInfo($employee, string $contentType = self::contentTypes['generateOnboardLink1'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
        $request = $this->generateOnboardLink1Request($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateOnboardLink1'
     *
     * @param  string $employee Generate an onboard link for this employee ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateOnboardLink1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generateOnboardLink1Request($employee, string $contentType = self::contentTypes['generateOnboardLink1'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling generateOnboardLink1'
            );
        }


        $resourcePath = '/employees/{employee}/onboard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getABankAccount
     *
     * Get a bank account
     *
     * @param  string $bank_account ID for the bank account to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getABankAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListBankAccounts200ResponseInner
     */
    public function getABankAccount($bank_account, string $contentType = self::contentTypes['getABankAccount'][0])
    {
        list($response) = $this->getABankAccountWithHttpInfo($bank_account, $contentType);
        return $response;
    }

    /**
     * Operation getABankAccountWithHttpInfo
     *
     * Get a bank account
     *
     * @param  string $bank_account ID for the bank account to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getABankAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListBankAccounts200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getABankAccountWithHttpInfo($bank_account, string $contentType = self::contentTypes['getABankAccount'][0])
    {
        $request = $this->getABankAccountRequest($bank_account, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListBankAccounts200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListBankAccounts200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListBankAccounts200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListBankAccounts200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListBankAccounts200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getABankAccountAsync
     *
     * Get a bank account
     *
     * @param  string $bank_account ID for the bank account to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getABankAccountAsync($bank_account, string $contentType = self::contentTypes['getABankAccount'][0])
    {
        return $this->getABankAccountAsyncWithHttpInfo($bank_account, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getABankAccountAsyncWithHttpInfo
     *
     * Get a bank account
     *
     * @param  string $bank_account ID for the bank account to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getABankAccountAsyncWithHttpInfo($bank_account, string $contentType = self::contentTypes['getABankAccount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListBankAccounts200ResponseInner';
        $request = $this->getABankAccountRequest($bank_account, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getABankAccount'
     *
     * @param  string $bank_account ID for the bank account to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getABankAccountRequest($bank_account, string $contentType = self::contentTypes['getABankAccount'][0])
    {

        // verify the required parameter 'bank_account' is set
        if ($bank_account === null || (is_array($bank_account) && count($bank_account) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bank_account when calling getABankAccount'
            );
        }


        $resourcePath = '/bank_accounts/{bank_account}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($bank_account !== null) {
            $resourcePath = str_replace(
                '{' . 'bank_account' . '}',
                ObjectSerializer::toPathValue($bank_account),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getACompany
     *
     * Get a company
     *
     * @param  string $company ID of the company to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompany'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getACompany($company, string $contentType = self::contentTypes['getACompany'][0])
    {
        list($response) = $this->getACompanyWithHttpInfo($company, $contentType);
        return $response;
    }

    /**
     * Operation getACompanyWithHttpInfo
     *
     * Get a company
     *
     * @param  string $company ID of the company to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompany'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getACompanyWithHttpInfo($company, string $contentType = self::contentTypes['getACompany'][0])
    {
        $request = $this->getACompanyRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getACompanyAsync
     *
     * Get a company
     *
     * @param  string $company ID of the company to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanyAsync($company, string $contentType = self::contentTypes['getACompany'][0])
    {
        return $this->getACompanyAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getACompanyAsyncWithHttpInfo
     *
     * Get a company
     *
     * @param  string $company ID of the company to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanyAsyncWithHttpInfo($company, string $contentType = self::contentTypes['getACompany'][0])
    {
        $returnType = 'object';
        $request = $this->getACompanyRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getACompany'
     *
     * @param  string $company ID of the company to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getACompanyRequest($company, string $contentType = self::contentTypes['getACompany'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getACompany'
            );
        }


        $resourcePath = '/companies/{company}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getACompanyAuthorizationDocument
     *
     * Get a company authorization document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyAuthorizationDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getACompanyAuthorizationDocument(string $contentType = self::contentTypes['getACompanyAuthorizationDocument'][0])
    {
        list($response) = $this->getACompanyAuthorizationDocumentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getACompanyAuthorizationDocumentWithHttpInfo
     *
     * Get a company authorization document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyAuthorizationDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getACompanyAuthorizationDocumentWithHttpInfo(string $contentType = self::contentTypes['getACompanyAuthorizationDocument'][0])
    {
        $request = $this->getACompanyAuthorizationDocumentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getACompanyAuthorizationDocumentAsync
     *
     * Get a company authorization document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyAuthorizationDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanyAuthorizationDocumentAsync(string $contentType = self::contentTypes['getACompanyAuthorizationDocument'][0])
    {
        return $this->getACompanyAuthorizationDocumentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getACompanyAuthorizationDocumentAsyncWithHttpInfo
     *
     * Get a company authorization document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyAuthorizationDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanyAuthorizationDocumentAsyncWithHttpInfo(string $contentType = self::contentTypes['getACompanyAuthorizationDocument'][0])
    {
        $returnType = 'object';
        $request = $this->getACompanyAuthorizationDocumentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getACompanyAuthorizationDocument'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyAuthorizationDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getACompanyAuthorizationDocumentRequest(string $contentType = self::contentTypes['getACompanyAuthorizationDocument'][0])
    {


        $resourcePath = '/documents/company_authorization_documents/{document}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getACompanyBenefit
     *
     * Get a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner|object
     */
    public function getACompanyBenefit($company_benefit, string $contentType = self::contentTypes['getACompanyBenefit'][0])
    {
        list($response) = $this->getACompanyBenefitWithHttpInfo($company_benefit, $contentType);
        return $response;
    }

    /**
     * Operation getACompanyBenefitWithHttpInfo
     *
     * Get a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getACompanyBenefitWithHttpInfo($company_benefit, string $contentType = self::contentTypes['getACompanyBenefit'][0])
    {
        $request = $this->getACompanyBenefitRequest($company_benefit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getACompanyBenefitAsync
     *
     * Get a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanyBenefitAsync($company_benefit, string $contentType = self::contentTypes['getACompanyBenefit'][0])
    {
        return $this->getACompanyBenefitAsyncWithHttpInfo($company_benefit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getACompanyBenefitAsyncWithHttpInfo
     *
     * Get a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanyBenefitAsyncWithHttpInfo($company_benefit, string $contentType = self::contentTypes['getACompanyBenefit'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner';
        $request = $this->getACompanyBenefitRequest($company_benefit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getACompanyBenefit'
     *
     * @param  string $company_benefit ID of the company benefit to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getACompanyBenefitRequest($company_benefit, string $contentType = self::contentTypes['getACompanyBenefit'][0])
    {

        // verify the required parameter 'company_benefit' is set
        if ($company_benefit === null || (is_array($company_benefit) && count($company_benefit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company_benefit when calling getACompanyBenefit'
            );
        }


        $resourcePath = '/company_benefits/{company_benefit}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company_benefit !== null) {
            $resourcePath = str_replace(
                '{' . 'company_benefit' . '}',
                ObjectSerializer::toPathValue($company_benefit),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getACompanyProvidedDocument
     *
     * Get a company provided document
     *
     * @param  string $document ID of the company provided document to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner|object
     */
    public function getACompanyProvidedDocument($document, string $contentType = self::contentTypes['getACompanyProvidedDocument'][0])
    {
        list($response) = $this->getACompanyProvidedDocumentWithHttpInfo($document, $contentType);
        return $response;
    }

    /**
     * Operation getACompanyProvidedDocumentWithHttpInfo
     *
     * Get a company provided document
     *
     * @param  string $document ID of the company provided document to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getACompanyProvidedDocumentWithHttpInfo($document, string $contentType = self::contentTypes['getACompanyProvidedDocument'][0])
    {
        $request = $this->getACompanyProvidedDocumentRequest($document, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getACompanyProvidedDocumentAsync
     *
     * Get a company provided document
     *
     * @param  string $document ID of the company provided document to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanyProvidedDocumentAsync($document, string $contentType = self::contentTypes['getACompanyProvidedDocument'][0])
    {
        return $this->getACompanyProvidedDocumentAsyncWithHttpInfo($document, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getACompanyProvidedDocumentAsyncWithHttpInfo
     *
     * Get a company provided document
     *
     * @param  string $document ID of the company provided document to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanyProvidedDocumentAsyncWithHttpInfo($document, string $contentType = self::contentTypes['getACompanyProvidedDocument'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200ResponseResultsInner';
        $request = $this->getACompanyProvidedDocumentRequest($document, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getACompanyProvidedDocument'
     *
     * @param  string $document ID of the company provided document to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getACompanyProvidedDocumentRequest($document, string $contentType = self::contentTypes['getACompanyProvidedDocument'][0])
    {

        // verify the required parameter 'document' is set
        if ($document === null || (is_array($document) && count($document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document when calling getACompanyProvidedDocument'
            );
        }


        $resourcePath = '/company_provided_documents/{document}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($document !== null) {
            $resourcePath = str_replace(
                '{' . 'document' . '}',
                ObjectSerializer::toPathValue($document),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getACompanyTaxDocument
     *
     * Get a company tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getACompanyTaxDocument(string $contentType = self::contentTypes['getACompanyTaxDocument'][0])
    {
        list($response) = $this->getACompanyTaxDocumentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getACompanyTaxDocumentWithHttpInfo
     *
     * Get a company tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getACompanyTaxDocumentWithHttpInfo(string $contentType = self::contentTypes['getACompanyTaxDocument'][0])
    {
        $request = $this->getACompanyTaxDocumentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getACompanyTaxDocumentAsync
     *
     * Get a company tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanyTaxDocumentAsync(string $contentType = self::contentTypes['getACompanyTaxDocument'][0])
    {
        return $this->getACompanyTaxDocumentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getACompanyTaxDocumentAsyncWithHttpInfo
     *
     * Get a company tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanyTaxDocumentAsyncWithHttpInfo(string $contentType = self::contentTypes['getACompanyTaxDocument'][0])
    {
        $returnType = 'object';
        $request = $this->getACompanyTaxDocumentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getACompanyTaxDocument'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanyTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getACompanyTaxDocumentRequest(string $contentType = self::contentTypes['getACompanyTaxDocument'][0])
    {


        $resourcePath = '/documents/company_tax_documents/{document}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getACompanysRequirements
     *
     * Get a requirement
     *
     * @param  string $requirement ID of the requirement (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanysRequirements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetACompanysRequirements200Response|object
     */
    public function getACompanysRequirements($requirement, string $contentType = self::contentTypes['getACompanysRequirements'][0])
    {
        list($response) = $this->getACompanysRequirementsWithHttpInfo($requirement, $contentType);
        return $response;
    }

    /**
     * Operation getACompanysRequirementsWithHttpInfo
     *
     * Get a requirement
     *
     * @param  string $requirement ID of the requirement (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanysRequirements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetACompanysRequirements200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getACompanysRequirementsWithHttpInfo($requirement, string $contentType = self::contentTypes['getACompanysRequirements'][0])
    {
        $request = $this->getACompanysRequirementsRequest($requirement, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetACompanysRequirements200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetACompanysRequirements200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetACompanysRequirements200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetACompanysRequirements200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetACompanysRequirements200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getACompanysRequirementsAsync
     *
     * Get a requirement
     *
     * @param  string $requirement ID of the requirement (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanysRequirements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanysRequirementsAsync($requirement, string $contentType = self::contentTypes['getACompanysRequirements'][0])
    {
        return $this->getACompanysRequirementsAsyncWithHttpInfo($requirement, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getACompanysRequirementsAsyncWithHttpInfo
     *
     * Get a requirement
     *
     * @param  string $requirement ID of the requirement (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanysRequirements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getACompanysRequirementsAsyncWithHttpInfo($requirement, string $contentType = self::contentTypes['getACompanysRequirements'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetACompanysRequirements200Response';
        $request = $this->getACompanysRequirementsRequest($requirement, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getACompanysRequirements'
     *
     * @param  string $requirement ID of the requirement (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getACompanysRequirements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getACompanysRequirementsRequest($requirement, string $contentType = self::contentTypes['getACompanysRequirements'][0])
    {

        // verify the required parameter 'requirement' is set
        if ($requirement === null || (is_array($requirement) && count($requirement) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $requirement when calling getACompanysRequirements'
            );
        }


        $resourcePath = '/requirements/{requirement}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($requirement !== null) {
            $resourcePath = str_replace(
                '{' . 'requirement' . '}',
                ObjectSerializer::toPathValue($requirement),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAContractor
     *
     * Get a contractor
     *
     * @param  string $contractor ID of the contractor to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractor'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getAContractor($contractor, string $contentType = self::contentTypes['getAContractor'][0])
    {
        $this->getAContractorWithHttpInfo($contractor, $contentType);
    }

    /**
     * Operation getAContractorWithHttpInfo
     *
     * Get a contractor
     *
     * @param  string $contractor ID of the contractor to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractor'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAContractorWithHttpInfo($contractor, string $contentType = self::contentTypes['getAContractor'][0])
    {
        $request = $this->getAContractorRequest($contractor, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAContractorAsync
     *
     * Get a contractor
     *
     * @param  string $contractor ID of the contractor to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAContractorAsync($contractor, string $contentType = self::contentTypes['getAContractor'][0])
    {
        return $this->getAContractorAsyncWithHttpInfo($contractor, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAContractorAsyncWithHttpInfo
     *
     * Get a contractor
     *
     * @param  string $contractor ID of the contractor to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAContractorAsyncWithHttpInfo($contractor, string $contentType = self::contentTypes['getAContractor'][0])
    {
        $returnType = '';
        $request = $this->getAContractorRequest($contractor, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAContractor'
     *
     * @param  string $contractor ID of the contractor to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAContractorRequest($contractor, string $contentType = self::contentTypes['getAContractor'][0])
    {

        // verify the required parameter 'contractor' is set
        if ($contractor === null || (is_array($contractor) && count($contractor) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractor when calling getAContractor'
            );
        }


        $resourcePath = '/contractors/{contractor}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contractor !== null) {
            $resourcePath = str_replace(
                '{' . 'contractor' . '}',
                ObjectSerializer::toPathValue($contractor),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAContractorPayment
     *
     * Get a contractor pay statement
     *
     * @param  string $contractor_payment ID of the contractor payment to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractorPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getAContractorPayment($contractor_payment, string $contentType = self::contentTypes['getAContractorPayment'][0])
    {
        list($response) = $this->getAContractorPaymentWithHttpInfo($contractor_payment, $contentType);
        return $response;
    }

    /**
     * Operation getAContractorPaymentWithHttpInfo
     *
     * Get a contractor pay statement
     *
     * @param  string $contractor_payment ID of the contractor payment to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractorPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAContractorPaymentWithHttpInfo($contractor_payment, string $contentType = self::contentTypes['getAContractorPayment'][0])
    {
        $request = $this->getAContractorPaymentRequest($contractor_payment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAContractorPaymentAsync
     *
     * Get a contractor pay statement
     *
     * @param  string $contractor_payment ID of the contractor payment to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAContractorPaymentAsync($contractor_payment, string $contentType = self::contentTypes['getAContractorPayment'][0])
    {
        return $this->getAContractorPaymentAsyncWithHttpInfo($contractor_payment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAContractorPaymentAsyncWithHttpInfo
     *
     * Get a contractor pay statement
     *
     * @param  string $contractor_payment ID of the contractor payment to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAContractorPaymentAsyncWithHttpInfo($contractor_payment, string $contentType = self::contentTypes['getAContractorPayment'][0])
    {
        $returnType = 'object';
        $request = $this->getAContractorPaymentRequest($contractor_payment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAContractorPayment'
     *
     * @param  string $contractor_payment ID of the contractor payment to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAContractorPaymentRequest($contractor_payment, string $contentType = self::contentTypes['getAContractorPayment'][0])
    {

        // verify the required parameter 'contractor_payment' is set
        if ($contractor_payment === null || (is_array($contractor_payment) && count($contractor_payment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractor_payment when calling getAContractorPayment'
            );
        }


        $resourcePath = '/contractor_payments/{contractor_payment}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contractor_payment !== null) {
            $resourcePath = str_replace(
                '{' . 'contractor_payment' . '}',
                ObjectSerializer::toPathValue($contractor_payment),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAContractorTaxDocument
     *
     * Get a contractor tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractorTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getAContractorTaxDocument(string $contentType = self::contentTypes['getAContractorTaxDocument'][0])
    {
        list($response) = $this->getAContractorTaxDocumentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getAContractorTaxDocumentWithHttpInfo
     *
     * Get a contractor tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractorTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAContractorTaxDocumentWithHttpInfo(string $contentType = self::contentTypes['getAContractorTaxDocument'][0])
    {
        $request = $this->getAContractorTaxDocumentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAContractorTaxDocumentAsync
     *
     * Get a contractor tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractorTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAContractorTaxDocumentAsync(string $contentType = self::contentTypes['getAContractorTaxDocument'][0])
    {
        return $this->getAContractorTaxDocumentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAContractorTaxDocumentAsyncWithHttpInfo
     *
     * Get a contractor tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractorTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAContractorTaxDocumentAsyncWithHttpInfo(string $contentType = self::contentTypes['getAContractorTaxDocument'][0])
    {
        $returnType = 'object';
        $request = $this->getAContractorTaxDocumentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAContractorTaxDocument'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAContractorTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAContractorTaxDocumentRequest(string $contentType = self::contentTypes['getAContractorTaxDocument'][0])
    {


        $resourcePath = '/documents/contractor_tax_documents/{document}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAFederalEinVerification
     *
     * Get a Federal EIN Verification
     *
     * @param  string $company ID of the company (required)
     * @param  string $federal_ein_verification ID of the federal EIN verification (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAFederalEinVerification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListFederalEinVerifications200ResponseResultsInner|object
     */
    public function getAFederalEinVerification($company, $federal_ein_verification, string $contentType = self::contentTypes['getAFederalEinVerification'][0])
    {
        list($response) = $this->getAFederalEinVerificationWithHttpInfo($company, $federal_ein_verification, $contentType);
        return $response;
    }

    /**
     * Operation getAFederalEinVerificationWithHttpInfo
     *
     * Get a Federal EIN Verification
     *
     * @param  string $company ID of the company (required)
     * @param  string $federal_ein_verification ID of the federal EIN verification (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAFederalEinVerification'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListFederalEinVerifications200ResponseResultsInner|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAFederalEinVerificationWithHttpInfo($company, $federal_ein_verification, string $contentType = self::contentTypes['getAFederalEinVerification'][0])
    {
        $request = $this->getAFederalEinVerificationRequest($company, $federal_ein_verification, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListFederalEinVerifications200ResponseResultsInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListFederalEinVerifications200ResponseResultsInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListFederalEinVerifications200ResponseResultsInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListFederalEinVerifications200ResponseResultsInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListFederalEinVerifications200ResponseResultsInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAFederalEinVerificationAsync
     *
     * Get a Federal EIN Verification
     *
     * @param  string $company ID of the company (required)
     * @param  string $federal_ein_verification ID of the federal EIN verification (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAFederalEinVerification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAFederalEinVerificationAsync($company, $federal_ein_verification, string $contentType = self::contentTypes['getAFederalEinVerification'][0])
    {
        return $this->getAFederalEinVerificationAsyncWithHttpInfo($company, $federal_ein_verification, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAFederalEinVerificationAsyncWithHttpInfo
     *
     * Get a Federal EIN Verification
     *
     * @param  string $company ID of the company (required)
     * @param  string $federal_ein_verification ID of the federal EIN verification (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAFederalEinVerification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAFederalEinVerificationAsyncWithHttpInfo($company, $federal_ein_verification, string $contentType = self::contentTypes['getAFederalEinVerification'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListFederalEinVerifications200ResponseResultsInner';
        $request = $this->getAFederalEinVerificationRequest($company, $federal_ein_verification, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAFederalEinVerification'
     *
     * @param  string $company ID of the company (required)
     * @param  string $federal_ein_verification ID of the federal EIN verification (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAFederalEinVerification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAFederalEinVerificationRequest($company, $federal_ein_verification, string $contentType = self::contentTypes['getAFederalEinVerification'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getAFederalEinVerification'
            );
        }

        // verify the required parameter 'federal_ein_verification' is set
        if ($federal_ein_verification === null || (is_array($federal_ein_verification) && count($federal_ein_verification) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $federal_ein_verification when calling getAFederalEinVerification'
            );
        }


        $resourcePath = '/companies/{company}/federal_ein_verifications/{federal_ein_verification}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }
        // path params
        if ($federal_ein_verification !== null) {
            $resourcePath = str_replace(
                '{' . 'federal_ein_verification' . '}',
                ObjectSerializer::toPathValue($federal_ein_verification),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAForm
     *
     * Get a form
     *
     * @param  string $form form (required)
     * @param  string $type By adding type&#x3D;contractor_setup as a query parameter, we will surface all of of the contractor specific forms. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getAForm($form, $type = null, string $contentType = self::contentTypes['getAForm'][0])
    {
        $this->getAFormWithHttpInfo($form, $type, $contentType);
    }

    /**
     * Operation getAFormWithHttpInfo
     *
     * Get a form
     *
     * @param  string $form (required)
     * @param  string $type By adding type&#x3D;contractor_setup as a query parameter, we will surface all of of the contractor specific forms. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAFormWithHttpInfo($form, $type = null, string $contentType = self::contentTypes['getAForm'][0])
    {
        $request = $this->getAFormRequest($form, $type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAFormAsync
     *
     * Get a form
     *
     * @param  string $form (required)
     * @param  string $type By adding type&#x3D;contractor_setup as a query parameter, we will surface all of of the contractor specific forms. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAFormAsync($form, $type = null, string $contentType = self::contentTypes['getAForm'][0])
    {
        return $this->getAFormAsyncWithHttpInfo($form, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAFormAsyncWithHttpInfo
     *
     * Get a form
     *
     * @param  string $form (required)
     * @param  string $type By adding type&#x3D;contractor_setup as a query parameter, we will surface all of of the contractor specific forms. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAFormAsyncWithHttpInfo($form, $type = null, string $contentType = self::contentTypes['getAForm'][0])
    {
        $returnType = '';
        $request = $this->getAFormRequest($form, $type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAForm'
     *
     * @param  string $form (required)
     * @param  string $type By adding type&#x3D;contractor_setup as a query parameter, we will surface all of of the contractor specific forms. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAFormRequest($form, $type = null, string $contentType = self::contentTypes['getAForm'][0])
    {

        // verify the required parameter 'form' is set
        if ($form === null || (is_array($form) && count($form) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $form when calling getAForm'
            );
        }



        $resourcePath = '/forms/{form}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($form !== null) {
            $resourcePath = str_replace(
                '{' . 'form' . '}',
                ObjectSerializer::toPathValue($form),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getANetPaySplit
     *
     * Get a net pay split
     *
     * @param  string $net_pay_split ID of the net pay split to be returned (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getANetPaySplit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListNetPaySplits200ResponseInner
     */
    public function getANetPaySplit($net_pay_split, string $contentType = self::contentTypes['getANetPaySplit'][0])
    {
        list($response) = $this->getANetPaySplitWithHttpInfo($net_pay_split, $contentType);
        return $response;
    }

    /**
     * Operation getANetPaySplitWithHttpInfo
     *
     * Get a net pay split
     *
     * @param  string $net_pay_split ID of the net pay split to be returned (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getANetPaySplit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListNetPaySplits200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getANetPaySplitWithHttpInfo($net_pay_split, string $contentType = self::contentTypes['getANetPaySplit'][0])
    {
        $request = $this->getANetPaySplitRequest($net_pay_split, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getANetPaySplitAsync
     *
     * Get a net pay split
     *
     * @param  string $net_pay_split ID of the net pay split to be returned (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getANetPaySplit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getANetPaySplitAsync($net_pay_split, string $contentType = self::contentTypes['getANetPaySplit'][0])
    {
        return $this->getANetPaySplitAsyncWithHttpInfo($net_pay_split, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getANetPaySplitAsyncWithHttpInfo
     *
     * Get a net pay split
     *
     * @param  string $net_pay_split ID of the net pay split to be returned (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getANetPaySplit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getANetPaySplitAsyncWithHttpInfo($net_pay_split, string $contentType = self::contentTypes['getANetPaySplit'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner';
        $request = $this->getANetPaySplitRequest($net_pay_split, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getANetPaySplit'
     *
     * @param  string $net_pay_split ID of the net pay split to be returned (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getANetPaySplit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getANetPaySplitRequest($net_pay_split, string $contentType = self::contentTypes['getANetPaySplit'][0])
    {

        // verify the required parameter 'net_pay_split' is set
        if ($net_pay_split === null || (is_array($net_pay_split) && count($net_pay_split) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $net_pay_split when calling getANetPaySplit'
            );
        }


        $resourcePath = '/net_pay_splits/{net_pay_split}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($net_pay_split !== null) {
            $resourcePath = str_replace(
                '{' . 'net_pay_split' . '}',
                ObjectSerializer::toPathValue($net_pay_split),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPaperCheck
     *
     * Get a paper check
     *
     * @param  string $payroll_item ID of the payroll item to return (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaperCheck'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAPaperCheck202Response|object
     */
    public function getAPaperCheck($payroll_item, $accept = null, string $contentType = self::contentTypes['getAPaperCheck'][0])
    {
        list($response) = $this->getAPaperCheckWithHttpInfo($payroll_item, $accept, $contentType);
        return $response;
    }

    /**
     * Operation getAPaperCheckWithHttpInfo
     *
     * Get a paper check
     *
     * @param  string $payroll_item ID of the payroll item to return (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaperCheck'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAPaperCheck202Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPaperCheckWithHttpInfo($payroll_item, $accept = null, string $contentType = self::contentTypes['getAPaperCheck'][0])
    {
        $request = $this->getAPaperCheckRequest($payroll_item, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Model\GetAPaperCheck202Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAPaperCheck202Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAPaperCheck202Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAPaperCheck202Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAPaperCheck202Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPaperCheckAsync
     *
     * Get a paper check
     *
     * @param  string $payroll_item ID of the payroll item to return (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaperCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaperCheckAsync($payroll_item, $accept = null, string $contentType = self::contentTypes['getAPaperCheck'][0])
    {
        return $this->getAPaperCheckAsyncWithHttpInfo($payroll_item, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPaperCheckAsyncWithHttpInfo
     *
     * Get a paper check
     *
     * @param  string $payroll_item ID of the payroll item to return (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaperCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaperCheckAsyncWithHttpInfo($payroll_item, $accept = null, string $contentType = self::contentTypes['getAPaperCheck'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAPaperCheck202Response';
        $request = $this->getAPaperCheckRequest($payroll_item, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPaperCheck'
     *
     * @param  string $payroll_item ID of the payroll item to return (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaperCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAPaperCheckRequest($payroll_item, $accept = null, string $contentType = self::contentTypes['getAPaperCheck'][0])
    {

        // verify the required parameter 'payroll_item' is set
        if ($payroll_item === null || (is_array($payroll_item) && count($payroll_item) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll_item when calling getAPaperCheck'
            );
        }



        $resourcePath = '/payroll_items/{payroll_item}/paper_check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($payroll_item !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll_item' . '}',
                ObjectSerializer::toPathValue($payroll_item),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPaperCheck2
     *
     * Get a paper check
     *
     * @param  string $contractor_payment ID of the contractor payment to return (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaperCheck2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAPaperCheck202Response|object
     */
    public function getAPaperCheck2($contractor_payment, $accept = null, string $contentType = self::contentTypes['getAPaperCheck2'][0])
    {
        list($response) = $this->getAPaperCheck2WithHttpInfo($contractor_payment, $accept, $contentType);
        return $response;
    }

    /**
     * Operation getAPaperCheck2WithHttpInfo
     *
     * Get a paper check
     *
     * @param  string $contractor_payment ID of the contractor payment to return (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaperCheck2'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAPaperCheck202Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPaperCheck2WithHttpInfo($contractor_payment, $accept = null, string $contentType = self::contentTypes['getAPaperCheck2'][0])
    {
        $request = $this->getAPaperCheck2Request($contractor_payment, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Model\GetAPaperCheck202Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAPaperCheck202Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAPaperCheck202Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAPaperCheck202Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAPaperCheck202Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPaperCheck2Async
     *
     * Get a paper check
     *
     * @param  string $contractor_payment ID of the contractor payment to return (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaperCheck2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaperCheck2Async($contractor_payment, $accept = null, string $contentType = self::contentTypes['getAPaperCheck2'][0])
    {
        return $this->getAPaperCheck2AsyncWithHttpInfo($contractor_payment, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPaperCheck2AsyncWithHttpInfo
     *
     * Get a paper check
     *
     * @param  string $contractor_payment ID of the contractor payment to return (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaperCheck2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaperCheck2AsyncWithHttpInfo($contractor_payment, $accept = null, string $contentType = self::contentTypes['getAPaperCheck2'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAPaperCheck202Response';
        $request = $this->getAPaperCheck2Request($contractor_payment, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPaperCheck2'
     *
     * @param  string $contractor_payment ID of the contractor payment to return (required)
     * @param  string $accept application/pdf (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaperCheck2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAPaperCheck2Request($contractor_payment, $accept = null, string $contentType = self::contentTypes['getAPaperCheck2'][0])
    {

        // verify the required parameter 'contractor_payment' is set
        if ($contractor_payment === null || (is_array($contractor_payment) && count($contractor_payment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractor_payment when calling getAPaperCheck2'
            );
        }



        $resourcePath = '/contractor_payments/{contractor_payment}/paper_check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($contractor_payment !== null) {
            $resourcePath = str_replace(
                '{' . 'contractor_payment' . '}',
                ObjectSerializer::toPathValue($contractor_payment),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPaySchedule
     *
     * Get a pay schedule
     *
     * @param  string $pay_schedule pay_schedule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaySchedule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAPaySchedule200Response|object
     */
    public function getAPaySchedule($pay_schedule, string $contentType = self::contentTypes['getAPaySchedule'][0])
    {
        list($response) = $this->getAPayScheduleWithHttpInfo($pay_schedule, $contentType);
        return $response;
    }

    /**
     * Operation getAPayScheduleWithHttpInfo
     *
     * Get a pay schedule
     *
     * @param  string $pay_schedule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaySchedule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAPaySchedule200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPayScheduleWithHttpInfo($pay_schedule, string $contentType = self::contentTypes['getAPaySchedule'][0])
    {
        $request = $this->getAPayScheduleRequest($pay_schedule, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAPaySchedule200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAPaySchedule200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAPaySchedule200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAPaySchedule200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAPaySchedule200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPayScheduleAsync
     *
     * Get a pay schedule
     *
     * @param  string $pay_schedule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaySchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPayScheduleAsync($pay_schedule, string $contentType = self::contentTypes['getAPaySchedule'][0])
    {
        return $this->getAPayScheduleAsyncWithHttpInfo($pay_schedule, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPayScheduleAsyncWithHttpInfo
     *
     * Get a pay schedule
     *
     * @param  string $pay_schedule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaySchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPayScheduleAsyncWithHttpInfo($pay_schedule, string $contentType = self::contentTypes['getAPaySchedule'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAPaySchedule200Response';
        $request = $this->getAPayScheduleRequest($pay_schedule, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPaySchedule'
     *
     * @param  string $pay_schedule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaySchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAPayScheduleRequest($pay_schedule, string $contentType = self::contentTypes['getAPaySchedule'][0])
    {

        // verify the required parameter 'pay_schedule' is set
        if ($pay_schedule === null || (is_array($pay_schedule) && count($pay_schedule) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pay_schedule when calling getAPaySchedule'
            );
        }


        $resourcePath = '/pay_schedules/{pay_schedule}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pay_schedule !== null) {
            $resourcePath = str_replace(
                '{' . 'pay_schedule' . '}',
                ObjectSerializer::toPathValue($pay_schedule),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPayment
     *
     * Get a tax filing
     *
     * @param  string $tax_filing_id ID corresponding to the tax filing (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAPayment200Response|object
     */
    public function getAPayment($tax_filing_id, string $contentType = self::contentTypes['getAPayment'][0])
    {
        list($response) = $this->getAPaymentWithHttpInfo($tax_filing_id, $contentType);
        return $response;
    }

    /**
     * Operation getAPaymentWithHttpInfo
     *
     * Get a tax filing
     *
     * @param  string $tax_filing_id ID corresponding to the tax filing (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAPayment200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPaymentWithHttpInfo($tax_filing_id, string $contentType = self::contentTypes['getAPayment'][0])
    {
        $request = $this->getAPaymentRequest($tax_filing_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAPayment200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAPayment200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAPayment200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAPayment200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAPayment200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPaymentAsync
     *
     * Get a tax filing
     *
     * @param  string $tax_filing_id ID corresponding to the tax filing (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaymentAsync($tax_filing_id, string $contentType = self::contentTypes['getAPayment'][0])
    {
        return $this->getAPaymentAsyncWithHttpInfo($tax_filing_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPaymentAsyncWithHttpInfo
     *
     * Get a tax filing
     *
     * @param  string $tax_filing_id ID corresponding to the tax filing (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaymentAsyncWithHttpInfo($tax_filing_id, string $contentType = self::contentTypes['getAPayment'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAPayment200Response';
        $request = $this->getAPaymentRequest($tax_filing_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPayment'
     *
     * @param  string $tax_filing_id ID corresponding to the tax filing (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAPaymentRequest($tax_filing_id, string $contentType = self::contentTypes['getAPayment'][0])
    {

        // verify the required parameter 'tax_filing_id' is set
        if ($tax_filing_id === null || (is_array($tax_filing_id) && count($tax_filing_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tax_filing_id when calling getAPayment'
            );
        }


        $resourcePath = '/tax_filings/{tax_filing_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tax_filing_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tax_filing_id' . '}',
                ObjectSerializer::toPathValue($tax_filing_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPaymentAttempt
     *
     * Get a payment attempt
     *
     * @param  string $payment_attempt ID corresponding to payment attempt object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaymentAttempt'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getAPaymentAttempt($payment_attempt, string $contentType = self::contentTypes['getAPaymentAttempt'][0])
    {
        $this->getAPaymentAttemptWithHttpInfo($payment_attempt, $contentType);
    }

    /**
     * Operation getAPaymentAttemptWithHttpInfo
     *
     * Get a payment attempt
     *
     * @param  string $payment_attempt ID corresponding to payment attempt object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaymentAttempt'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPaymentAttemptWithHttpInfo($payment_attempt, string $contentType = self::contentTypes['getAPaymentAttempt'][0])
    {
        $request = $this->getAPaymentAttemptRequest($payment_attempt, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPaymentAttemptAsync
     *
     * Get a payment attempt
     *
     * @param  string $payment_attempt ID corresponding to payment attempt object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaymentAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaymentAttemptAsync($payment_attempt, string $contentType = self::contentTypes['getAPaymentAttempt'][0])
    {
        return $this->getAPaymentAttemptAsyncWithHttpInfo($payment_attempt, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPaymentAttemptAsyncWithHttpInfo
     *
     * Get a payment attempt
     *
     * @param  string $payment_attempt ID corresponding to payment attempt object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaymentAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaymentAttemptAsyncWithHttpInfo($payment_attempt, string $contentType = self::contentTypes['getAPaymentAttempt'][0])
    {
        $returnType = '';
        $request = $this->getAPaymentAttemptRequest($payment_attempt, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPaymentAttempt'
     *
     * @param  string $payment_attempt ID corresponding to payment attempt object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaymentAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAPaymentAttemptRequest($payment_attempt, string $contentType = self::contentTypes['getAPaymentAttempt'][0])
    {

        // verify the required parameter 'payment_attempt' is set
        if ($payment_attempt === null || (is_array($payment_attempt) && count($payment_attempt) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_attempt when calling getAPaymentAttempt'
            );
        }


        $resourcePath = '/payment_attempts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_attempt !== null) {
            $resourcePath = str_replace(
                '{' . 'payment_attempt' . '}',
                ObjectSerializer::toPathValue($payment_attempt),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPaymentAttemptCopy1
     *
     * Get a payment
     *
     * @param  string $payment ID corresponding to payment object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaymentAttemptCopy1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getAPaymentAttemptCopy1($payment, string $contentType = self::contentTypes['getAPaymentAttemptCopy1'][0])
    {
        $this->getAPaymentAttemptCopy1WithHttpInfo($payment, $contentType);
    }

    /**
     * Operation getAPaymentAttemptCopy1WithHttpInfo
     *
     * Get a payment
     *
     * @param  string $payment ID corresponding to payment object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaymentAttemptCopy1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPaymentAttemptCopy1WithHttpInfo($payment, string $contentType = self::contentTypes['getAPaymentAttemptCopy1'][0])
    {
        $request = $this->getAPaymentAttemptCopy1Request($payment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPaymentAttemptCopy1Async
     *
     * Get a payment
     *
     * @param  string $payment ID corresponding to payment object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaymentAttemptCopy1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaymentAttemptCopy1Async($payment, string $contentType = self::contentTypes['getAPaymentAttemptCopy1'][0])
    {
        return $this->getAPaymentAttemptCopy1AsyncWithHttpInfo($payment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPaymentAttemptCopy1AsyncWithHttpInfo
     *
     * Get a payment
     *
     * @param  string $payment ID corresponding to payment object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaymentAttemptCopy1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaymentAttemptCopy1AsyncWithHttpInfo($payment, string $contentType = self::contentTypes['getAPaymentAttemptCopy1'][0])
    {
        $returnType = '';
        $request = $this->getAPaymentAttemptCopy1Request($payment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPaymentAttemptCopy1'
     *
     * @param  string $payment ID corresponding to payment object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaymentAttemptCopy1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAPaymentAttemptCopy1Request($payment, string $contentType = self::contentTypes['getAPaymentAttemptCopy1'][0])
    {

        // verify the required parameter 'payment' is set
        if ($payment === null || (is_array($payment) && count($payment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment when calling getAPaymentAttemptCopy1'
            );
        }


        $resourcePath = '/payments/{payment}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment !== null) {
            $resourcePath = str_replace(
                '{' . 'payment' . '}',
                ObjectSerializer::toPathValue($payment),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPayrollItem
     *
     * Get a payroll item
     *
     * @param  string $payroll_item ID of the payroll item to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPayrollItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getAPayrollItem($payroll_item, string $contentType = self::contentTypes['getAPayrollItem'][0])
    {
        $this->getAPayrollItemWithHttpInfo($payroll_item, $contentType);
    }

    /**
     * Operation getAPayrollItemWithHttpInfo
     *
     * Get a payroll item
     *
     * @param  string $payroll_item ID of the payroll item to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPayrollItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPayrollItemWithHttpInfo($payroll_item, string $contentType = self::contentTypes['getAPayrollItem'][0])
    {
        $request = $this->getAPayrollItemRequest($payroll_item, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getAPayrollItemAsync
     *
     * Get a payroll item
     *
     * @param  string $payroll_item ID of the payroll item to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPayrollItemAsync($payroll_item, string $contentType = self::contentTypes['getAPayrollItem'][0])
    {
        return $this->getAPayrollItemAsyncWithHttpInfo($payroll_item, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPayrollItemAsyncWithHttpInfo
     *
     * Get a payroll item
     *
     * @param  string $payroll_item ID of the payroll item to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPayrollItemAsyncWithHttpInfo($payroll_item, string $contentType = self::contentTypes['getAPayrollItem'][0])
    {
        $returnType = '';
        $request = $this->getAPayrollItemRequest($payroll_item, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPayrollItem'
     *
     * @param  string $payroll_item ID of the payroll item to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAPayrollItemRequest($payroll_item, string $contentType = self::contentTypes['getAPayrollItem'][0])
    {

        // verify the required parameter 'payroll_item' is set
        if ($payroll_item === null || (is_array($payroll_item) && count($payroll_item) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll_item when calling getAPayrollItem'
            );
        }


        $resourcePath = '/payroll_items/{payroll_item}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll_item !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll_item' . '}',
                ObjectSerializer::toPathValue($payroll_item),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPaystub
     *
     * Get a paystub
     *
     * @param  string $employee Return paystub for this employee ID (required)
     * @param  string $payroll Return the paystub for this payroll ID (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaystub'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAPaystub200Response|object
     */
    public function getAPaystub($employee, $payroll, $accept = null, string $contentType = self::contentTypes['getAPaystub'][0])
    {
        list($response) = $this->getAPaystubWithHttpInfo($employee, $payroll, $accept, $contentType);
        return $response;
    }

    /**
     * Operation getAPaystubWithHttpInfo
     *
     * Get a paystub
     *
     * @param  string $employee Return paystub for this employee ID (required)
     * @param  string $payroll Return the paystub for this payroll ID (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaystub'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAPaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPaystubWithHttpInfo($employee, $payroll, $accept = null, string $contentType = self::contentTypes['getAPaystub'][0])
    {
        $request = $this->getAPaystubRequest($employee, $payroll, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAPaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAPaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAPaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAPaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAPaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPaystubAsync
     *
     * Get a paystub
     *
     * @param  string $employee Return paystub for this employee ID (required)
     * @param  string $payroll Return the paystub for this payroll ID (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaystub'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaystubAsync($employee, $payroll, $accept = null, string $contentType = self::contentTypes['getAPaystub'][0])
    {
        return $this->getAPaystubAsyncWithHttpInfo($employee, $payroll, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPaystubAsyncWithHttpInfo
     *
     * Get a paystub
     *
     * @param  string $employee Return paystub for this employee ID (required)
     * @param  string $payroll Return the paystub for this payroll ID (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaystub'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaystubAsyncWithHttpInfo($employee, $payroll, $accept = null, string $contentType = self::contentTypes['getAPaystub'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAPaystub200Response';
        $request = $this->getAPaystubRequest($employee, $payroll, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPaystub'
     *
     * @param  string $employee Return paystub for this employee ID (required)
     * @param  string $payroll Return the paystub for this payroll ID (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaystub'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAPaystubRequest($employee, $payroll, $accept = null, string $contentType = self::contentTypes['getAPaystub'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling getAPaystub'
            );
        }

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling getAPaystub'
            );
        }



        $resourcePath = '/employees/{employee}/paystubs/{payroll}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }
        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPaystub1
     *
     * Get a contractor payment
     *
     * @param  string $contractor Return paystub for this contractor ID (required)
     * @param  string $payroll Return the paystub for this payroll ID (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaystub1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAPaystub1200Response|object
     */
    public function getAPaystub1($contractor, $payroll, $accept = null, string $contentType = self::contentTypes['getAPaystub1'][0])
    {
        list($response) = $this->getAPaystub1WithHttpInfo($contractor, $payroll, $accept, $contentType);
        return $response;
    }

    /**
     * Operation getAPaystub1WithHttpInfo
     *
     * Get a contractor payment
     *
     * @param  string $contractor Return paystub for this contractor ID (required)
     * @param  string $payroll Return the paystub for this payroll ID (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaystub1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAPaystub1200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPaystub1WithHttpInfo($contractor, $payroll, $accept = null, string $contentType = self::contentTypes['getAPaystub1'][0])
    {
        $request = $this->getAPaystub1Request($contractor, $payroll, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAPaystub1200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAPaystub1200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAPaystub1200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAPaystub1200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAPaystub1200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPaystub1Async
     *
     * Get a contractor payment
     *
     * @param  string $contractor Return paystub for this contractor ID (required)
     * @param  string $payroll Return the paystub for this payroll ID (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaystub1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaystub1Async($contractor, $payroll, $accept = null, string $contentType = self::contentTypes['getAPaystub1'][0])
    {
        return $this->getAPaystub1AsyncWithHttpInfo($contractor, $payroll, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPaystub1AsyncWithHttpInfo
     *
     * Get a contractor payment
     *
     * @param  string $contractor Return paystub for this contractor ID (required)
     * @param  string $payroll Return the paystub for this payroll ID (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaystub1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPaystub1AsyncWithHttpInfo($contractor, $payroll, $accept = null, string $contentType = self::contentTypes['getAPaystub1'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAPaystub1200Response';
        $request = $this->getAPaystub1Request($contractor, $payroll, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPaystub1'
     *
     * @param  string $contractor Return paystub for this contractor ID (required)
     * @param  string $payroll Return the paystub for this payroll ID (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPaystub1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAPaystub1Request($contractor, $payroll, $accept = null, string $contentType = self::contentTypes['getAPaystub1'][0])
    {

        // verify the required parameter 'contractor' is set
        if ($contractor === null || (is_array($contractor) && count($contractor) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractor when calling getAPaystub1'
            );
        }

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling getAPaystub1'
            );
        }



        $resourcePath = '/contractors/{contractor}/payments/{payroll}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($contractor !== null) {
            $resourcePath = str_replace(
                '{' . 'contractor' . '}',
                ObjectSerializer::toPathValue($contractor),
                $resourcePath
            );
        }
        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAPostTaxDeduction
     *
     * Get a post-tax deduction
     *
     * @param  string $post_tax_deduction ID of the post-tax deduction to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getAPostTaxDeduction($post_tax_deduction, string $contentType = self::contentTypes['getAPostTaxDeduction'][0])
    {
        list($response) = $this->getAPostTaxDeductionWithHttpInfo($post_tax_deduction, $contentType);
        return $response;
    }

    /**
     * Operation getAPostTaxDeductionWithHttpInfo
     *
     * Get a post-tax deduction
     *
     * @param  string $post_tax_deduction ID of the post-tax deduction to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAPostTaxDeductionWithHttpInfo($post_tax_deduction, string $contentType = self::contentTypes['getAPostTaxDeduction'][0])
    {
        $request = $this->getAPostTaxDeductionRequest($post_tax_deduction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAPostTaxDeductionAsync
     *
     * Get a post-tax deduction
     *
     * @param  string $post_tax_deduction ID of the post-tax deduction to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPostTaxDeductionAsync($post_tax_deduction, string $contentType = self::contentTypes['getAPostTaxDeduction'][0])
    {
        return $this->getAPostTaxDeductionAsyncWithHttpInfo($post_tax_deduction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAPostTaxDeductionAsyncWithHttpInfo
     *
     * Get a post-tax deduction
     *
     * @param  string $post_tax_deduction ID of the post-tax deduction to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAPostTaxDeductionAsyncWithHttpInfo($post_tax_deduction, string $contentType = self::contentTypes['getAPostTaxDeduction'][0])
    {
        $returnType = 'object';
        $request = $this->getAPostTaxDeductionRequest($post_tax_deduction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAPostTaxDeduction'
     *
     * @param  string $post_tax_deduction ID of the post-tax deduction to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAPostTaxDeductionRequest($post_tax_deduction, string $contentType = self::contentTypes['getAPostTaxDeduction'][0])
    {

        // verify the required parameter 'post_tax_deduction' is set
        if ($post_tax_deduction === null || (is_array($post_tax_deduction) && count($post_tax_deduction) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_tax_deduction when calling getAPostTaxDeduction'
            );
        }


        $resourcePath = '/post_tax_deductions/{post_tax_deduction}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($post_tax_deduction !== null) {
            $resourcePath = str_replace(
                '{' . 'post_tax_deduction' . '}',
                ObjectSerializer::toPathValue($post_tax_deduction),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getASetupDocument
     *
     * Get a Setup Document
     *
     * @param  string $document Document ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getASetupDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getASetupDocument($document, string $contentType = self::contentTypes['getASetupDocument'][0])
    {
        list($response) = $this->getASetupDocumentWithHttpInfo($document, $contentType);
        return $response;
    }

    /**
     * Operation getASetupDocumentWithHttpInfo
     *
     * Get a Setup Document
     *
     * @param  string $document Document ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getASetupDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getASetupDocumentWithHttpInfo($document, string $contentType = self::contentTypes['getASetupDocument'][0])
    {
        $request = $this->getASetupDocumentRequest($document, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getASetupDocumentAsync
     *
     * Get a Setup Document
     *
     * @param  string $document Document ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getASetupDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getASetupDocumentAsync($document, string $contentType = self::contentTypes['getASetupDocument'][0])
    {
        return $this->getASetupDocumentAsyncWithHttpInfo($document, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getASetupDocumentAsyncWithHttpInfo
     *
     * Get a Setup Document
     *
     * @param  string $document Document ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getASetupDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getASetupDocumentAsyncWithHttpInfo($document, string $contentType = self::contentTypes['getASetupDocument'][0])
    {
        $returnType = 'object';
        $request = $this->getASetupDocumentRequest($document, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getASetupDocument'
     *
     * @param  string $document Document ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getASetupDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getASetupDocumentRequest($document, string $contentType = self::contentTypes['getASetupDocument'][0])
    {

        // verify the required parameter 'document' is set
        if ($document === null || (is_array($document) && count($document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document when calling getASetupDocument'
            );
        }


        $resourcePath = '/documents/setup_documents/{document}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($document !== null) {
            $resourcePath = str_replace(
                '{' . 'document' . '}',
                ObjectSerializer::toPathValue($document),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getATaxFilingEventCopy
     *
     * Get a tax filing event
     *
     * @param  string $tax_filing_event_id ID corresponding to tax filing event object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getATaxFilingEventCopy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getATaxFilingEventCopy($tax_filing_event_id, string $contentType = self::contentTypes['getATaxFilingEventCopy'][0])
    {
        $this->getATaxFilingEventCopyWithHttpInfo($tax_filing_event_id, $contentType);
    }

    /**
     * Operation getATaxFilingEventCopyWithHttpInfo
     *
     * Get a tax filing event
     *
     * @param  string $tax_filing_event_id ID corresponding to tax filing event object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getATaxFilingEventCopy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getATaxFilingEventCopyWithHttpInfo($tax_filing_event_id, string $contentType = self::contentTypes['getATaxFilingEventCopy'][0])
    {
        $request = $this->getATaxFilingEventCopyRequest($tax_filing_event_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getATaxFilingEventCopyAsync
     *
     * Get a tax filing event
     *
     * @param  string $tax_filing_event_id ID corresponding to tax filing event object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getATaxFilingEventCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getATaxFilingEventCopyAsync($tax_filing_event_id, string $contentType = self::contentTypes['getATaxFilingEventCopy'][0])
    {
        return $this->getATaxFilingEventCopyAsyncWithHttpInfo($tax_filing_event_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getATaxFilingEventCopyAsyncWithHttpInfo
     *
     * Get a tax filing event
     *
     * @param  string $tax_filing_event_id ID corresponding to tax filing event object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getATaxFilingEventCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getATaxFilingEventCopyAsyncWithHttpInfo($tax_filing_event_id, string $contentType = self::contentTypes['getATaxFilingEventCopy'][0])
    {
        $returnType = '';
        $request = $this->getATaxFilingEventCopyRequest($tax_filing_event_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getATaxFilingEventCopy'
     *
     * @param  string $tax_filing_event_id ID corresponding to tax filing event object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getATaxFilingEventCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getATaxFilingEventCopyRequest($tax_filing_event_id, string $contentType = self::contentTypes['getATaxFilingEventCopy'][0])
    {

        // verify the required parameter 'tax_filing_event_id' is set
        if ($tax_filing_event_id === null || (is_array($tax_filing_event_id) && count($tax_filing_event_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tax_filing_event_id when calling getATaxFilingEventCopy'
            );
        }


        $resourcePath = '/tax_filing_events/{tax_filing_event_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tax_filing_event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tax_filing_event_id' . '}',
                ObjectSerializer::toPathValue($tax_filing_event_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAWebhookConfig
     *
     * Get a webhook config
     *
     * @param  string $webhook_config webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAWebhookConfig200Response
     */
    public function getAWebhookConfig($webhook_config, string $contentType = self::contentTypes['getAWebhookConfig'][0])
    {
        list($response) = $this->getAWebhookConfigWithHttpInfo($webhook_config, $contentType);
        return $response;
    }

    /**
     * Operation getAWebhookConfigWithHttpInfo
     *
     * Get a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAWebhookConfig200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAWebhookConfigWithHttpInfo($webhook_config, string $contentType = self::contentTypes['getAWebhookConfig'][0])
    {
        $request = $this->getAWebhookConfigRequest($webhook_config, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAWebhookConfig200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAWebhookConfig200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAWebhookConfig200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAWebhookConfig200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAWebhookConfig200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAWebhookConfigAsync
     *
     * Get a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAWebhookConfigAsync($webhook_config, string $contentType = self::contentTypes['getAWebhookConfig'][0])
    {
        return $this->getAWebhookConfigAsyncWithHttpInfo($webhook_config, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAWebhookConfigAsyncWithHttpInfo
     *
     * Get a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAWebhookConfigAsyncWithHttpInfo($webhook_config, string $contentType = self::contentTypes['getAWebhookConfig'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAWebhookConfig200Response';
        $request = $this->getAWebhookConfigRequest($webhook_config, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAWebhookConfig'
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAWebhookConfigRequest($webhook_config, string $contentType = self::contentTypes['getAWebhookConfig'][0])
    {

        // verify the required parameter 'webhook_config' is set
        if ($webhook_config === null || (is_array($webhook_config) && count($webhook_config) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_config when calling getAWebhookConfig'
            );
        }


        $resourcePath = '/webhook_configs/{webhook_config}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_config !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_config' . '}',
                ObjectSerializer::toPathValue($webhook_config),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAWorkplace
     *
     * Get a workplace
     *
     * @param  string $workplace workplace (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWorkplace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListWorkplaces200ResponseInner
     */
    public function getAWorkplace($workplace, string $contentType = self::contentTypes['getAWorkplace'][0])
    {
        list($response) = $this->getAWorkplaceWithHttpInfo($workplace, $contentType);
        return $response;
    }

    /**
     * Operation getAWorkplaceWithHttpInfo
     *
     * Get a workplace
     *
     * @param  string $workplace (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWorkplace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListWorkplaces200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAWorkplaceWithHttpInfo($workplace, string $contentType = self::contentTypes['getAWorkplace'][0])
    {
        $request = $this->getAWorkplaceRequest($workplace, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListWorkplaces200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListWorkplaces200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAWorkplaceAsync
     *
     * Get a workplace
     *
     * @param  string $workplace (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWorkplace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAWorkplaceAsync($workplace, string $contentType = self::contentTypes['getAWorkplace'][0])
    {
        return $this->getAWorkplaceAsyncWithHttpInfo($workplace, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAWorkplaceAsyncWithHttpInfo
     *
     * Get a workplace
     *
     * @param  string $workplace (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWorkplace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAWorkplaceAsyncWithHttpInfo($workplace, string $contentType = self::contentTypes['getAWorkplace'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner';
        $request = $this->getAWorkplaceRequest($workplace, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAWorkplace'
     *
     * @param  string $workplace (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWorkplace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAWorkplaceRequest($workplace, string $contentType = self::contentTypes['getAWorkplace'][0])
    {

        // verify the required parameter 'workplace' is set
        if ($workplace === null || (is_array($workplace) && count($workplace) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workplace when calling getAWorkplace'
            );
        }


        $resourcePath = '/workplaces/{workplace}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($workplace !== null) {
            $resourcePath = str_replace(
                '{' . 'workplace' . '}',
                ObjectSerializer::toPathValue($workplace),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAWorkplace1
     *
     * Get an earning code
     *
     * @param  string $earning_code earning_code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWorkplace1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAWorkplace1200Response|object
     */
    public function getAWorkplace1($earning_code, string $contentType = self::contentTypes['getAWorkplace1'][0])
    {
        list($response) = $this->getAWorkplace1WithHttpInfo($earning_code, $contentType);
        return $response;
    }

    /**
     * Operation getAWorkplace1WithHttpInfo
     *
     * Get an earning code
     *
     * @param  string $earning_code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWorkplace1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAWorkplace1200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAWorkplace1WithHttpInfo($earning_code, string $contentType = self::contentTypes['getAWorkplace1'][0])
    {
        $request = $this->getAWorkplace1Request($earning_code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAWorkplace1200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAWorkplace1200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAWorkplace1200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAWorkplace1200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAWorkplace1200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAWorkplace1Async
     *
     * Get an earning code
     *
     * @param  string $earning_code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWorkplace1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAWorkplace1Async($earning_code, string $contentType = self::contentTypes['getAWorkplace1'][0])
    {
        return $this->getAWorkplace1AsyncWithHttpInfo($earning_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAWorkplace1AsyncWithHttpInfo
     *
     * Get an earning code
     *
     * @param  string $earning_code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWorkplace1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAWorkplace1AsyncWithHttpInfo($earning_code, string $contentType = self::contentTypes['getAWorkplace1'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAWorkplace1200Response';
        $request = $this->getAWorkplace1Request($earning_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAWorkplace1'
     *
     * @param  string $earning_code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAWorkplace1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAWorkplace1Request($earning_code, string $contentType = self::contentTypes['getAWorkplace1'][0])
    {

        // verify the required parameter 'earning_code' is set
        if ($earning_code === null || (is_array($earning_code) && count($earning_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $earning_code when calling getAWorkplace1'
            );
        }


        $resourcePath = '/earning_codes/{earning_code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($earning_code !== null) {
            $resourcePath = str_replace(
                '{' . 'earning_code' . '}',
                ObjectSerializer::toPathValue($earning_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnEarningRate
     *
     * Get an earning rate
     *
     * @param  string $earning_rate ID for the earning rate object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEarningRate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getAnEarningRate($earning_rate, string $contentType = self::contentTypes['getAnEarningRate'][0])
    {
        list($response) = $this->getAnEarningRateWithHttpInfo($earning_rate, $contentType);
        return $response;
    }

    /**
     * Operation getAnEarningRateWithHttpInfo
     *
     * Get an earning rate
     *
     * @param  string $earning_rate ID for the earning rate object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEarningRate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnEarningRateWithHttpInfo($earning_rate, string $contentType = self::contentTypes['getAnEarningRate'][0])
    {
        $request = $this->getAnEarningRateRequest($earning_rate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnEarningRateAsync
     *
     * Get an earning rate
     *
     * @param  string $earning_rate ID for the earning rate object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEarningRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEarningRateAsync($earning_rate, string $contentType = self::contentTypes['getAnEarningRate'][0])
    {
        return $this->getAnEarningRateAsyncWithHttpInfo($earning_rate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnEarningRateAsyncWithHttpInfo
     *
     * Get an earning rate
     *
     * @param  string $earning_rate ID for the earning rate object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEarningRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEarningRateAsyncWithHttpInfo($earning_rate, string $contentType = self::contentTypes['getAnEarningRate'][0])
    {
        $returnType = 'object';
        $request = $this->getAnEarningRateRequest($earning_rate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnEarningRate'
     *
     * @param  string $earning_rate ID for the earning rate object (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEarningRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnEarningRateRequest($earning_rate, string $contentType = self::contentTypes['getAnEarningRate'][0])
    {

        // verify the required parameter 'earning_rate' is set
        if ($earning_rate === null || (is_array($earning_rate) && count($earning_rate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $earning_rate when calling getAnEarningRate'
            );
        }


        $resourcePath = '/earning_rates/{earning_rate}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($earning_rate !== null) {
            $resourcePath = str_replace(
                '{' . 'earning_rate' . '}',
                ObjectSerializer::toPathValue($earning_rate),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnEmployee
     *
     * Get an employee
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployee'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getAnEmployee($employee, string $contentType = self::contentTypes['getAnEmployee'][0])
    {
        $this->getAnEmployeeWithHttpInfo($employee, $contentType);
    }

    /**
     * Operation getAnEmployeeWithHttpInfo
     *
     * Get an employee
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployee'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnEmployeeWithHttpInfo($employee, string $contentType = self::contentTypes['getAnEmployee'][0])
    {
        $request = $this->getAnEmployeeRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getAnEmployeeAsync
     *
     * Get an employee
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployee'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEmployeeAsync($employee, string $contentType = self::contentTypes['getAnEmployee'][0])
    {
        return $this->getAnEmployeeAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnEmployeeAsyncWithHttpInfo
     *
     * Get an employee
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployee'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEmployeeAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['getAnEmployee'][0])
    {
        $returnType = '';
        $request = $this->getAnEmployeeRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnEmployee'
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployee'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnEmployeeRequest($employee, string $contentType = self::contentTypes['getAnEmployee'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling getAnEmployee'
            );
        }


        $resourcePath = '/employees/{employee}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnEmployeeBenefit
     *
     * Get a benefit
     *
     * @param  string $benefit ID of the benefit to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListBenefits200ResponseInner
     */
    public function getAnEmployeeBenefit($benefit, string $contentType = self::contentTypes['getAnEmployeeBenefit'][0])
    {
        list($response) = $this->getAnEmployeeBenefitWithHttpInfo($benefit, $contentType);
        return $response;
    }

    /**
     * Operation getAnEmployeeBenefitWithHttpInfo
     *
     * Get a benefit
     *
     * @param  string $benefit ID of the benefit to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListBenefits200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnEmployeeBenefitWithHttpInfo($benefit, string $contentType = self::contentTypes['getAnEmployeeBenefit'][0])
    {
        $request = $this->getAnEmployeeBenefitRequest($benefit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListBenefits200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListBenefits200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListBenefits200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListBenefits200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListBenefits200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnEmployeeBenefitAsync
     *
     * Get a benefit
     *
     * @param  string $benefit ID of the benefit to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEmployeeBenefitAsync($benefit, string $contentType = self::contentTypes['getAnEmployeeBenefit'][0])
    {
        return $this->getAnEmployeeBenefitAsyncWithHttpInfo($benefit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnEmployeeBenefitAsyncWithHttpInfo
     *
     * Get a benefit
     *
     * @param  string $benefit ID of the benefit to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEmployeeBenefitAsyncWithHttpInfo($benefit, string $contentType = self::contentTypes['getAnEmployeeBenefit'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListBenefits200ResponseInner';
        $request = $this->getAnEmployeeBenefitRequest($benefit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnEmployeeBenefit'
     *
     * @param  string $benefit ID of the benefit to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnEmployeeBenefitRequest($benefit, string $contentType = self::contentTypes['getAnEmployeeBenefit'][0])
    {

        // verify the required parameter 'benefit' is set
        if ($benefit === null || (is_array($benefit) && count($benefit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $benefit when calling getAnEmployeeBenefit'
            );
        }


        $resourcePath = '/benefits/{benefit}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($benefit !== null) {
            $resourcePath = str_replace(
                '{' . 'benefit' . '}',
                ObjectSerializer::toPathValue($benefit),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnEmployeeForm
     *
     * Get an employee form
     *
     * @param  string $employee Return forms associated with this employee ID (required)
     * @param  string $form The ID of the form to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getAnEmployeeForm($employee, $form, string $contentType = self::contentTypes['getAnEmployeeForm'][0])
    {
        $this->getAnEmployeeFormWithHttpInfo($employee, $form, $contentType);
    }

    /**
     * Operation getAnEmployeeFormWithHttpInfo
     *
     * Get an employee form
     *
     * @param  string $employee Return forms associated with this employee ID (required)
     * @param  string $form The ID of the form to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnEmployeeFormWithHttpInfo($employee, $form, string $contentType = self::contentTypes['getAnEmployeeForm'][0])
    {
        $request = $this->getAnEmployeeFormRequest($employee, $form, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnEmployeeFormAsync
     *
     * Get an employee form
     *
     * @param  string $employee Return forms associated with this employee ID (required)
     * @param  string $form The ID of the form to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEmployeeFormAsync($employee, $form, string $contentType = self::contentTypes['getAnEmployeeForm'][0])
    {
        return $this->getAnEmployeeFormAsyncWithHttpInfo($employee, $form, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnEmployeeFormAsyncWithHttpInfo
     *
     * Get an employee form
     *
     * @param  string $employee Return forms associated with this employee ID (required)
     * @param  string $form The ID of the form to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEmployeeFormAsyncWithHttpInfo($employee, $form, string $contentType = self::contentTypes['getAnEmployeeForm'][0])
    {
        $returnType = '';
        $request = $this->getAnEmployeeFormRequest($employee, $form, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnEmployeeForm'
     *
     * @param  string $employee Return forms associated with this employee ID (required)
     * @param  string $form The ID of the form to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnEmployeeFormRequest($employee, $form, string $contentType = self::contentTypes['getAnEmployeeForm'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling getAnEmployeeForm'
            );
        }

        // verify the required parameter 'form' is set
        if ($form === null || (is_array($form) && count($form) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $form when calling getAnEmployeeForm'
            );
        }


        $resourcePath = '/employees/{employee}/forms/{form}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }
        // path params
        if ($form !== null) {
            $resourcePath = str_replace(
                '{' . 'form' . '}',
                ObjectSerializer::toPathValue($form),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnEmployeeTaxDocument
     *
     * Get an employee tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getAnEmployeeTaxDocument(string $contentType = self::contentTypes['getAnEmployeeTaxDocument'][0])
    {
        list($response) = $this->getAnEmployeeTaxDocumentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getAnEmployeeTaxDocumentWithHttpInfo
     *
     * Get an employee tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeTaxDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnEmployeeTaxDocumentWithHttpInfo(string $contentType = self::contentTypes['getAnEmployeeTaxDocument'][0])
    {
        $request = $this->getAnEmployeeTaxDocumentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnEmployeeTaxDocumentAsync
     *
     * Get an employee tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEmployeeTaxDocumentAsync(string $contentType = self::contentTypes['getAnEmployeeTaxDocument'][0])
    {
        return $this->getAnEmployeeTaxDocumentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnEmployeeTaxDocumentAsyncWithHttpInfo
     *
     * Get an employee tax document
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEmployeeTaxDocumentAsyncWithHttpInfo(string $contentType = self::contentTypes['getAnEmployeeTaxDocument'][0])
    {
        $returnType = 'object';
        $request = $this->getAnEmployeeTaxDocumentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnEmployeeTaxDocument'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeeTaxDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnEmployeeTaxDocumentRequest(string $contentType = self::contentTypes['getAnEmployeeTaxDocument'][0])
    {


        $resourcePath = '/documents/employee_tax_documents/{document}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnEmployeesPaystubs
     *
     * List employee paystubs
     *
     * @param  string $employee Return paystubs for this employee ID (required)
     * @param  string $payroll Return the paystub for this payroll ID. (optional)
     * @param  int $limit Number of paystubs returned per page (optional)
     * @param  string $status Filters to only show paystubs for payrolls with the specified status.  If multiple &#x60;status&#x60; params are provided, paystubs with any of the statuses will be returned.  Accepted values are &#x60;pending&#x60;, &#x60;processing&#x60;, &#x60;failed&#x60;, or &#x60;paid&#x60;. (optional)
     * @param  \DateTime $start Return paystubs from payrolls with a payday on or after this date (YYYY-MM-DD) (optional)
     * @param  \DateTime $end Return paystubs from payrolls with a payday on or before this date (YYYY-MM-DD) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeesPaystubs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAnEmployeesPaystubs200Response
     */
    public function getAnEmployeesPaystubs($employee, $payroll = null, $limit = null, $status = null, $start = null, $end = null, string $contentType = self::contentTypes['getAnEmployeesPaystubs'][0])
    {
        list($response) = $this->getAnEmployeesPaystubsWithHttpInfo($employee, $payroll, $limit, $status, $start, $end, $contentType);
        return $response;
    }

    /**
     * Operation getAnEmployeesPaystubsWithHttpInfo
     *
     * List employee paystubs
     *
     * @param  string $employee Return paystubs for this employee ID (required)
     * @param  string $payroll Return the paystub for this payroll ID. (optional)
     * @param  int $limit Number of paystubs returned per page (optional)
     * @param  string $status Filters to only show paystubs for payrolls with the specified status.  If multiple &#x60;status&#x60; params are provided, paystubs with any of the statuses will be returned.  Accepted values are &#x60;pending&#x60;, &#x60;processing&#x60;, &#x60;failed&#x60;, or &#x60;paid&#x60;. (optional)
     * @param  \DateTime $start Return paystubs from payrolls with a payday on or after this date (YYYY-MM-DD) (optional)
     * @param  \DateTime $end Return paystubs from payrolls with a payday on or before this date (YYYY-MM-DD) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeesPaystubs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAnEmployeesPaystubs200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnEmployeesPaystubsWithHttpInfo($employee, $payroll = null, $limit = null, $status = null, $start = null, $end = null, string $contentType = self::contentTypes['getAnEmployeesPaystubs'][0])
    {
        $request = $this->getAnEmployeesPaystubsRequest($employee, $payroll, $limit, $status, $start, $end, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAnEmployeesPaystubs200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAnEmployeesPaystubs200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAnEmployeesPaystubs200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAnEmployeesPaystubs200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAnEmployeesPaystubs200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnEmployeesPaystubsAsync
     *
     * List employee paystubs
     *
     * @param  string $employee Return paystubs for this employee ID (required)
     * @param  string $payroll Return the paystub for this payroll ID. (optional)
     * @param  int $limit Number of paystubs returned per page (optional)
     * @param  string $status Filters to only show paystubs for payrolls with the specified status.  If multiple &#x60;status&#x60; params are provided, paystubs with any of the statuses will be returned.  Accepted values are &#x60;pending&#x60;, &#x60;processing&#x60;, &#x60;failed&#x60;, or &#x60;paid&#x60;. (optional)
     * @param  \DateTime $start Return paystubs from payrolls with a payday on or after this date (YYYY-MM-DD) (optional)
     * @param  \DateTime $end Return paystubs from payrolls with a payday on or before this date (YYYY-MM-DD) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeesPaystubs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEmployeesPaystubsAsync($employee, $payroll = null, $limit = null, $status = null, $start = null, $end = null, string $contentType = self::contentTypes['getAnEmployeesPaystubs'][0])
    {
        return $this->getAnEmployeesPaystubsAsyncWithHttpInfo($employee, $payroll, $limit, $status, $start, $end, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnEmployeesPaystubsAsyncWithHttpInfo
     *
     * List employee paystubs
     *
     * @param  string $employee Return paystubs for this employee ID (required)
     * @param  string $payroll Return the paystub for this payroll ID. (optional)
     * @param  int $limit Number of paystubs returned per page (optional)
     * @param  string $status Filters to only show paystubs for payrolls with the specified status.  If multiple &#x60;status&#x60; params are provided, paystubs with any of the statuses will be returned.  Accepted values are &#x60;pending&#x60;, &#x60;processing&#x60;, &#x60;failed&#x60;, or &#x60;paid&#x60;. (optional)
     * @param  \DateTime $start Return paystubs from payrolls with a payday on or after this date (YYYY-MM-DD) (optional)
     * @param  \DateTime $end Return paystubs from payrolls with a payday on or before this date (YYYY-MM-DD) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeesPaystubs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnEmployeesPaystubsAsyncWithHttpInfo($employee, $payroll = null, $limit = null, $status = null, $start = null, $end = null, string $contentType = self::contentTypes['getAnEmployeesPaystubs'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAnEmployeesPaystubs200Response';
        $request = $this->getAnEmployeesPaystubsRequest($employee, $payroll, $limit, $status, $start, $end, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnEmployeesPaystubs'
     *
     * @param  string $employee Return paystubs for this employee ID (required)
     * @param  string $payroll Return the paystub for this payroll ID. (optional)
     * @param  int $limit Number of paystubs returned per page (optional)
     * @param  string $status Filters to only show paystubs for payrolls with the specified status.  If multiple &#x60;status&#x60; params are provided, paystubs with any of the statuses will be returned.  Accepted values are &#x60;pending&#x60;, &#x60;processing&#x60;, &#x60;failed&#x60;, or &#x60;paid&#x60;. (optional)
     * @param  \DateTime $start Return paystubs from payrolls with a payday on or after this date (YYYY-MM-DD) (optional)
     * @param  \DateTime $end Return paystubs from payrolls with a payday on or before this date (YYYY-MM-DD) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnEmployeesPaystubs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnEmployeesPaystubsRequest($employee, $payroll = null, $limit = null, $status = null, $start = null, $end = null, string $contentType = self::contentTypes['getAnEmployeesPaystubs'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling getAnEmployeesPaystubs'
            );
        }







        $resourcePath = '/employees/{employee}/paystubs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payroll,
            'payroll', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end,
            'end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAppliedForTaxIdsReport
     *
     * Get a company&#39;s applied-for tax parameters report
     *
     * @param  string $company ID of the company with the Applied-For report to return (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAppliedForTaxIdsReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAppliedForTaxIdsReport200Response|object
     */
    public function getAppliedForTaxIdsReport($company, $accept = null, string $contentType = self::contentTypes['getAppliedForTaxIdsReport'][0])
    {
        list($response) = $this->getAppliedForTaxIdsReportWithHttpInfo($company, $accept, $contentType);
        return $response;
    }

    /**
     * Operation getAppliedForTaxIdsReportWithHttpInfo
     *
     * Get a company&#39;s applied-for tax parameters report
     *
     * @param  string $company ID of the company with the Applied-For report to return (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAppliedForTaxIdsReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAppliedForTaxIdsReport200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAppliedForTaxIdsReportWithHttpInfo($company, $accept = null, string $contentType = self::contentTypes['getAppliedForTaxIdsReport'][0])
    {
        $request = $this->getAppliedForTaxIdsReportRequest($company, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAppliedForTaxIdsReport200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAppliedForTaxIdsReport200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAppliedForTaxIdsReport200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAppliedForTaxIdsReport200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAppliedForTaxIdsReport200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAppliedForTaxIdsReportAsync
     *
     * Get a company&#39;s applied-for tax parameters report
     *
     * @param  string $company ID of the company with the Applied-For report to return (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAppliedForTaxIdsReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAppliedForTaxIdsReportAsync($company, $accept = null, string $contentType = self::contentTypes['getAppliedForTaxIdsReport'][0])
    {
        return $this->getAppliedForTaxIdsReportAsyncWithHttpInfo($company, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAppliedForTaxIdsReportAsyncWithHttpInfo
     *
     * Get a company&#39;s applied-for tax parameters report
     *
     * @param  string $company ID of the company with the Applied-For report to return (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAppliedForTaxIdsReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAppliedForTaxIdsReportAsyncWithHttpInfo($company, $accept = null, string $contentType = self::contentTypes['getAppliedForTaxIdsReport'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAppliedForTaxIdsReport200Response';
        $request = $this->getAppliedForTaxIdsReportRequest($company, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAppliedForTaxIdsReport'
     *
     * @param  string $company ID of the company with the Applied-For report to return (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAppliedForTaxIdsReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAppliedForTaxIdsReportRequest($company, $accept = null, string $contentType = self::contentTypes['getAppliedForTaxIdsReport'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getAppliedForTaxIdsReport'
            );
        }



        $resourcePath = '/companies/{company}/reports/applied_for_ids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCashRequirementReport
     *
     * Get Cash Requirement Report
     *
     * @param  string $payroll Returns cash requirement breakdown for this payroll ID (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCashRequirementReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getCashRequirementReport($payroll, $accept = null, string $contentType = self::contentTypes['getCashRequirementReport'][0])
    {
        list($response) = $this->getCashRequirementReportWithHttpInfo($payroll, $accept, $contentType);
        return $response;
    }

    /**
     * Operation getCashRequirementReportWithHttpInfo
     *
     * Get Cash Requirement Report
     *
     * @param  string $payroll Returns cash requirement breakdown for this payroll ID (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCashRequirementReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCashRequirementReportWithHttpInfo($payroll, $accept = null, string $contentType = self::contentTypes['getCashRequirementReport'][0])
    {
        $request = $this->getCashRequirementReportRequest($payroll, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCashRequirementReportAsync
     *
     * Get Cash Requirement Report
     *
     * @param  string $payroll Returns cash requirement breakdown for this payroll ID (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCashRequirementReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCashRequirementReportAsync($payroll, $accept = null, string $contentType = self::contentTypes['getCashRequirementReport'][0])
    {
        return $this->getCashRequirementReportAsyncWithHttpInfo($payroll, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCashRequirementReportAsyncWithHttpInfo
     *
     * Get Cash Requirement Report
     *
     * @param  string $payroll Returns cash requirement breakdown for this payroll ID (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCashRequirementReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCashRequirementReportAsyncWithHttpInfo($payroll, $accept = null, string $contentType = self::contentTypes['getCashRequirementReport'][0])
    {
        $returnType = 'object';
        $request = $this->getCashRequirementReportRequest($payroll, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCashRequirementReport'
     *
     * @param  string $payroll Returns cash requirement breakdown for this payroll ID (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCashRequirementReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCashRequirementReportRequest($payroll, $accept = null, string $contentType = self::contentTypes['getCashRequirementReport'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling getCashRequirementReport'
            );
        }



        $resourcePath = '/payrolls/{payroll}/reports/cash_requirement';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCompanyDefinedAttributes
     *
     * Get company-defined attributes
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyDefinedAttributes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetCompanyDefinedAttributes200Response
     */
    public function getCompanyDefinedAttributes($employee, string $contentType = self::contentTypes['getCompanyDefinedAttributes'][0])
    {
        list($response) = $this->getCompanyDefinedAttributesWithHttpInfo($employee, $contentType);
        return $response;
    }

    /**
     * Operation getCompanyDefinedAttributesWithHttpInfo
     *
     * Get company-defined attributes
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyDefinedAttributes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetCompanyDefinedAttributes200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCompanyDefinedAttributesWithHttpInfo($employee, string $contentType = self::contentTypes['getCompanyDefinedAttributes'][0])
    {
        $request = $this->getCompanyDefinedAttributesRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetCompanyDefinedAttributes200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetCompanyDefinedAttributes200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetCompanyDefinedAttributes200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetCompanyDefinedAttributes200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetCompanyDefinedAttributes200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCompanyDefinedAttributesAsync
     *
     * Get company-defined attributes
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyDefinedAttributes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCompanyDefinedAttributesAsync($employee, string $contentType = self::contentTypes['getCompanyDefinedAttributes'][0])
    {
        return $this->getCompanyDefinedAttributesAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCompanyDefinedAttributesAsyncWithHttpInfo
     *
     * Get company-defined attributes
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyDefinedAttributes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCompanyDefinedAttributesAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['getCompanyDefinedAttributes'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetCompanyDefinedAttributes200Response';
        $request = $this->getCompanyDefinedAttributesRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCompanyDefinedAttributes'
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyDefinedAttributes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCompanyDefinedAttributesRequest($employee, string $contentType = self::contentTypes['getCompanyDefinedAttributes'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling getCompanyDefinedAttributes'
            );
        }


        $resourcePath = '/employees/{employee}/company_defined_attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCompanyPaydays
     *
     * Get company paydays
     *
     * @param  string $company Return paydays for this company ID (required)
     * @param  \DateTime $start Return paydays on or after this date. If not a valid payday, the first date in the returned range will be the first valid payday after this date. If omitted, this endpoint will return items starting from today. (optional)
     * @param  string $processing_period Return paydays for payrolls with the given processing period. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyPaydays'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getCompanyPaydays($company, $start = null, $processing_period = null, string $contentType = self::contentTypes['getCompanyPaydays'][0])
    {
        $this->getCompanyPaydaysWithHttpInfo($company, $start, $processing_period, $contentType);
    }

    /**
     * Operation getCompanyPaydaysWithHttpInfo
     *
     * Get company paydays
     *
     * @param  string $company Return paydays for this company ID (required)
     * @param  \DateTime $start Return paydays on or after this date. If not a valid payday, the first date in the returned range will be the first valid payday after this date. If omitted, this endpoint will return items starting from today. (optional)
     * @param  string $processing_period Return paydays for payrolls with the given processing period. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyPaydays'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCompanyPaydaysWithHttpInfo($company, $start = null, $processing_period = null, string $contentType = self::contentTypes['getCompanyPaydays'][0])
    {
        $request = $this->getCompanyPaydaysRequest($company, $start, $processing_period, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCompanyPaydaysAsync
     *
     * Get company paydays
     *
     * @param  string $company Return paydays for this company ID (required)
     * @param  \DateTime $start Return paydays on or after this date. If not a valid payday, the first date in the returned range will be the first valid payday after this date. If omitted, this endpoint will return items starting from today. (optional)
     * @param  string $processing_period Return paydays for payrolls with the given processing period. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyPaydays'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCompanyPaydaysAsync($company, $start = null, $processing_period = null, string $contentType = self::contentTypes['getCompanyPaydays'][0])
    {
        return $this->getCompanyPaydaysAsyncWithHttpInfo($company, $start, $processing_period, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCompanyPaydaysAsyncWithHttpInfo
     *
     * Get company paydays
     *
     * @param  string $company Return paydays for this company ID (required)
     * @param  \DateTime $start Return paydays on or after this date. If not a valid payday, the first date in the returned range will be the first valid payday after this date. If omitted, this endpoint will return items starting from today. (optional)
     * @param  string $processing_period Return paydays for payrolls with the given processing period. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyPaydays'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCompanyPaydaysAsyncWithHttpInfo($company, $start = null, $processing_period = null, string $contentType = self::contentTypes['getCompanyPaydays'][0])
    {
        $returnType = '';
        $request = $this->getCompanyPaydaysRequest($company, $start, $processing_period, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCompanyPaydays'
     *
     * @param  string $company Return paydays for this company ID (required)
     * @param  \DateTime $start Return paydays on or after this date. If not a valid payday, the first date in the returned range will be the first valid payday after this date. If omitted, this endpoint will return items starting from today. (optional)
     * @param  string $processing_period Return paydays for payrolls with the given processing period. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyPaydays'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCompanyPaydaysRequest($company, $start = null, $processing_period = null, string $contentType = self::contentTypes['getCompanyPaydays'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getCompanyPaydays'
            );
        }




        $resourcePath = '/companies/{company}/paydays';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $processing_period,
            'processing_period', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCompanyTaxParameterSetting
     *
     * Get a specific company&#39;s tax parameter setting
     *
     * @param  string $company_id ID of the company used to get the applicable tax parameter details. (required)
     * @param  string $tax_param_id ID of the tax parameter used to detail the values. (required)
     * @param  \DateTime $as_of Used to show the tax parameter effective dated details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyTaxParameterSetting'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getCompanyTaxParameterSetting($company_id, $tax_param_id, $as_of = null, string $contentType = self::contentTypes['getCompanyTaxParameterSetting'][0])
    {
        $this->getCompanyTaxParameterSettingWithHttpInfo($company_id, $tax_param_id, $as_of, $contentType);
    }

    /**
     * Operation getCompanyTaxParameterSettingWithHttpInfo
     *
     * Get a specific company&#39;s tax parameter setting
     *
     * @param  string $company_id ID of the company used to get the applicable tax parameter details. (required)
     * @param  string $tax_param_id ID of the tax parameter used to detail the values. (required)
     * @param  \DateTime $as_of Used to show the tax parameter effective dated details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyTaxParameterSetting'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCompanyTaxParameterSettingWithHttpInfo($company_id, $tax_param_id, $as_of = null, string $contentType = self::contentTypes['getCompanyTaxParameterSetting'][0])
    {
        $request = $this->getCompanyTaxParameterSettingRequest($company_id, $tax_param_id, $as_of, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCompanyTaxParameterSettingAsync
     *
     * Get a specific company&#39;s tax parameter setting
     *
     * @param  string $company_id ID of the company used to get the applicable tax parameter details. (required)
     * @param  string $tax_param_id ID of the tax parameter used to detail the values. (required)
     * @param  \DateTime $as_of Used to show the tax parameter effective dated details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyTaxParameterSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCompanyTaxParameterSettingAsync($company_id, $tax_param_id, $as_of = null, string $contentType = self::contentTypes['getCompanyTaxParameterSetting'][0])
    {
        return $this->getCompanyTaxParameterSettingAsyncWithHttpInfo($company_id, $tax_param_id, $as_of, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCompanyTaxParameterSettingAsyncWithHttpInfo
     *
     * Get a specific company&#39;s tax parameter setting
     *
     * @param  string $company_id ID of the company used to get the applicable tax parameter details. (required)
     * @param  string $tax_param_id ID of the tax parameter used to detail the values. (required)
     * @param  \DateTime $as_of Used to show the tax parameter effective dated details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyTaxParameterSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCompanyTaxParameterSettingAsyncWithHttpInfo($company_id, $tax_param_id, $as_of = null, string $contentType = self::contentTypes['getCompanyTaxParameterSetting'][0])
    {
        $returnType = '';
        $request = $this->getCompanyTaxParameterSettingRequest($company_id, $tax_param_id, $as_of, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCompanyTaxParameterSetting'
     *
     * @param  string $company_id ID of the company used to get the applicable tax parameter details. (required)
     * @param  string $tax_param_id ID of the tax parameter used to detail the values. (required)
     * @param  \DateTime $as_of Used to show the tax parameter effective dated details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCompanyTaxParameterSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCompanyTaxParameterSettingRequest($company_id, $tax_param_id, $as_of = null, string $contentType = self::contentTypes['getCompanyTaxParameterSetting'][0])
    {

        // verify the required parameter 'company_id' is set
        if ($company_id === null || (is_array($company_id) && count($company_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company_id when calling getCompanyTaxParameterSetting'
            );
        }

        // verify the required parameter 'tax_param_id' is set
        if ($tax_param_id === null || (is_array($tax_param_id) && count($tax_param_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tax_param_id when calling getCompanyTaxParameterSetting'
            );
        }



        $resourcePath = '/company_tax_params/{company_id}/settings/{tax_param_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_of,
            'as_of', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($company_id !== null) {
            $resourcePath = str_replace(
                '{' . 'company_id' . '}',
                ObjectSerializer::toPathValue($company_id),
                $resourcePath
            );
        }
        // path params
        if ($tax_param_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tax_param_id' . '}',
                ObjectSerializer::toPathValue($tax_param_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContractorPaymentsReport
     *
     * Get contractor payments report
     *
     * @param  string $company ID of the company with the contractor report to return (required)
     * @param  \DateTime $start Filter on payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Filter on payrolls with a payday before or on this date. (optional)
     * @param  string $payroll Filter on payroll(s) with this ID. To specify multiple payrolls, repeat this query parameter. (For example: \&quot;&amp;payroll&#x3D;pay_123&amp;payroll&#x3D;pay_456&amp;...\&quot;) (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  bool $preview Include to show the report for contractor payments on draft payrolls (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContractorPaymentsReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getContractorPaymentsReport($company, $start = null, $end = null, $payroll = null, $accept = null, $preview = null, string $contentType = self::contentTypes['getContractorPaymentsReport'][0])
    {
        $this->getContractorPaymentsReportWithHttpInfo($company, $start, $end, $payroll, $accept, $preview, $contentType);
    }

    /**
     * Operation getContractorPaymentsReportWithHttpInfo
     *
     * Get contractor payments report
     *
     * @param  string $company ID of the company with the contractor report to return (required)
     * @param  \DateTime $start Filter on payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Filter on payrolls with a payday before or on this date. (optional)
     * @param  string $payroll Filter on payroll(s) with this ID. To specify multiple payrolls, repeat this query parameter. (For example: \&quot;&amp;payroll&#x3D;pay_123&amp;payroll&#x3D;pay_456&amp;...\&quot;) (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  bool $preview Include to show the report for contractor payments on draft payrolls (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContractorPaymentsReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContractorPaymentsReportWithHttpInfo($company, $start = null, $end = null, $payroll = null, $accept = null, $preview = null, string $contentType = self::contentTypes['getContractorPaymentsReport'][0])
    {
        $request = $this->getContractorPaymentsReportRequest($company, $start, $end, $payroll, $accept, $preview, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getContractorPaymentsReportAsync
     *
     * Get contractor payments report
     *
     * @param  string $company ID of the company with the contractor report to return (required)
     * @param  \DateTime $start Filter on payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Filter on payrolls with a payday before or on this date. (optional)
     * @param  string $payroll Filter on payroll(s) with this ID. To specify multiple payrolls, repeat this query parameter. (For example: \&quot;&amp;payroll&#x3D;pay_123&amp;payroll&#x3D;pay_456&amp;...\&quot;) (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  bool $preview Include to show the report for contractor payments on draft payrolls (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContractorPaymentsReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContractorPaymentsReportAsync($company, $start = null, $end = null, $payroll = null, $accept = null, $preview = null, string $contentType = self::contentTypes['getContractorPaymentsReport'][0])
    {
        return $this->getContractorPaymentsReportAsyncWithHttpInfo($company, $start, $end, $payroll, $accept, $preview, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContractorPaymentsReportAsyncWithHttpInfo
     *
     * Get contractor payments report
     *
     * @param  string $company ID of the company with the contractor report to return (required)
     * @param  \DateTime $start Filter on payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Filter on payrolls with a payday before or on this date. (optional)
     * @param  string $payroll Filter on payroll(s) with this ID. To specify multiple payrolls, repeat this query parameter. (For example: \&quot;&amp;payroll&#x3D;pay_123&amp;payroll&#x3D;pay_456&amp;...\&quot;) (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  bool $preview Include to show the report for contractor payments on draft payrolls (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContractorPaymentsReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContractorPaymentsReportAsyncWithHttpInfo($company, $start = null, $end = null, $payroll = null, $accept = null, $preview = null, string $contentType = self::contentTypes['getContractorPaymentsReport'][0])
    {
        $returnType = '';
        $request = $this->getContractorPaymentsReportRequest($company, $start, $end, $payroll, $accept, $preview, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContractorPaymentsReport'
     *
     * @param  string $company ID of the company with the contractor report to return (required)
     * @param  \DateTime $start Filter on payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Filter on payrolls with a payday before or on this date. (optional)
     * @param  string $payroll Filter on payroll(s) with this ID. To specify multiple payrolls, repeat this query parameter. (For example: \&quot;&amp;payroll&#x3D;pay_123&amp;payroll&#x3D;pay_456&amp;...\&quot;) (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  bool $preview Include to show the report for contractor payments on draft payrolls (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContractorPaymentsReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContractorPaymentsReportRequest($company, $start = null, $end = null, $payroll = null, $accept = null, $preview = null, string $contentType = self::contentTypes['getContractorPaymentsReport'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getContractorPaymentsReport'
            );
        }







        $resourcePath = '/companies/{company}/reports/contractor_payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end,
            'end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payroll,
            'payroll', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $preview,
            'preview', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmployeeTaxParameterSetting
     *
     * Get a specific employee&#39;s tax parameter setting
     *
     * @param  string $employee_id ID of the employee used to get the applicable tax parameter details. (required)
     * @param  string $tax_param_id ID of the tax parameter used to detail the values. (required)
     * @param  \DateTime $as_of Used to show the tax parameter’s effective dated details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmployeeTaxParameterSetting'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetEmployeeTaxParameterSetting200Response|object
     */
    public function getEmployeeTaxParameterSetting($employee_id, $tax_param_id, $as_of = null, string $contentType = self::contentTypes['getEmployeeTaxParameterSetting'][0])
    {
        list($response) = $this->getEmployeeTaxParameterSettingWithHttpInfo($employee_id, $tax_param_id, $as_of, $contentType);
        return $response;
    }

    /**
     * Operation getEmployeeTaxParameterSettingWithHttpInfo
     *
     * Get a specific employee&#39;s tax parameter setting
     *
     * @param  string $employee_id ID of the employee used to get the applicable tax parameter details. (required)
     * @param  string $tax_param_id ID of the tax parameter used to detail the values. (required)
     * @param  \DateTime $as_of Used to show the tax parameter’s effective dated details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmployeeTaxParameterSetting'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetEmployeeTaxParameterSetting200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmployeeTaxParameterSettingWithHttpInfo($employee_id, $tax_param_id, $as_of = null, string $contentType = self::contentTypes['getEmployeeTaxParameterSetting'][0])
    {
        $request = $this->getEmployeeTaxParameterSettingRequest($employee_id, $tax_param_id, $as_of, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetEmployeeTaxParameterSetting200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetEmployeeTaxParameterSetting200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetEmployeeTaxParameterSetting200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetEmployeeTaxParameterSetting200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetEmployeeTaxParameterSetting200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmployeeTaxParameterSettingAsync
     *
     * Get a specific employee&#39;s tax parameter setting
     *
     * @param  string $employee_id ID of the employee used to get the applicable tax parameter details. (required)
     * @param  string $tax_param_id ID of the tax parameter used to detail the values. (required)
     * @param  \DateTime $as_of Used to show the tax parameter’s effective dated details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmployeeTaxParameterSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmployeeTaxParameterSettingAsync($employee_id, $tax_param_id, $as_of = null, string $contentType = self::contentTypes['getEmployeeTaxParameterSetting'][0])
    {
        return $this->getEmployeeTaxParameterSettingAsyncWithHttpInfo($employee_id, $tax_param_id, $as_of, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmployeeTaxParameterSettingAsyncWithHttpInfo
     *
     * Get a specific employee&#39;s tax parameter setting
     *
     * @param  string $employee_id ID of the employee used to get the applicable tax parameter details. (required)
     * @param  string $tax_param_id ID of the tax parameter used to detail the values. (required)
     * @param  \DateTime $as_of Used to show the tax parameter’s effective dated details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmployeeTaxParameterSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmployeeTaxParameterSettingAsyncWithHttpInfo($employee_id, $tax_param_id, $as_of = null, string $contentType = self::contentTypes['getEmployeeTaxParameterSetting'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetEmployeeTaxParameterSetting200Response';
        $request = $this->getEmployeeTaxParameterSettingRequest($employee_id, $tax_param_id, $as_of, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmployeeTaxParameterSetting'
     *
     * @param  string $employee_id ID of the employee used to get the applicable tax parameter details. (required)
     * @param  string $tax_param_id ID of the tax parameter used to detail the values. (required)
     * @param  \DateTime $as_of Used to show the tax parameter’s effective dated details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmployeeTaxParameterSetting'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEmployeeTaxParameterSettingRequest($employee_id, $tax_param_id, $as_of = null, string $contentType = self::contentTypes['getEmployeeTaxParameterSetting'][0])
    {

        // verify the required parameter 'employee_id' is set
        if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee_id when calling getEmployeeTaxParameterSetting'
            );
        }

        // verify the required parameter 'tax_param_id' is set
        if ($tax_param_id === null || (is_array($tax_param_id) && count($tax_param_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tax_param_id when calling getEmployeeTaxParameterSetting'
            );
        }



        $resourcePath = '/employee_tax_params/{employee_id}/settings/{tax_param_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_of,
            'as_of', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($employee_id !== null) {
            $resourcePath = str_replace(
                '{' . 'employee_id' . '}',
                ObjectSerializer::toPathValue($employee_id),
                $resourcePath
            );
        }
        // path params
        if ($tax_param_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tax_param_id' . '}',
                ObjectSerializer::toPathValue($tax_param_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaperChecks
     *
     * Get paper checks
     *
     * @param  string $payroll payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaperChecks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAPaperCheck202Response|object
     */
    public function getPaperChecks($payroll, string $contentType = self::contentTypes['getPaperChecks'][0])
    {
        list($response) = $this->getPaperChecksWithHttpInfo($payroll, $contentType);
        return $response;
    }

    /**
     * Operation getPaperChecksWithHttpInfo
     *
     * Get paper checks
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaperChecks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAPaperCheck202Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaperChecksWithHttpInfo($payroll, string $contentType = self::contentTypes['getPaperChecks'][0])
    {
        $request = $this->getPaperChecksRequest($payroll, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\OpenAPI\Client\Model\GetAPaperCheck202Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAPaperCheck202Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAPaperCheck202Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAPaperCheck202Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAPaperCheck202Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaperChecksAsync
     *
     * Get paper checks
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaperChecks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaperChecksAsync($payroll, string $contentType = self::contentTypes['getPaperChecks'][0])
    {
        return $this->getPaperChecksAsyncWithHttpInfo($payroll, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaperChecksAsyncWithHttpInfo
     *
     * Get paper checks
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaperChecks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaperChecksAsyncWithHttpInfo($payroll, string $contentType = self::contentTypes['getPaperChecks'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAPaperCheck202Response';
        $request = $this->getPaperChecksRequest($payroll, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaperChecks'
     *
     * @param  string $payroll (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaperChecks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPaperChecksRequest($payroll, string $contentType = self::contentTypes['getPaperChecks'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling getPaperChecks'
            );
        }


        $resourcePath = '/payrolls/{payroll}/paper_checks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaperChecksReport
     *
     * Get Paper Checks Report
     *
     * @param  string $payroll Returns paper checks report for this payroll ID (required)
     * @param  string $accept Either application/json or text/csv (optional)
     * @param  string $representation &#x60;default&#x60; or &#x60;checkeeper&#x60;. If &#x60;checkeeper&#x60; is selected, report entries will be formatted to be compatible with Checkeeper&#39;s paper checks import flow. (optional, default to 'default')
     * @param  string $address_type &#x60;payee&#x60; or &#x60;company&#x60;. If &#x60;payee&#x60; is selected, the address for each entry is set to the individual payee&#39;s mailing address, as recorded in Check. If set to &#x60;company&#x60;, all entries will have the mailing address set to the company&#39;s address. (optional, default to 'payee')
     * @param  mixed $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaperChecksReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetPaperChecksReport200Response
     */
    public function getPaperChecksReport($payroll, $accept = null, $representation = 'default', $address_type = 'payee', $body = null, string $contentType = self::contentTypes['getPaperChecksReport'][0])
    {
        list($response) = $this->getPaperChecksReportWithHttpInfo($payroll, $accept, $representation, $address_type, $body, $contentType);
        return $response;
    }

    /**
     * Operation getPaperChecksReportWithHttpInfo
     *
     * Get Paper Checks Report
     *
     * @param  string $payroll Returns paper checks report for this payroll ID (required)
     * @param  string $accept Either application/json or text/csv (optional)
     * @param  string $representation &#x60;default&#x60; or &#x60;checkeeper&#x60;. If &#x60;checkeeper&#x60; is selected, report entries will be formatted to be compatible with Checkeeper&#39;s paper checks import flow. (optional, default to 'default')
     * @param  string $address_type &#x60;payee&#x60; or &#x60;company&#x60;. If &#x60;payee&#x60; is selected, the address for each entry is set to the individual payee&#39;s mailing address, as recorded in Check. If set to &#x60;company&#x60;, all entries will have the mailing address set to the company&#39;s address. (optional, default to 'payee')
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaperChecksReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetPaperChecksReport200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaperChecksReportWithHttpInfo($payroll, $accept = null, $representation = 'default', $address_type = 'payee', $body = null, string $contentType = self::contentTypes['getPaperChecksReport'][0])
    {
        $request = $this->getPaperChecksReportRequest($payroll, $accept, $representation, $address_type, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetPaperChecksReport200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetPaperChecksReport200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetPaperChecksReport200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetPaperChecksReport200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetPaperChecksReport200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaperChecksReportAsync
     *
     * Get Paper Checks Report
     *
     * @param  string $payroll Returns paper checks report for this payroll ID (required)
     * @param  string $accept Either application/json or text/csv (optional)
     * @param  string $representation &#x60;default&#x60; or &#x60;checkeeper&#x60;. If &#x60;checkeeper&#x60; is selected, report entries will be formatted to be compatible with Checkeeper&#39;s paper checks import flow. (optional, default to 'default')
     * @param  string $address_type &#x60;payee&#x60; or &#x60;company&#x60;. If &#x60;payee&#x60; is selected, the address for each entry is set to the individual payee&#39;s mailing address, as recorded in Check. If set to &#x60;company&#x60;, all entries will have the mailing address set to the company&#39;s address. (optional, default to 'payee')
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaperChecksReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaperChecksReportAsync($payroll, $accept = null, $representation = 'default', $address_type = 'payee', $body = null, string $contentType = self::contentTypes['getPaperChecksReport'][0])
    {
        return $this->getPaperChecksReportAsyncWithHttpInfo($payroll, $accept, $representation, $address_type, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaperChecksReportAsyncWithHttpInfo
     *
     * Get Paper Checks Report
     *
     * @param  string $payroll Returns paper checks report for this payroll ID (required)
     * @param  string $accept Either application/json or text/csv (optional)
     * @param  string $representation &#x60;default&#x60; or &#x60;checkeeper&#x60;. If &#x60;checkeeper&#x60; is selected, report entries will be formatted to be compatible with Checkeeper&#39;s paper checks import flow. (optional, default to 'default')
     * @param  string $address_type &#x60;payee&#x60; or &#x60;company&#x60;. If &#x60;payee&#x60; is selected, the address for each entry is set to the individual payee&#39;s mailing address, as recorded in Check. If set to &#x60;company&#x60;, all entries will have the mailing address set to the company&#39;s address. (optional, default to 'payee')
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaperChecksReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaperChecksReportAsyncWithHttpInfo($payroll, $accept = null, $representation = 'default', $address_type = 'payee', $body = null, string $contentType = self::contentTypes['getPaperChecksReport'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetPaperChecksReport200Response';
        $request = $this->getPaperChecksReportRequest($payroll, $accept, $representation, $address_type, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaperChecksReport'
     *
     * @param  string $payroll Returns paper checks report for this payroll ID (required)
     * @param  string $accept Either application/json or text/csv (optional)
     * @param  string $representation &#x60;default&#x60; or &#x60;checkeeper&#x60;. If &#x60;checkeeper&#x60; is selected, report entries will be formatted to be compatible with Checkeeper&#39;s paper checks import flow. (optional, default to 'default')
     * @param  string $address_type &#x60;payee&#x60; or &#x60;company&#x60;. If &#x60;payee&#x60; is selected, the address for each entry is set to the individual payee&#39;s mailing address, as recorded in Check. If set to &#x60;company&#x60;, all entries will have the mailing address set to the company&#39;s address. (optional, default to 'payee')
     * @param  mixed $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaperChecksReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPaperChecksReportRequest($payroll, $accept = null, $representation = 'default', $address_type = 'payee', $body = null, string $contentType = self::contentTypes['getPaperChecksReport'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling getPaperChecksReport'
            );
        }






        $resourcePath = '/payrolls/{payroll}/reports/paper_checks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $representation,
            'representation', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_type,
            'address_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaydays
     *
     * Get paydays
     *
     * @param  string $pay_schedule pay_schedule (required)
     * @param  \DateTime $start Return paydays on or after this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaydays'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetPaydays200ResponseInner[]|object
     */
    public function getPaydays($pay_schedule, $start = null, string $contentType = self::contentTypes['getPaydays'][0])
    {
        list($response) = $this->getPaydaysWithHttpInfo($pay_schedule, $start, $contentType);
        return $response;
    }

    /**
     * Operation getPaydaysWithHttpInfo
     *
     * Get paydays
     *
     * @param  string $pay_schedule (required)
     * @param  \DateTime $start Return paydays on or after this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaydays'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetPaydays200ResponseInner[]|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaydaysWithHttpInfo($pay_schedule, $start = null, string $contentType = self::contentTypes['getPaydays'][0])
    {
        $request = $this->getPaydaysRequest($pay_schedule, $start, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetPaydays200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetPaydays200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetPaydays200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetPaydays200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetPaydays200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaydaysAsync
     *
     * Get paydays
     *
     * @param  string $pay_schedule (required)
     * @param  \DateTime $start Return paydays on or after this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaydays'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaydaysAsync($pay_schedule, $start = null, string $contentType = self::contentTypes['getPaydays'][0])
    {
        return $this->getPaydaysAsyncWithHttpInfo($pay_schedule, $start, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaydaysAsyncWithHttpInfo
     *
     * Get paydays
     *
     * @param  string $pay_schedule (required)
     * @param  \DateTime $start Return paydays on or after this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaydays'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaydaysAsyncWithHttpInfo($pay_schedule, $start = null, string $contentType = self::contentTypes['getPaydays'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetPaydays200ResponseInner[]';
        $request = $this->getPaydaysRequest($pay_schedule, $start, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaydays'
     *
     * @param  string $pay_schedule (required)
     * @param  \DateTime $start Return paydays on or after this date. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaydays'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPaydaysRequest($pay_schedule, $start = null, string $contentType = self::contentTypes['getPaydays'][0])
    {

        // verify the required parameter 'pay_schedule' is set
        if ($pay_schedule === null || (is_array($pay_schedule) && count($pay_schedule) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pay_schedule when calling getPaydays'
            );
        }



        $resourcePath = '/pay_schedules/{pay_schedule}/paydays';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($pay_schedule !== null) {
            $resourcePath = str_replace(
                '{' . 'pay_schedule' . '}',
                ObjectSerializer::toPathValue($pay_schedule),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPayroll
     *
     * Get a payroll
     *
     * @param  string $payroll ID of the payroll to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetPayroll200Response
     */
    public function getPayroll($payroll, string $contentType = self::contentTypes['getPayroll'][0])
    {
        list($response) = $this->getPayrollWithHttpInfo($payroll, $contentType);
        return $response;
    }

    /**
     * Operation getPayrollWithHttpInfo
     *
     * Get a payroll
     *
     * @param  string $payroll ID of the payroll to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetPayroll200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPayrollWithHttpInfo($payroll, string $contentType = self::contentTypes['getPayroll'][0])
    {
        $request = $this->getPayrollRequest($payroll, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetPayroll200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetPayroll200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetPayroll200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetPayroll200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetPayroll200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPayrollAsync
     *
     * Get a payroll
     *
     * @param  string $payroll ID of the payroll to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPayrollAsync($payroll, string $contentType = self::contentTypes['getPayroll'][0])
    {
        return $this->getPayrollAsyncWithHttpInfo($payroll, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPayrollAsyncWithHttpInfo
     *
     * Get a payroll
     *
     * @param  string $payroll ID of the payroll to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPayrollAsyncWithHttpInfo($payroll, string $contentType = self::contentTypes['getPayroll'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetPayroll200Response';
        $request = $this->getPayrollRequest($payroll, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPayroll'
     *
     * @param  string $payroll ID of the payroll to return. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPayrollRequest($payroll, string $contentType = self::contentTypes['getPayroll'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling getPayroll'
            );
        }


        $resourcePath = '/payrolls/{payroll}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPayrollJournal
     *
     * Get payroll journal
     *
     * @param  string $company ID of the company with the payroll journal to return (required)
     * @param  \DateTime $start Return payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $payroll Return the payroll with this ID. To specify multiple payrolls, repeat this query parameter. (For example: \&quot;&amp;payroll&#x3D;pay_123&amp;payroll&#x3D;pay_456&amp;...\&quot;) (optional)
     * @param  bool $include_taxable_wages Return payrolls with taxable wages. (optional, default to false)
     * @param  bool $include_employee_id Return employees with their ID. (optional, default to false)
     * @param  bool $include_contractors Return payments made to contractors on payrolls (optional, default to false)
     * @param  string $group_by Determines how to breakdown pay. If &#x60;workplace&#x60; is provided, employees will have one line item per payroll and workplace combination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayrollJournal'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getPayrollJournal($company, $start = null, $end = null, $accept = null, $payroll = null, $include_taxable_wages = false, $include_employee_id = false, $include_contractors = false, $group_by = null, string $contentType = self::contentTypes['getPayrollJournal'][0])
    {
        list($response) = $this->getPayrollJournalWithHttpInfo($company, $start, $end, $accept, $payroll, $include_taxable_wages, $include_employee_id, $include_contractors, $group_by, $contentType);
        return $response;
    }

    /**
     * Operation getPayrollJournalWithHttpInfo
     *
     * Get payroll journal
     *
     * @param  string $company ID of the company with the payroll journal to return (required)
     * @param  \DateTime $start Return payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $payroll Return the payroll with this ID. To specify multiple payrolls, repeat this query parameter. (For example: \&quot;&amp;payroll&#x3D;pay_123&amp;payroll&#x3D;pay_456&amp;...\&quot;) (optional)
     * @param  bool $include_taxable_wages Return payrolls with taxable wages. (optional, default to false)
     * @param  bool $include_employee_id Return employees with their ID. (optional, default to false)
     * @param  bool $include_contractors Return payments made to contractors on payrolls (optional, default to false)
     * @param  string $group_by Determines how to breakdown pay. If &#x60;workplace&#x60; is provided, employees will have one line item per payroll and workplace combination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayrollJournal'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPayrollJournalWithHttpInfo($company, $start = null, $end = null, $accept = null, $payroll = null, $include_taxable_wages = false, $include_employee_id = false, $include_contractors = false, $group_by = null, string $contentType = self::contentTypes['getPayrollJournal'][0])
    {
        $request = $this->getPayrollJournalRequest($company, $start, $end, $accept, $payroll, $include_taxable_wages, $include_employee_id, $include_contractors, $group_by, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPayrollJournalAsync
     *
     * Get payroll journal
     *
     * @param  string $company ID of the company with the payroll journal to return (required)
     * @param  \DateTime $start Return payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $payroll Return the payroll with this ID. To specify multiple payrolls, repeat this query parameter. (For example: \&quot;&amp;payroll&#x3D;pay_123&amp;payroll&#x3D;pay_456&amp;...\&quot;) (optional)
     * @param  bool $include_taxable_wages Return payrolls with taxable wages. (optional, default to false)
     * @param  bool $include_employee_id Return employees with their ID. (optional, default to false)
     * @param  bool $include_contractors Return payments made to contractors on payrolls (optional, default to false)
     * @param  string $group_by Determines how to breakdown pay. If &#x60;workplace&#x60; is provided, employees will have one line item per payroll and workplace combination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayrollJournal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPayrollJournalAsync($company, $start = null, $end = null, $accept = null, $payroll = null, $include_taxable_wages = false, $include_employee_id = false, $include_contractors = false, $group_by = null, string $contentType = self::contentTypes['getPayrollJournal'][0])
    {
        return $this->getPayrollJournalAsyncWithHttpInfo($company, $start, $end, $accept, $payroll, $include_taxable_wages, $include_employee_id, $include_contractors, $group_by, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPayrollJournalAsyncWithHttpInfo
     *
     * Get payroll journal
     *
     * @param  string $company ID of the company with the payroll journal to return (required)
     * @param  \DateTime $start Return payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $payroll Return the payroll with this ID. To specify multiple payrolls, repeat this query parameter. (For example: \&quot;&amp;payroll&#x3D;pay_123&amp;payroll&#x3D;pay_456&amp;...\&quot;) (optional)
     * @param  bool $include_taxable_wages Return payrolls with taxable wages. (optional, default to false)
     * @param  bool $include_employee_id Return employees with their ID. (optional, default to false)
     * @param  bool $include_contractors Return payments made to contractors on payrolls (optional, default to false)
     * @param  string $group_by Determines how to breakdown pay. If &#x60;workplace&#x60; is provided, employees will have one line item per payroll and workplace combination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayrollJournal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPayrollJournalAsyncWithHttpInfo($company, $start = null, $end = null, $accept = null, $payroll = null, $include_taxable_wages = false, $include_employee_id = false, $include_contractors = false, $group_by = null, string $contentType = self::contentTypes['getPayrollJournal'][0])
    {
        $returnType = 'object';
        $request = $this->getPayrollJournalRequest($company, $start, $end, $accept, $payroll, $include_taxable_wages, $include_employee_id, $include_contractors, $group_by, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPayrollJournal'
     *
     * @param  string $company ID of the company with the payroll journal to return (required)
     * @param  \DateTime $start Return payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $payroll Return the payroll with this ID. To specify multiple payrolls, repeat this query parameter. (For example: \&quot;&amp;payroll&#x3D;pay_123&amp;payroll&#x3D;pay_456&amp;...\&quot;) (optional)
     * @param  bool $include_taxable_wages Return payrolls with taxable wages. (optional, default to false)
     * @param  bool $include_employee_id Return employees with their ID. (optional, default to false)
     * @param  bool $include_contractors Return payments made to contractors on payrolls (optional, default to false)
     * @param  string $group_by Determines how to breakdown pay. If &#x60;workplace&#x60; is provided, employees will have one line item per payroll and workplace combination. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayrollJournal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPayrollJournalRequest($company, $start = null, $end = null, $accept = null, $payroll = null, $include_taxable_wages = false, $include_employee_id = false, $include_contractors = false, $group_by = null, string $contentType = self::contentTypes['getPayrollJournal'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getPayrollJournal'
            );
        }










        $resourcePath = '/companies/{company}/reports/payroll_journal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end,
            'end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payroll,
            'payroll', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_taxable_wages,
            'include_taxable_wages', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_employee_id,
            'include_employee_id', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_contractors,
            'include_contractors', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_by,
            'group_by', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPayrollSummary
     *
     * Get payroll summary
     *
     * @param  string $company Return payroll summaries for this company ID (required)
     * @param  \DateTime $start Return payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  bool $include_employee_id Return employees with their ID. (optional, default to false)
     * @param  bool $include_contractors Return payments made to contractors on payrolls (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayrollSummary'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getPayrollSummary($company, $start = null, $end = null, $accept = null, $include_employee_id = false, $include_contractors = false, string $contentType = self::contentTypes['getPayrollSummary'][0])
    {
        list($response) = $this->getPayrollSummaryWithHttpInfo($company, $start, $end, $accept, $include_employee_id, $include_contractors, $contentType);
        return $response;
    }

    /**
     * Operation getPayrollSummaryWithHttpInfo
     *
     * Get payroll summary
     *
     * @param  string $company Return payroll summaries for this company ID (required)
     * @param  \DateTime $start Return payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  bool $include_employee_id Return employees with their ID. (optional, default to false)
     * @param  bool $include_contractors Return payments made to contractors on payrolls (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayrollSummary'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPayrollSummaryWithHttpInfo($company, $start = null, $end = null, $accept = null, $include_employee_id = false, $include_contractors = false, string $contentType = self::contentTypes['getPayrollSummary'][0])
    {
        $request = $this->getPayrollSummaryRequest($company, $start, $end, $accept, $include_employee_id, $include_contractors, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPayrollSummaryAsync
     *
     * Get payroll summary
     *
     * @param  string $company Return payroll summaries for this company ID (required)
     * @param  \DateTime $start Return payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  bool $include_employee_id Return employees with their ID. (optional, default to false)
     * @param  bool $include_contractors Return payments made to contractors on payrolls (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayrollSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPayrollSummaryAsync($company, $start = null, $end = null, $accept = null, $include_employee_id = false, $include_contractors = false, string $contentType = self::contentTypes['getPayrollSummary'][0])
    {
        return $this->getPayrollSummaryAsyncWithHttpInfo($company, $start, $end, $accept, $include_employee_id, $include_contractors, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPayrollSummaryAsyncWithHttpInfo
     *
     * Get payroll summary
     *
     * @param  string $company Return payroll summaries for this company ID (required)
     * @param  \DateTime $start Return payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  bool $include_employee_id Return employees with their ID. (optional, default to false)
     * @param  bool $include_contractors Return payments made to contractors on payrolls (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayrollSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPayrollSummaryAsyncWithHttpInfo($company, $start = null, $end = null, $accept = null, $include_employee_id = false, $include_contractors = false, string $contentType = self::contentTypes['getPayrollSummary'][0])
    {
        $returnType = 'object';
        $request = $this->getPayrollSummaryRequest($company, $start, $end, $accept, $include_employee_id, $include_contractors, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPayrollSummary'
     *
     * @param  string $company Return payroll summaries for this company ID (required)
     * @param  \DateTime $start Return payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  bool $include_employee_id Return employees with their ID. (optional, default to false)
     * @param  bool $include_contractors Return payments made to contractors on payrolls (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPayrollSummary'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPayrollSummaryRequest($company, $start = null, $end = null, $accept = null, $include_employee_id = false, $include_contractors = false, string $contentType = self::contentTypes['getPayrollSummary'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getPayrollSummary'
            );
        }







        $resourcePath = '/companies/{company}/reports/payroll_summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end,
            'end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_employee_id,
            'include_employee_id', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_contractors,
            'include_contractors', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReciprocityElections
     *
     * Get reciprocity elections
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReciprocityElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetReciprocityElections200Response|object
     */
    public function getReciprocityElections($employee, string $contentType = self::contentTypes['getReciprocityElections'][0])
    {
        list($response) = $this->getReciprocityElectionsWithHttpInfo($employee, $contentType);
        return $response;
    }

    /**
     * Operation getReciprocityElectionsWithHttpInfo
     *
     * Get reciprocity elections
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReciprocityElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetReciprocityElections200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReciprocityElectionsWithHttpInfo($employee, string $contentType = self::contentTypes['getReciprocityElections'][0])
    {
        $request = $this->getReciprocityElectionsRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetReciprocityElections200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetReciprocityElections200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetReciprocityElections200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetReciprocityElections200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetReciprocityElections200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getReciprocityElectionsAsync
     *
     * Get reciprocity elections
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReciprocityElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReciprocityElectionsAsync($employee, string $contentType = self::contentTypes['getReciprocityElections'][0])
    {
        return $this->getReciprocityElectionsAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReciprocityElectionsAsyncWithHttpInfo
     *
     * Get reciprocity elections
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReciprocityElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReciprocityElectionsAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['getReciprocityElections'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetReciprocityElections200Response';
        $request = $this->getReciprocityElectionsRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReciprocityElections'
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReciprocityElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getReciprocityElectionsRequest($employee, string $contentType = self::contentTypes['getReciprocityElections'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling getReciprocityElections'
            );
        }


        $resourcePath = '/employees/{employee}/reciprocity_elections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSignatories
     *
     * Get signatories
     *
     * @param  string $company ID of the associated company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSignatories'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getSignatories($company, string $contentType = self::contentTypes['getSignatories'][0])
    {
        $this->getSignatoriesWithHttpInfo($company, $contentType);
    }

    /**
     * Operation getSignatoriesWithHttpInfo
     *
     * Get signatories
     *
     * @param  string $company ID of the associated company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSignatories'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSignatoriesWithHttpInfo($company, string $contentType = self::contentTypes['getSignatories'][0])
    {
        $request = $this->getSignatoriesRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSignatoriesAsync
     *
     * Get signatories
     *
     * @param  string $company ID of the associated company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSignatories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignatoriesAsync($company, string $contentType = self::contentTypes['getSignatories'][0])
    {
        return $this->getSignatoriesAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSignatoriesAsyncWithHttpInfo
     *
     * Get signatories
     *
     * @param  string $company ID of the associated company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSignatories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignatoriesAsyncWithHttpInfo($company, string $contentType = self::contentTypes['getSignatories'][0])
    {
        $returnType = '';
        $request = $this->getSignatoriesRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSignatories'
     *
     * @param  string $company ID of the associated company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSignatories'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSignatoriesRequest($company, string $contentType = self::contentTypes['getSignatories'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getSignatories'
            );
        }


        $resourcePath = '/companies/{company}/signatories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTaxLiabilityReport
     *
     * Get tax liability report
     *
     * @param  string $company Return tax liabilities for this company ID (required)
     * @param  \DateTime $start Return tax liabilities from payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return tax liabilities from payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTaxLiabilityReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getTaxLiabilityReport($company, $start = null, $end = null, $accept = null, string $contentType = self::contentTypes['getTaxLiabilityReport'][0])
    {
        list($response) = $this->getTaxLiabilityReportWithHttpInfo($company, $start, $end, $accept, $contentType);
        return $response;
    }

    /**
     * Operation getTaxLiabilityReportWithHttpInfo
     *
     * Get tax liability report
     *
     * @param  string $company Return tax liabilities for this company ID (required)
     * @param  \DateTime $start Return tax liabilities from payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return tax liabilities from payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTaxLiabilityReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaxLiabilityReportWithHttpInfo($company, $start = null, $end = null, $accept = null, string $contentType = self::contentTypes['getTaxLiabilityReport'][0])
    {
        $request = $this->getTaxLiabilityReportRequest($company, $start, $end, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTaxLiabilityReportAsync
     *
     * Get tax liability report
     *
     * @param  string $company Return tax liabilities for this company ID (required)
     * @param  \DateTime $start Return tax liabilities from payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return tax liabilities from payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTaxLiabilityReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaxLiabilityReportAsync($company, $start = null, $end = null, $accept = null, string $contentType = self::contentTypes['getTaxLiabilityReport'][0])
    {
        return $this->getTaxLiabilityReportAsyncWithHttpInfo($company, $start, $end, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaxLiabilityReportAsyncWithHttpInfo
     *
     * Get tax liability report
     *
     * @param  string $company Return tax liabilities for this company ID (required)
     * @param  \DateTime $start Return tax liabilities from payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return tax liabilities from payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTaxLiabilityReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaxLiabilityReportAsyncWithHttpInfo($company, $start = null, $end = null, $accept = null, string $contentType = self::contentTypes['getTaxLiabilityReport'][0])
    {
        $returnType = 'object';
        $request = $this->getTaxLiabilityReportRequest($company, $start, $end, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTaxLiabilityReport'
     *
     * @param  string $company Return tax liabilities for this company ID (required)
     * @param  \DateTime $start Return tax liabilities from payrolls with a payday on or after this date. (optional)
     * @param  \DateTime $end Return tax liabilities from payrolls with a payday before or on this date. (optional)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTaxLiabilityReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTaxLiabilityReportRequest($company, $start = null, $end = null, $accept = null, string $contentType = self::contentTypes['getTaxLiabilityReport'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getTaxLiabilityReport'
            );
        }





        $resourcePath = '/companies/{company}/reports/tax_liabilities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end,
            'end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTheEnrollmentProfile
     *
     * Get the enrollment profile
     *
     * @param  string $company The ID of the associated company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getTheEnrollmentProfile($company, string $contentType = self::contentTypes['getTheEnrollmentProfile'][0])
    {
        $this->getTheEnrollmentProfileWithHttpInfo($company, $contentType);
    }

    /**
     * Operation getTheEnrollmentProfileWithHttpInfo
     *
     * Get the enrollment profile
     *
     * @param  string $company The ID of the associated company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTheEnrollmentProfileWithHttpInfo($company, string $contentType = self::contentTypes['getTheEnrollmentProfile'][0])
    {
        $request = $this->getTheEnrollmentProfileRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTheEnrollmentProfileAsync
     *
     * Get the enrollment profile
     *
     * @param  string $company The ID of the associated company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTheEnrollmentProfileAsync($company, string $contentType = self::contentTypes['getTheEnrollmentProfile'][0])
    {
        return $this->getTheEnrollmentProfileAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTheEnrollmentProfileAsyncWithHttpInfo
     *
     * Get the enrollment profile
     *
     * @param  string $company The ID of the associated company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTheEnrollmentProfileAsyncWithHttpInfo($company, string $contentType = self::contentTypes['getTheEnrollmentProfile'][0])
    {
        $returnType = '';
        $request = $this->getTheEnrollmentProfileRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTheEnrollmentProfile'
     *
     * @param  string $company The ID of the associated company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTheEnrollmentProfileRequest($company, string $contentType = self::contentTypes['getTheEnrollmentProfile'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getTheEnrollmentProfile'
            );
        }


        $resourcePath = '/companies/{company}/enrollment_profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getW2PreviewReport
     *
     * Get W-2 Preview Report
     *
     * @param  string $company Returns employee W-2 data for this company ID (required)
     * @param  string $year Returns employee W-2 data related to this year (defaults to current year). (optional, default to '2021')
     * @param  bool $include_ids Returns employee W-2 data with the associated company and employee ids. (optional, default to false)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getW2PreviewReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getW2PreviewReport($company, $year = '2021', $include_ids = false, $accept = null, string $contentType = self::contentTypes['getW2PreviewReport'][0])
    {
        list($response) = $this->getW2PreviewReportWithHttpInfo($company, $year, $include_ids, $accept, $contentType);
        return $response;
    }

    /**
     * Operation getW2PreviewReportWithHttpInfo
     *
     * Get W-2 Preview Report
     *
     * @param  string $company Returns employee W-2 data for this company ID (required)
     * @param  string $year Returns employee W-2 data related to this year (defaults to current year). (optional, default to '2021')
     * @param  bool $include_ids Returns employee W-2 data with the associated company and employee ids. (optional, default to false)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getW2PreviewReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getW2PreviewReportWithHttpInfo($company, $year = '2021', $include_ids = false, $accept = null, string $contentType = self::contentTypes['getW2PreviewReport'][0])
    {
        $request = $this->getW2PreviewReportRequest($company, $year, $include_ids, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getW2PreviewReportAsync
     *
     * Get W-2 Preview Report
     *
     * @param  string $company Returns employee W-2 data for this company ID (required)
     * @param  string $year Returns employee W-2 data related to this year (defaults to current year). (optional, default to '2021')
     * @param  bool $include_ids Returns employee W-2 data with the associated company and employee ids. (optional, default to false)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getW2PreviewReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getW2PreviewReportAsync($company, $year = '2021', $include_ids = false, $accept = null, string $contentType = self::contentTypes['getW2PreviewReport'][0])
    {
        return $this->getW2PreviewReportAsyncWithHttpInfo($company, $year, $include_ids, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getW2PreviewReportAsyncWithHttpInfo
     *
     * Get W-2 Preview Report
     *
     * @param  string $company Returns employee W-2 data for this company ID (required)
     * @param  string $year Returns employee W-2 data related to this year (defaults to current year). (optional, default to '2021')
     * @param  bool $include_ids Returns employee W-2 data with the associated company and employee ids. (optional, default to false)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getW2PreviewReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getW2PreviewReportAsyncWithHttpInfo($company, $year = '2021', $include_ids = false, $accept = null, string $contentType = self::contentTypes['getW2PreviewReport'][0])
    {
        $returnType = 'object';
        $request = $this->getW2PreviewReportRequest($company, $year, $include_ids, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getW2PreviewReport'
     *
     * @param  string $company Returns employee W-2 data for this company ID (required)
     * @param  string $year Returns employee W-2 data related to this year (defaults to current year). (optional, default to '2021')
     * @param  bool $include_ids Returns employee W-2 data with the associated company and employee ids. (optional, default to false)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getW2PreviewReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getW2PreviewReportRequest($company, $year = '2021', $include_ids = false, $accept = null, string $contentType = self::contentTypes['getW2PreviewReport'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getW2PreviewReport'
            );
        }





        $resourcePath = '/companies/{company}/reports/w2_preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $year,
            'year', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_ids,
            'include_ids', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getW4ExemptStatusReport
     *
     * Get W-4 Exempt Status Report
     *
     * @param  string $company Returns employee federal and state withholding exception data for this company ID (required)
     * @param  string $year Returns employee federal and state withholding excemption data related to this year. (optional, default to 'Current year')
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getW4ExemptStatusReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function getW4ExemptStatusReport($company, $year = 'Current year', $accept = null, string $contentType = self::contentTypes['getW4ExemptStatusReport'][0])
    {
        list($response) = $this->getW4ExemptStatusReportWithHttpInfo($company, $year, $accept, $contentType);
        return $response;
    }

    /**
     * Operation getW4ExemptStatusReportWithHttpInfo
     *
     * Get W-4 Exempt Status Report
     *
     * @param  string $company Returns employee federal and state withholding exception data for this company ID (required)
     * @param  string $year Returns employee federal and state withholding excemption data related to this year. (optional, default to 'Current year')
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getW4ExemptStatusReport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getW4ExemptStatusReportWithHttpInfo($company, $year = 'Current year', $accept = null, string $contentType = self::contentTypes['getW4ExemptStatusReport'][0])
    {
        $request = $this->getW4ExemptStatusReportRequest($company, $year, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getW4ExemptStatusReportAsync
     *
     * Get W-4 Exempt Status Report
     *
     * @param  string $company Returns employee federal and state withholding exception data for this company ID (required)
     * @param  string $year Returns employee federal and state withholding excemption data related to this year. (optional, default to 'Current year')
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getW4ExemptStatusReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getW4ExemptStatusReportAsync($company, $year = 'Current year', $accept = null, string $contentType = self::contentTypes['getW4ExemptStatusReport'][0])
    {
        return $this->getW4ExemptStatusReportAsyncWithHttpInfo($company, $year, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getW4ExemptStatusReportAsyncWithHttpInfo
     *
     * Get W-4 Exempt Status Report
     *
     * @param  string $company Returns employee federal and state withholding exception data for this company ID (required)
     * @param  string $year Returns employee federal and state withholding excemption data related to this year. (optional, default to 'Current year')
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getW4ExemptStatusReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getW4ExemptStatusReportAsyncWithHttpInfo($company, $year = 'Current year', $accept = null, string $contentType = self::contentTypes['getW4ExemptStatusReport'][0])
    {
        $returnType = 'object';
        $request = $this->getW4ExemptStatusReportRequest($company, $year, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getW4ExemptStatusReport'
     *
     * @param  string $company Returns employee federal and state withholding exception data for this company ID (required)
     * @param  string $year Returns employee federal and state withholding excemption data related to this year. (optional, default to 'Current year')
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getW4ExemptStatusReport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getW4ExemptStatusReportRequest($company, $year = 'Current year', $accept = null, string $contentType = self::contentTypes['getW4ExemptStatusReport'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling getW4ExemptStatusReport'
            );
        }




        $resourcePath = '/companies/{company}/reports/w4_exemption_status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $year,
            'year', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAWebhookConfig
     *
     * List webhook configs
     *
     * @param  int $limit Number of webhook configs returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAWebhookConfig200Response[]
     */
    public function listAWebhookConfig($limit = null, string $contentType = self::contentTypes['listAWebhookConfig'][0])
    {
        list($response) = $this->listAWebhookConfigWithHttpInfo($limit, $contentType);
        return $response;
    }

    /**
     * Operation listAWebhookConfigWithHttpInfo
     *
     * List webhook configs
     *
     * @param  int $limit Number of webhook configs returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAWebhookConfig200Response[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listAWebhookConfigWithHttpInfo($limit = null, string $contentType = self::contentTypes['listAWebhookConfig'][0])
    {
        $request = $this->listAWebhookConfigRequest($limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAWebhookConfig200Response[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAWebhookConfig200Response[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAWebhookConfig200Response[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAWebhookConfig200Response[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAWebhookConfig200Response[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAWebhookConfigAsync
     *
     * List webhook configs
     *
     * @param  int $limit Number of webhook configs returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAWebhookConfigAsync($limit = null, string $contentType = self::contentTypes['listAWebhookConfig'][0])
    {
        return $this->listAWebhookConfigAsyncWithHttpInfo($limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAWebhookConfigAsyncWithHttpInfo
     *
     * List webhook configs
     *
     * @param  int $limit Number of webhook configs returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAWebhookConfigAsyncWithHttpInfo($limit = null, string $contentType = self::contentTypes['listAWebhookConfig'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAWebhookConfig200Response[]';
        $request = $this->listAWebhookConfigRequest($limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAWebhookConfig'
     *
     * @param  int $limit Number of webhook configs returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAWebhookConfigRequest($limit = null, string $contentType = self::contentTypes['listAWebhookConfig'][0])
    {



        $resourcePath = '/webhook_configs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listBankAccounts
     *
     * List bank accounts
     *
     * @param  string $company Return bank accounts for this [company](ref:company) ID. (optional)
     * @param  string $employee Return bank accounts for this [employee](ref:the-employee-object) ID. (optional)
     * @param  string $contractor Return bank accounts for this [contractor](ref:the-contractor-object) ID. (optional)
     * @param  int $limit Number of bank accounts returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBankAccounts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListBankAccounts200ResponseInner[]
     */
    public function listBankAccounts($company = null, $employee = null, $contractor = null, $limit = null, string $contentType = self::contentTypes['listBankAccounts'][0])
    {
        list($response) = $this->listBankAccountsWithHttpInfo($company, $employee, $contractor, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listBankAccountsWithHttpInfo
     *
     * List bank accounts
     *
     * @param  string $company Return bank accounts for this [company](ref:company) ID. (optional)
     * @param  string $employee Return bank accounts for this [employee](ref:the-employee-object) ID. (optional)
     * @param  string $contractor Return bank accounts for this [contractor](ref:the-contractor-object) ID. (optional)
     * @param  int $limit Number of bank accounts returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBankAccounts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListBankAccounts200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listBankAccountsWithHttpInfo($company = null, $employee = null, $contractor = null, $limit = null, string $contentType = self::contentTypes['listBankAccounts'][0])
    {
        $request = $this->listBankAccountsRequest($company, $employee, $contractor, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListBankAccounts200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListBankAccounts200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListBankAccounts200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListBankAccounts200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListBankAccounts200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listBankAccountsAsync
     *
     * List bank accounts
     *
     * @param  string $company Return bank accounts for this [company](ref:company) ID. (optional)
     * @param  string $employee Return bank accounts for this [employee](ref:the-employee-object) ID. (optional)
     * @param  string $contractor Return bank accounts for this [contractor](ref:the-contractor-object) ID. (optional)
     * @param  int $limit Number of bank accounts returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBankAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBankAccountsAsync($company = null, $employee = null, $contractor = null, $limit = null, string $contentType = self::contentTypes['listBankAccounts'][0])
    {
        return $this->listBankAccountsAsyncWithHttpInfo($company, $employee, $contractor, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listBankAccountsAsyncWithHttpInfo
     *
     * List bank accounts
     *
     * @param  string $company Return bank accounts for this [company](ref:company) ID. (optional)
     * @param  string $employee Return bank accounts for this [employee](ref:the-employee-object) ID. (optional)
     * @param  string $contractor Return bank accounts for this [contractor](ref:the-contractor-object) ID. (optional)
     * @param  int $limit Number of bank accounts returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBankAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBankAccountsAsyncWithHttpInfo($company = null, $employee = null, $contractor = null, $limit = null, string $contentType = self::contentTypes['listBankAccounts'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListBankAccounts200ResponseInner[]';
        $request = $this->listBankAccountsRequest($company, $employee, $contractor, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listBankAccounts'
     *
     * @param  string $company Return bank accounts for this [company](ref:company) ID. (optional)
     * @param  string $employee Return bank accounts for this [employee](ref:the-employee-object) ID. (optional)
     * @param  string $contractor Return bank accounts for this [contractor](ref:the-contractor-object) ID. (optional)
     * @param  int $limit Number of bank accounts returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBankAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listBankAccountsRequest($company = null, $employee = null, $contractor = null, $limit = null, string $contentType = self::contentTypes['listBankAccounts'][0])
    {






        $resourcePath = '/bank_accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $employee,
            'employee', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contractor,
            'contractor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listBenefits
     *
     * List benefits
     *
     * @param  string $employee Return benefits for this employee ID. (optional)
     * @param  string $company Return benefits for all employees of this company ID. (optional)
     * @param  int $limit Number of benefits returned per page (optional)
     * @param  bool $include_external Flag to indicate if to additionally expose external benefits in the list response. Defaults to false if not included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBenefits'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListBenefits200ResponseInner[]|object
     */
    public function listBenefits($employee = null, $company = null, $limit = null, $include_external = null, string $contentType = self::contentTypes['listBenefits'][0])
    {
        list($response) = $this->listBenefitsWithHttpInfo($employee, $company, $limit, $include_external, $contentType);
        return $response;
    }

    /**
     * Operation listBenefitsWithHttpInfo
     *
     * List benefits
     *
     * @param  string $employee Return benefits for this employee ID. (optional)
     * @param  string $company Return benefits for all employees of this company ID. (optional)
     * @param  int $limit Number of benefits returned per page (optional)
     * @param  bool $include_external Flag to indicate if to additionally expose external benefits in the list response. Defaults to false if not included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBenefits'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListBenefits200ResponseInner[]|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listBenefitsWithHttpInfo($employee = null, $company = null, $limit = null, $include_external = null, string $contentType = self::contentTypes['listBenefits'][0])
    {
        $request = $this->listBenefitsRequest($employee, $company, $limit, $include_external, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListBenefits200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListBenefits200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListBenefits200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListBenefits200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListBenefits200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listBenefitsAsync
     *
     * List benefits
     *
     * @param  string $employee Return benefits for this employee ID. (optional)
     * @param  string $company Return benefits for all employees of this company ID. (optional)
     * @param  int $limit Number of benefits returned per page (optional)
     * @param  bool $include_external Flag to indicate if to additionally expose external benefits in the list response. Defaults to false if not included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBenefits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBenefitsAsync($employee = null, $company = null, $limit = null, $include_external = null, string $contentType = self::contentTypes['listBenefits'][0])
    {
        return $this->listBenefitsAsyncWithHttpInfo($employee, $company, $limit, $include_external, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listBenefitsAsyncWithHttpInfo
     *
     * List benefits
     *
     * @param  string $employee Return benefits for this employee ID. (optional)
     * @param  string $company Return benefits for all employees of this company ID. (optional)
     * @param  int $limit Number of benefits returned per page (optional)
     * @param  bool $include_external Flag to indicate if to additionally expose external benefits in the list response. Defaults to false if not included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBenefits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBenefitsAsyncWithHttpInfo($employee = null, $company = null, $limit = null, $include_external = null, string $contentType = self::contentTypes['listBenefits'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListBenefits200ResponseInner[]';
        $request = $this->listBenefitsRequest($employee, $company, $limit, $include_external, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listBenefits'
     *
     * @param  string $employee Return benefits for this employee ID. (optional)
     * @param  string $company Return benefits for all employees of this company ID. (optional)
     * @param  int $limit Number of benefits returned per page (optional)
     * @param  bool $include_external Flag to indicate if to additionally expose external benefits in the list response. Defaults to false if not included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listBenefits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listBenefitsRequest($employee = null, $company = null, $limit = null, $include_external = null, string $contentType = self::contentTypes['listBenefits'][0])
    {






        $resourcePath = '/benefits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $employee,
            'employee', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_external,
            'include_external', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCompanies
     *
     * List companies
     *
     * @param  bool $active Filter companies by whether they are active or not active. (optional, default to true)
     * @param  int $limit Number of companies returned per page (optional)
     * @param  string[] $id Filter the list to the specified IDs. For more details, check out the [Bulk Get Requests guide](https://docs.checkhq.com/docs/bulk-resource-get-requests). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanies'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function listCompanies($active = true, $limit = null, $id = null, string $contentType = self::contentTypes['listCompanies'][0])
    {
        list($response) = $this->listCompaniesWithHttpInfo($active, $limit, $id, $contentType);
        return $response;
    }

    /**
     * Operation listCompaniesWithHttpInfo
     *
     * List companies
     *
     * @param  bool $active Filter companies by whether they are active or not active. (optional, default to true)
     * @param  int $limit Number of companies returned per page (optional)
     * @param  string[] $id Filter the list to the specified IDs. For more details, check out the [Bulk Get Requests guide](https://docs.checkhq.com/docs/bulk-resource-get-requests). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanies'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCompaniesWithHttpInfo($active = true, $limit = null, $id = null, string $contentType = self::contentTypes['listCompanies'][0])
    {
        $request = $this->listCompaniesRequest($active, $limit, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCompaniesAsync
     *
     * List companies
     *
     * @param  bool $active Filter companies by whether they are active or not active. (optional, default to true)
     * @param  int $limit Number of companies returned per page (optional)
     * @param  string[] $id Filter the list to the specified IDs. For more details, check out the [Bulk Get Requests guide](https://docs.checkhq.com/docs/bulk-resource-get-requests). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompaniesAsync($active = true, $limit = null, $id = null, string $contentType = self::contentTypes['listCompanies'][0])
    {
        return $this->listCompaniesAsyncWithHttpInfo($active, $limit, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCompaniesAsyncWithHttpInfo
     *
     * List companies
     *
     * @param  bool $active Filter companies by whether they are active or not active. (optional, default to true)
     * @param  int $limit Number of companies returned per page (optional)
     * @param  string[] $id Filter the list to the specified IDs. For more details, check out the [Bulk Get Requests guide](https://docs.checkhq.com/docs/bulk-resource-get-requests). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompaniesAsyncWithHttpInfo($active = true, $limit = null, $id = null, string $contentType = self::contentTypes['listCompanies'][0])
    {
        $returnType = 'object';
        $request = $this->listCompaniesRequest($active, $limit, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCompanies'
     *
     * @param  bool $active Filter companies by whether they are active or not active. (optional, default to true)
     * @param  int $limit Number of companies returned per page (optional)
     * @param  string[] $id Filter the list to the specified IDs. For more details, check out the [Bulk Get Requests guide](https://docs.checkhq.com/docs/bulk-resource-get-requests). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCompaniesRequest($active = true, $limit = null, $id = null, string $contentType = self::contentTypes['listCompanies'][0])
    {





        $resourcePath = '/companies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCompanyAuthorizationDocuments
     *
     * List company authorization documents
     *
     * @param  string $company Return authorization documents for this company ID (optional)
     * @param  int $year Return documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of authorization documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyAuthorizationDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function listCompanyAuthorizationDocuments($company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listCompanyAuthorizationDocuments'][0])
    {
        list($response) = $this->listCompanyAuthorizationDocumentsWithHttpInfo($company, $year, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listCompanyAuthorizationDocumentsWithHttpInfo
     *
     * List company authorization documents
     *
     * @param  string $company Return authorization documents for this company ID (optional)
     * @param  int $year Return documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of authorization documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyAuthorizationDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCompanyAuthorizationDocumentsWithHttpInfo($company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listCompanyAuthorizationDocuments'][0])
    {
        $request = $this->listCompanyAuthorizationDocumentsRequest($company, $year, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCompanyAuthorizationDocumentsAsync
     *
     * List company authorization documents
     *
     * @param  string $company Return authorization documents for this company ID (optional)
     * @param  int $year Return documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of authorization documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyAuthorizationDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyAuthorizationDocumentsAsync($company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listCompanyAuthorizationDocuments'][0])
    {
        return $this->listCompanyAuthorizationDocumentsAsyncWithHttpInfo($company, $year, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCompanyAuthorizationDocumentsAsyncWithHttpInfo
     *
     * List company authorization documents
     *
     * @param  string $company Return authorization documents for this company ID (optional)
     * @param  int $year Return documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of authorization documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyAuthorizationDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyAuthorizationDocumentsAsyncWithHttpInfo($company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listCompanyAuthorizationDocuments'][0])
    {
        $returnType = 'object';
        $request = $this->listCompanyAuthorizationDocumentsRequest($company, $year, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCompanyAuthorizationDocuments'
     *
     * @param  string $company Return authorization documents for this company ID (optional)
     * @param  int $year Return documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of authorization documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyAuthorizationDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCompanyAuthorizationDocumentsRequest($company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listCompanyAuthorizationDocuments'][0])
    {





        $resourcePath = '/documents/company_authorization_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $year,
            'year', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCompanyBenefits
     *
     * List company benefits
     *
     * @param  string $company Return all company benefits associated with this company ID. (optional)
     * @param  int $limit Number of company benefits returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyBenefits'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner[]|object
     */
    public function listCompanyBenefits($company = null, $limit = null, string $contentType = self::contentTypes['listCompanyBenefits'][0])
    {
        list($response) = $this->listCompanyBenefitsWithHttpInfo($company, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listCompanyBenefitsWithHttpInfo
     *
     * List company benefits
     *
     * @param  string $company Return all company benefits associated with this company ID. (optional)
     * @param  int $limit Number of company benefits returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyBenefits'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner[]|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCompanyBenefitsWithHttpInfo($company = null, $limit = null, string $contentType = self::contentTypes['listCompanyBenefits'][0])
    {
        $request = $this->listCompanyBenefitsRequest($company, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCompanyBenefitsAsync
     *
     * List company benefits
     *
     * @param  string $company Return all company benefits associated with this company ID. (optional)
     * @param  int $limit Number of company benefits returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyBenefits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyBenefitsAsync($company = null, $limit = null, string $contentType = self::contentTypes['listCompanyBenefits'][0])
    {
        return $this->listCompanyBenefitsAsyncWithHttpInfo($company, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCompanyBenefitsAsyncWithHttpInfo
     *
     * List company benefits
     *
     * @param  string $company Return all company benefits associated with this company ID. (optional)
     * @param  int $limit Number of company benefits returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyBenefits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyBenefitsAsyncWithHttpInfo($company = null, $limit = null, string $contentType = self::contentTypes['listCompanyBenefits'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListCompanyBenefits200ResponseInner[]';
        $request = $this->listCompanyBenefitsRequest($company, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCompanyBenefits'
     *
     * @param  string $company Return all company benefits associated with this company ID. (optional)
     * @param  int $limit Number of company benefits returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyBenefits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCompanyBenefitsRequest($company = null, $limit = null, string $contentType = self::contentTypes['listCompanyBenefits'][0])
    {




        $resourcePath = '/company_benefits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCompanyJurisdictions
     *
     * List a company&#39;s jurisdictions
     *
     * @param  string $company_id ID of the company used to get the applicable tax parameter details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyJurisdictions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listCompanyJurisdictions($company_id, string $contentType = self::contentTypes['listCompanyJurisdictions'][0])
    {
        $this->listCompanyJurisdictionsWithHttpInfo($company_id, $contentType);
    }

    /**
     * Operation listCompanyJurisdictionsWithHttpInfo
     *
     * List a company&#39;s jurisdictions
     *
     * @param  string $company_id ID of the company used to get the applicable tax parameter details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyJurisdictions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCompanyJurisdictionsWithHttpInfo($company_id, string $contentType = self::contentTypes['listCompanyJurisdictions'][0])
    {
        $request = $this->listCompanyJurisdictionsRequest($company_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCompanyJurisdictionsAsync
     *
     * List a company&#39;s jurisdictions
     *
     * @param  string $company_id ID of the company used to get the applicable tax parameter details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyJurisdictions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyJurisdictionsAsync($company_id, string $contentType = self::contentTypes['listCompanyJurisdictions'][0])
    {
        return $this->listCompanyJurisdictionsAsyncWithHttpInfo($company_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCompanyJurisdictionsAsyncWithHttpInfo
     *
     * List a company&#39;s jurisdictions
     *
     * @param  string $company_id ID of the company used to get the applicable tax parameter details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyJurisdictions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyJurisdictionsAsyncWithHttpInfo($company_id, string $contentType = self::contentTypes['listCompanyJurisdictions'][0])
    {
        $returnType = '';
        $request = $this->listCompanyJurisdictionsRequest($company_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCompanyJurisdictions'
     *
     * @param  string $company_id ID of the company used to get the applicable tax parameter details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyJurisdictions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCompanyJurisdictionsRequest($company_id, string $contentType = self::contentTypes['listCompanyJurisdictions'][0])
    {

        // verify the required parameter 'company_id' is set
        if ($company_id === null || (is_array($company_id) && count($company_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company_id when calling listCompanyJurisdictions'
            );
        }


        $resourcePath = '/company_tax_params/{company_id}/jurisdictions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company_id !== null) {
            $resourcePath = str_replace(
                '{' . 'company_id' . '}',
                ObjectSerializer::toPathValue($company_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCompanyProvidedDocuments
     *
     * List company provided documents
     *
     * @param  string $company ID of the company that this document is associated with. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyProvidedDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListCompanyProvidedDocuments200Response|object
     */
    public function listCompanyProvidedDocuments($company = null, string $contentType = self::contentTypes['listCompanyProvidedDocuments'][0])
    {
        list($response) = $this->listCompanyProvidedDocumentsWithHttpInfo($company, $contentType);
        return $response;
    }

    /**
     * Operation listCompanyProvidedDocumentsWithHttpInfo
     *
     * List company provided documents
     *
     * @param  string $company ID of the company that this document is associated with. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyProvidedDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListCompanyProvidedDocuments200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCompanyProvidedDocumentsWithHttpInfo($company = null, string $contentType = self::contentTypes['listCompanyProvidedDocuments'][0])
    {
        $request = $this->listCompanyProvidedDocumentsRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListCompanyProvidedDocuments200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListCompanyProvidedDocuments200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCompanyProvidedDocumentsAsync
     *
     * List company provided documents
     *
     * @param  string $company ID of the company that this document is associated with. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyProvidedDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyProvidedDocumentsAsync($company = null, string $contentType = self::contentTypes['listCompanyProvidedDocuments'][0])
    {
        return $this->listCompanyProvidedDocumentsAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCompanyProvidedDocumentsAsyncWithHttpInfo
     *
     * List company provided documents
     *
     * @param  string $company ID of the company that this document is associated with. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyProvidedDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyProvidedDocumentsAsyncWithHttpInfo($company = null, string $contentType = self::contentTypes['listCompanyProvidedDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListCompanyProvidedDocuments200Response';
        $request = $this->listCompanyProvidedDocumentsRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCompanyProvidedDocuments'
     *
     * @param  string $company ID of the company that this document is associated with. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyProvidedDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCompanyProvidedDocumentsRequest($company = null, string $contentType = self::contentTypes['listCompanyProvidedDocuments'][0])
    {



        $resourcePath = '/company_provided_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCompanyTaxDocuments
     *
     * List company tax documents
     *
     * @param  string $company Return tax documents for this company ID (optional)
     * @param  int $year Return tax documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  string $quarter Return tax documents for this quarter (accepted values are &#x60;q1&#x60;, &#x60;q2&#x60;, &#x60;q3&#x60;, or &#x60;q4&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListCompanyTaxDocuments200Response|object
     */
    public function listCompanyTaxDocuments($company = null, $year = null, $quarter = null, $limit = null, string $contentType = self::contentTypes['listCompanyTaxDocuments'][0])
    {
        list($response) = $this->listCompanyTaxDocumentsWithHttpInfo($company, $year, $quarter, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listCompanyTaxDocumentsWithHttpInfo
     *
     * List company tax documents
     *
     * @param  string $company Return tax documents for this company ID (optional)
     * @param  int $year Return tax documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  string $quarter Return tax documents for this quarter (accepted values are &#x60;q1&#x60;, &#x60;q2&#x60;, &#x60;q3&#x60;, or &#x60;q4&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListCompanyTaxDocuments200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCompanyTaxDocumentsWithHttpInfo($company = null, $year = null, $quarter = null, $limit = null, string $contentType = self::contentTypes['listCompanyTaxDocuments'][0])
    {
        $request = $this->listCompanyTaxDocumentsRequest($company, $year, $quarter, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListCompanyTaxDocuments200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListCompanyTaxDocuments200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListCompanyTaxDocuments200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListCompanyTaxDocuments200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListCompanyTaxDocuments200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCompanyTaxDocumentsAsync
     *
     * List company tax documents
     *
     * @param  string $company Return tax documents for this company ID (optional)
     * @param  int $year Return tax documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  string $quarter Return tax documents for this quarter (accepted values are &#x60;q1&#x60;, &#x60;q2&#x60;, &#x60;q3&#x60;, or &#x60;q4&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyTaxDocumentsAsync($company = null, $year = null, $quarter = null, $limit = null, string $contentType = self::contentTypes['listCompanyTaxDocuments'][0])
    {
        return $this->listCompanyTaxDocumentsAsyncWithHttpInfo($company, $year, $quarter, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCompanyTaxDocumentsAsyncWithHttpInfo
     *
     * List company tax documents
     *
     * @param  string $company Return tax documents for this company ID (optional)
     * @param  int $year Return tax documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  string $quarter Return tax documents for this quarter (accepted values are &#x60;q1&#x60;, &#x60;q2&#x60;, &#x60;q3&#x60;, or &#x60;q4&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyTaxDocumentsAsyncWithHttpInfo($company = null, $year = null, $quarter = null, $limit = null, string $contentType = self::contentTypes['listCompanyTaxDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListCompanyTaxDocuments200Response';
        $request = $this->listCompanyTaxDocumentsRequest($company, $year, $quarter, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCompanyTaxDocuments'
     *
     * @param  string $company Return tax documents for this company ID (optional)
     * @param  int $year Return tax documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  string $quarter Return tax documents for this quarter (accepted values are &#x60;q1&#x60;, &#x60;q2&#x60;, &#x60;q3&#x60;, or &#x60;q4&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCompanyTaxDocumentsRequest($company = null, $year = null, $quarter = null, $limit = null, string $contentType = self::contentTypes['listCompanyTaxDocuments'][0])
    {






        $resourcePath = '/documents/company_tax_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $year,
            'year', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quarter,
            'quarter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCompanyTaxElections
     *
     * List company tax elections
     *
     * @param  string $company Unique ID for the company. (optional)
     * @param  string $tax Unique ID for the tax. (optional)
     * @param  \DateTime $as_of Used to list tax elections applicable as of the supplied date. Defaults to today. (optional)
     * @param  bool $exemptible Used to filter tax elections to exemptible taxes. (optional)
     * @param  string $jurisdiction Used to filter tax elections by tax jurisdiction. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListCompanyTaxElections200Response|object
     */
    public function listCompanyTaxElections($company = null, $tax = null, $as_of = null, $exemptible = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxElections'][0])
    {
        list($response) = $this->listCompanyTaxElectionsWithHttpInfo($company, $tax, $as_of, $exemptible, $jurisdiction, $contentType);
        return $response;
    }

    /**
     * Operation listCompanyTaxElectionsWithHttpInfo
     *
     * List company tax elections
     *
     * @param  string $company Unique ID for the company. (optional)
     * @param  string $tax Unique ID for the tax. (optional)
     * @param  \DateTime $as_of Used to list tax elections applicable as of the supplied date. Defaults to today. (optional)
     * @param  bool $exemptible Used to filter tax elections to exemptible taxes. (optional)
     * @param  string $jurisdiction Used to filter tax elections by tax jurisdiction. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListCompanyTaxElections200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCompanyTaxElectionsWithHttpInfo($company = null, $tax = null, $as_of = null, $exemptible = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxElections'][0])
    {
        $request = $this->listCompanyTaxElectionsRequest($company, $tax, $as_of, $exemptible, $jurisdiction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListCompanyTaxElections200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListCompanyTaxElections200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListCompanyTaxElections200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListCompanyTaxElections200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListCompanyTaxElections200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCompanyTaxElectionsAsync
     *
     * List company tax elections
     *
     * @param  string $company Unique ID for the company. (optional)
     * @param  string $tax Unique ID for the tax. (optional)
     * @param  \DateTime $as_of Used to list tax elections applicable as of the supplied date. Defaults to today. (optional)
     * @param  bool $exemptible Used to filter tax elections to exemptible taxes. (optional)
     * @param  string $jurisdiction Used to filter tax elections by tax jurisdiction. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyTaxElectionsAsync($company = null, $tax = null, $as_of = null, $exemptible = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxElections'][0])
    {
        return $this->listCompanyTaxElectionsAsyncWithHttpInfo($company, $tax, $as_of, $exemptible, $jurisdiction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCompanyTaxElectionsAsyncWithHttpInfo
     *
     * List company tax elections
     *
     * @param  string $company Unique ID for the company. (optional)
     * @param  string $tax Unique ID for the tax. (optional)
     * @param  \DateTime $as_of Used to list tax elections applicable as of the supplied date. Defaults to today. (optional)
     * @param  bool $exemptible Used to filter tax elections to exemptible taxes. (optional)
     * @param  string $jurisdiction Used to filter tax elections by tax jurisdiction. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyTaxElectionsAsyncWithHttpInfo($company = null, $tax = null, $as_of = null, $exemptible = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxElections'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListCompanyTaxElections200Response';
        $request = $this->listCompanyTaxElectionsRequest($company, $tax, $as_of, $exemptible, $jurisdiction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCompanyTaxElections'
     *
     * @param  string $company Unique ID for the company. (optional)
     * @param  string $tax Unique ID for the tax. (optional)
     * @param  \DateTime $as_of Used to list tax elections applicable as of the supplied date. Defaults to today. (optional)
     * @param  bool $exemptible Used to filter tax elections to exemptible taxes. (optional)
     * @param  string $jurisdiction Used to filter tax elections by tax jurisdiction. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCompanyTaxElectionsRequest($company = null, $tax = null, $as_of = null, $exemptible = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxElections'][0])
    {







        $resourcePath = '/company_tax_elections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tax,
            'tax', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_of,
            'as_of', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exemptible,
            'exemptible', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $jurisdiction,
            'jurisdiction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCompanyTaxParameterSettings
     *
     * List a company&#39;s tax parameter settings
     *
     * @param  string $company_id ID of the company used to list the applicable tax parameter details. (required)
     * @param  \DateTime $as_of Used to show the list of tax parameters with the list of effective dated details. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the company’s tax (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listCompanyTaxParameterSettings($company_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxParameterSettings'][0])
    {
        $this->listCompanyTaxParameterSettingsWithHttpInfo($company_id, $as_of, $jurisdiction, $contentType);
    }

    /**
     * Operation listCompanyTaxParameterSettingsWithHttpInfo
     *
     * List a company&#39;s tax parameter settings
     *
     * @param  string $company_id ID of the company used to list the applicable tax parameter details. (required)
     * @param  \DateTime $as_of Used to show the list of tax parameters with the list of effective dated details. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the company’s tax (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCompanyTaxParameterSettingsWithHttpInfo($company_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxParameterSettings'][0])
    {
        $request = $this->listCompanyTaxParameterSettingsRequest($company_id, $as_of, $jurisdiction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCompanyTaxParameterSettingsAsync
     *
     * List a company&#39;s tax parameter settings
     *
     * @param  string $company_id ID of the company used to list the applicable tax parameter details. (required)
     * @param  \DateTime $as_of Used to show the list of tax parameters with the list of effective dated details. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the company’s tax (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyTaxParameterSettingsAsync($company_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxParameterSettings'][0])
    {
        return $this->listCompanyTaxParameterSettingsAsyncWithHttpInfo($company_id, $as_of, $jurisdiction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCompanyTaxParameterSettingsAsyncWithHttpInfo
     *
     * List a company&#39;s tax parameter settings
     *
     * @param  string $company_id ID of the company used to list the applicable tax parameter details. (required)
     * @param  \DateTime $as_of Used to show the list of tax parameters with the list of effective dated details. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the company’s tax (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyTaxParameterSettingsAsyncWithHttpInfo($company_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxParameterSettings'][0])
    {
        $returnType = '';
        $request = $this->listCompanyTaxParameterSettingsRequest($company_id, $as_of, $jurisdiction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCompanyTaxParameterSettings'
     *
     * @param  string $company_id ID of the company used to list the applicable tax parameter details. (required)
     * @param  \DateTime $as_of Used to show the list of tax parameters with the list of effective dated details. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the company’s tax (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCompanyTaxParameterSettingsRequest($company_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxParameterSettings'][0])
    {

        // verify the required parameter 'company_id' is set
        if ($company_id === null || (is_array($company_id) && count($company_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company_id when calling listCompanyTaxParameterSettings'
            );
        }




        $resourcePath = '/company_tax_params/{company_id}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_of,
            'as_of', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $jurisdiction,
            'jurisdiction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($company_id !== null) {
            $resourcePath = str_replace(
                '{' . 'company_id' . '}',
                ObjectSerializer::toPathValue($company_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCompanyTaxParameters
     *
     * List a company&#39;s tax parameters
     *
     * @param  string $company_id ID of the company used to list the applicable tax parameters. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the company’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxParameters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listCompanyTaxParameters($company_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxParameters'][0])
    {
        $this->listCompanyTaxParametersWithHttpInfo($company_id, $as_of, $jurisdiction, $contentType);
    }

    /**
     * Operation listCompanyTaxParametersWithHttpInfo
     *
     * List a company&#39;s tax parameters
     *
     * @param  string $company_id ID of the company used to list the applicable tax parameters. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the company’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxParameters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCompanyTaxParametersWithHttpInfo($company_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxParameters'][0])
    {
        $request = $this->listCompanyTaxParametersRequest($company_id, $as_of, $jurisdiction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCompanyTaxParametersAsync
     *
     * List a company&#39;s tax parameters
     *
     * @param  string $company_id ID of the company used to list the applicable tax parameters. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the company’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyTaxParametersAsync($company_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxParameters'][0])
    {
        return $this->listCompanyTaxParametersAsyncWithHttpInfo($company_id, $as_of, $jurisdiction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCompanyTaxParametersAsyncWithHttpInfo
     *
     * List a company&#39;s tax parameters
     *
     * @param  string $company_id ID of the company used to list the applicable tax parameters. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the company’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCompanyTaxParametersAsyncWithHttpInfo($company_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxParameters'][0])
    {
        $returnType = '';
        $request = $this->listCompanyTaxParametersRequest($company_id, $as_of, $jurisdiction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCompanyTaxParameters'
     *
     * @param  string $company_id ID of the company used to list the applicable tax parameters. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the company’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCompanyTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCompanyTaxParametersRequest($company_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listCompanyTaxParameters'][0])
    {

        // verify the required parameter 'company_id' is set
        if ($company_id === null || (is_array($company_id) && count($company_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company_id when calling listCompanyTaxParameters'
            );
        }




        $resourcePath = '/company_tax_params/{company_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_of,
            'as_of', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $jurisdiction,
            'jurisdiction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($company_id !== null) {
            $resourcePath = str_replace(
                '{' . 'company_id' . '}',
                ObjectSerializer::toPathValue($company_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listContractorPayments
     *
     * List contractor payments
     *
     * @param  string $contractor ID of the contractor to return payments for (required)
     * @param  string $payroll Return payments for the payroll specified by this payroll ID. (optional)
     * @param  int $limit Number of payments returned per page (optional)
     * @param  string $status Filters to only show payments for payrolls with the specified status. If multiple &#x60;status&#x60; params are provided, payments with any of the statuses will be returned. Accepted values are &#x60;pending&#x60;, &#x60;processing&#x60;, &#x60;failed&#x60;, or &#x60;paid&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorPayments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listContractorPayments($contractor, $payroll = null, $limit = null, $status = null, string $contentType = self::contentTypes['listContractorPayments'][0])
    {
        $this->listContractorPaymentsWithHttpInfo($contractor, $payroll, $limit, $status, $contentType);
    }

    /**
     * Operation listContractorPaymentsWithHttpInfo
     *
     * List contractor payments
     *
     * @param  string $contractor ID of the contractor to return payments for (required)
     * @param  string $payroll Return payments for the payroll specified by this payroll ID. (optional)
     * @param  int $limit Number of payments returned per page (optional)
     * @param  string $status Filters to only show payments for payrolls with the specified status. If multiple &#x60;status&#x60; params are provided, payments with any of the statuses will be returned. Accepted values are &#x60;pending&#x60;, &#x60;processing&#x60;, &#x60;failed&#x60;, or &#x60;paid&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorPayments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listContractorPaymentsWithHttpInfo($contractor, $payroll = null, $limit = null, $status = null, string $contentType = self::contentTypes['listContractorPayments'][0])
    {
        $request = $this->listContractorPaymentsRequest($contractor, $payroll, $limit, $status, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation listContractorPaymentsAsync
     *
     * List contractor payments
     *
     * @param  string $contractor ID of the contractor to return payments for (required)
     * @param  string $payroll Return payments for the payroll specified by this payroll ID. (optional)
     * @param  int $limit Number of payments returned per page (optional)
     * @param  string $status Filters to only show payments for payrolls with the specified status. If multiple &#x60;status&#x60; params are provided, payments with any of the statuses will be returned. Accepted values are &#x60;pending&#x60;, &#x60;processing&#x60;, &#x60;failed&#x60;, or &#x60;paid&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listContractorPaymentsAsync($contractor, $payroll = null, $limit = null, $status = null, string $contentType = self::contentTypes['listContractorPayments'][0])
    {
        return $this->listContractorPaymentsAsyncWithHttpInfo($contractor, $payroll, $limit, $status, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listContractorPaymentsAsyncWithHttpInfo
     *
     * List contractor payments
     *
     * @param  string $contractor ID of the contractor to return payments for (required)
     * @param  string $payroll Return payments for the payroll specified by this payroll ID. (optional)
     * @param  int $limit Number of payments returned per page (optional)
     * @param  string $status Filters to only show payments for payrolls with the specified status. If multiple &#x60;status&#x60; params are provided, payments with any of the statuses will be returned. Accepted values are &#x60;pending&#x60;, &#x60;processing&#x60;, &#x60;failed&#x60;, or &#x60;paid&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listContractorPaymentsAsyncWithHttpInfo($contractor, $payroll = null, $limit = null, $status = null, string $contentType = self::contentTypes['listContractorPayments'][0])
    {
        $returnType = '';
        $request = $this->listContractorPaymentsRequest($contractor, $payroll, $limit, $status, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listContractorPayments'
     *
     * @param  string $contractor ID of the contractor to return payments for (required)
     * @param  string $payroll Return payments for the payroll specified by this payroll ID. (optional)
     * @param  int $limit Number of payments returned per page (optional)
     * @param  string $status Filters to only show payments for payrolls with the specified status. If multiple &#x60;status&#x60; params are provided, payments with any of the statuses will be returned. Accepted values are &#x60;pending&#x60;, &#x60;processing&#x60;, &#x60;failed&#x60;, or &#x60;paid&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listContractorPaymentsRequest($contractor, $payroll = null, $limit = null, $status = null, string $contentType = self::contentTypes['listContractorPayments'][0])
    {

        // verify the required parameter 'contractor' is set
        if ($contractor === null || (is_array($contractor) && count($contractor) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractor when calling listContractorPayments'
            );
        }





        $resourcePath = '/contractors/{contractor}/payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payroll,
            'payroll', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($contractor !== null) {
            $resourcePath = str_replace(
                '{' . 'contractor' . '}',
                ObjectSerializer::toPathValue($contractor),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listContractorPayments1
     *
     * List contractor payments
     *
     * @param  string $payroll Return payroll_items for this [payroll](ref:payroll) ID. (optional)
     * @param  string $contractor List contractor_payments for this contractor ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorPayments1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function listContractorPayments1($payroll = null, $contractor = null, string $contentType = self::contentTypes['listContractorPayments1'][0])
    {
        list($response) = $this->listContractorPayments1WithHttpInfo($payroll, $contractor, $contentType);
        return $response;
    }

    /**
     * Operation listContractorPayments1WithHttpInfo
     *
     * List contractor payments
     *
     * @param  string $payroll Return payroll_items for this [payroll](ref:payroll) ID. (optional)
     * @param  string $contractor List contractor_payments for this contractor ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorPayments1'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listContractorPayments1WithHttpInfo($payroll = null, $contractor = null, string $contentType = self::contentTypes['listContractorPayments1'][0])
    {
        $request = $this->listContractorPayments1Request($payroll, $contractor, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listContractorPayments1Async
     *
     * List contractor payments
     *
     * @param  string $payroll Return payroll_items for this [payroll](ref:payroll) ID. (optional)
     * @param  string $contractor List contractor_payments for this contractor ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorPayments1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listContractorPayments1Async($payroll = null, $contractor = null, string $contentType = self::contentTypes['listContractorPayments1'][0])
    {
        return $this->listContractorPayments1AsyncWithHttpInfo($payroll, $contractor, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listContractorPayments1AsyncWithHttpInfo
     *
     * List contractor payments
     *
     * @param  string $payroll Return payroll_items for this [payroll](ref:payroll) ID. (optional)
     * @param  string $contractor List contractor_payments for this contractor ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorPayments1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listContractorPayments1AsyncWithHttpInfo($payroll = null, $contractor = null, string $contentType = self::contentTypes['listContractorPayments1'][0])
    {
        $returnType = 'object';
        $request = $this->listContractorPayments1Request($payroll, $contractor, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listContractorPayments1'
     *
     * @param  string $payroll Return payroll_items for this [payroll](ref:payroll) ID. (optional)
     * @param  string $contractor List contractor_payments for this contractor ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorPayments1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listContractorPayments1Request($payroll = null, $contractor = null, string $contentType = self::contentTypes['listContractorPayments1'][0])
    {




        $resourcePath = '/contractor_payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payroll,
            'payroll', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contractor,
            'contractor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listContractorTaxDocuments
     *
     * List contractor tax documents
     *
     * @param  string $contractor Return documents for this contractor ID. (optional)
     * @param  string $company Return documents for this company ID. Results will include tax documents for all contractors who perform work for this company. (optional)
     * @param  int $year Return documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function listContractorTaxDocuments($contractor = null, $company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listContractorTaxDocuments'][0])
    {
        list($response) = $this->listContractorTaxDocumentsWithHttpInfo($contractor, $company, $year, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listContractorTaxDocumentsWithHttpInfo
     *
     * List contractor tax documents
     *
     * @param  string $contractor Return documents for this contractor ID. (optional)
     * @param  string $company Return documents for this company ID. Results will include tax documents for all contractors who perform work for this company. (optional)
     * @param  int $year Return documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listContractorTaxDocumentsWithHttpInfo($contractor = null, $company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listContractorTaxDocuments'][0])
    {
        $request = $this->listContractorTaxDocumentsRequest($contractor, $company, $year, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listContractorTaxDocumentsAsync
     *
     * List contractor tax documents
     *
     * @param  string $contractor Return documents for this contractor ID. (optional)
     * @param  string $company Return documents for this company ID. Results will include tax documents for all contractors who perform work for this company. (optional)
     * @param  int $year Return documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listContractorTaxDocumentsAsync($contractor = null, $company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listContractorTaxDocuments'][0])
    {
        return $this->listContractorTaxDocumentsAsyncWithHttpInfo($contractor, $company, $year, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listContractorTaxDocumentsAsyncWithHttpInfo
     *
     * List contractor tax documents
     *
     * @param  string $contractor Return documents for this contractor ID. (optional)
     * @param  string $company Return documents for this company ID. Results will include tax documents for all contractors who perform work for this company. (optional)
     * @param  int $year Return documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listContractorTaxDocumentsAsyncWithHttpInfo($contractor = null, $company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listContractorTaxDocuments'][0])
    {
        $returnType = 'object';
        $request = $this->listContractorTaxDocumentsRequest($contractor, $company, $year, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listContractorTaxDocuments'
     *
     * @param  string $contractor Return documents for this contractor ID. (optional)
     * @param  string $company Return documents for this company ID. Results will include tax documents for all contractors who perform work for this company. (optional)
     * @param  int $year Return documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractorTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listContractorTaxDocumentsRequest($contractor = null, $company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listContractorTaxDocuments'][0])
    {






        $resourcePath = '/documents/contractor_tax_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contractor,
            'contractor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $year,
            'year', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listContractors
     *
     * List contractors
     *
     * @param  string $company Return contractors for the company specified by this company ID. (optional)
     * @param  int $limit Number of contractors returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractors'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function listContractors($company = null, $limit = null, string $contentType = self::contentTypes['listContractors'][0])
    {
        list($response) = $this->listContractorsWithHttpInfo($company, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listContractorsWithHttpInfo
     *
     * List contractors
     *
     * @param  string $company Return contractors for the company specified by this company ID. (optional)
     * @param  int $limit Number of contractors returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractors'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listContractorsWithHttpInfo($company = null, $limit = null, string $contentType = self::contentTypes['listContractors'][0])
    {
        $request = $this->listContractorsRequest($company, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listContractorsAsync
     *
     * List contractors
     *
     * @param  string $company Return contractors for the company specified by this company ID. (optional)
     * @param  int $limit Number of contractors returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listContractorsAsync($company = null, $limit = null, string $contentType = self::contentTypes['listContractors'][0])
    {
        return $this->listContractorsAsyncWithHttpInfo($company, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listContractorsAsyncWithHttpInfo
     *
     * List contractors
     *
     * @param  string $company Return contractors for the company specified by this company ID. (optional)
     * @param  int $limit Number of contractors returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listContractorsAsyncWithHttpInfo($company = null, $limit = null, string $contentType = self::contentTypes['listContractors'][0])
    {
        $returnType = 'object';
        $request = $this->listContractorsRequest($company, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listContractors'
     *
     * @param  string $company Return contractors for the company specified by this company ID. (optional)
     * @param  int $limit Number of contractors returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listContractors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listContractorsRequest($company = null, $limit = null, string $contentType = self::contentTypes['listContractors'][0])
    {




        $resourcePath = '/contractors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEarningCodes
     *
     * List earning codes
     *
     * @param  string $company company (optional)
     * @param  int $limit Number of earning codes returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEarningCodes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function listEarningCodes($company = null, $limit = null, string $contentType = self::contentTypes['listEarningCodes'][0])
    {
        list($response) = $this->listEarningCodesWithHttpInfo($company, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listEarningCodesWithHttpInfo
     *
     * List earning codes
     *
     * @param  string $company (optional)
     * @param  int $limit Number of earning codes returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEarningCodes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEarningCodesWithHttpInfo($company = null, $limit = null, string $contentType = self::contentTypes['listEarningCodes'][0])
    {
        $request = $this->listEarningCodesRequest($company, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEarningCodesAsync
     *
     * List earning codes
     *
     * @param  string $company (optional)
     * @param  int $limit Number of earning codes returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEarningCodes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEarningCodesAsync($company = null, $limit = null, string $contentType = self::contentTypes['listEarningCodes'][0])
    {
        return $this->listEarningCodesAsyncWithHttpInfo($company, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEarningCodesAsyncWithHttpInfo
     *
     * List earning codes
     *
     * @param  string $company (optional)
     * @param  int $limit Number of earning codes returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEarningCodes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEarningCodesAsyncWithHttpInfo($company = null, $limit = null, string $contentType = self::contentTypes['listEarningCodes'][0])
    {
        $returnType = 'object';
        $request = $this->listEarningCodesRequest($company, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEarningCodes'
     *
     * @param  string $company (optional)
     * @param  int $limit Number of earning codes returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEarningCodes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEarningCodesRequest($company = null, $limit = null, string $contentType = self::contentTypes['listEarningCodes'][0])
    {




        $resourcePath = '/earning_codes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEarningRates
     *
     * List earning rates
     *
     * @param  bool $active active (optional)
     * @param  string $employee employee (optional)
     * @param  int $limit Number of earning rates returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEarningRates'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function listEarningRates($active = null, $employee = null, $limit = null, string $contentType = self::contentTypes['listEarningRates'][0])
    {
        list($response) = $this->listEarningRatesWithHttpInfo($active, $employee, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listEarningRatesWithHttpInfo
     *
     * List earning rates
     *
     * @param  bool $active (optional)
     * @param  string $employee (optional)
     * @param  int $limit Number of earning rates returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEarningRates'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEarningRatesWithHttpInfo($active = null, $employee = null, $limit = null, string $contentType = self::contentTypes['listEarningRates'][0])
    {
        $request = $this->listEarningRatesRequest($active, $employee, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEarningRatesAsync
     *
     * List earning rates
     *
     * @param  bool $active (optional)
     * @param  string $employee (optional)
     * @param  int $limit Number of earning rates returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEarningRates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEarningRatesAsync($active = null, $employee = null, $limit = null, string $contentType = self::contentTypes['listEarningRates'][0])
    {
        return $this->listEarningRatesAsyncWithHttpInfo($active, $employee, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEarningRatesAsyncWithHttpInfo
     *
     * List earning rates
     *
     * @param  bool $active (optional)
     * @param  string $employee (optional)
     * @param  int $limit Number of earning rates returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEarningRates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEarningRatesAsyncWithHttpInfo($active = null, $employee = null, $limit = null, string $contentType = self::contentTypes['listEarningRates'][0])
    {
        $returnType = 'object';
        $request = $this->listEarningRatesRequest($active, $employee, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEarningRates'
     *
     * @param  bool $active (optional)
     * @param  string $employee (optional)
     * @param  int $limit Number of earning rates returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEarningRates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEarningRatesRequest($active = null, $employee = null, $limit = null, string $contentType = self::contentTypes['listEarningRates'][0])
    {





        $resourcePath = '/earning_rates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $employee,
            'employee', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEmployeeForms
     *
     * List employee forms
     *
     * @param  string $employee Return forms associated with this employee ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeForms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listEmployeeForms($employee, string $contentType = self::contentTypes['listEmployeeForms'][0])
    {
        $this->listEmployeeFormsWithHttpInfo($employee, $contentType);
    }

    /**
     * Operation listEmployeeFormsWithHttpInfo
     *
     * List employee forms
     *
     * @param  string $employee Return forms associated with this employee ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeForms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEmployeeFormsWithHttpInfo($employee, string $contentType = self::contentTypes['listEmployeeForms'][0])
    {
        $request = $this->listEmployeeFormsRequest($employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEmployeeFormsAsync
     *
     * List employee forms
     *
     * @param  string $employee Return forms associated with this employee ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeForms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeeFormsAsync($employee, string $contentType = self::contentTypes['listEmployeeForms'][0])
    {
        return $this->listEmployeeFormsAsyncWithHttpInfo($employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEmployeeFormsAsyncWithHttpInfo
     *
     * List employee forms
     *
     * @param  string $employee Return forms associated with this employee ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeForms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeeFormsAsyncWithHttpInfo($employee, string $contentType = self::contentTypes['listEmployeeForms'][0])
    {
        $returnType = '';
        $request = $this->listEmployeeFormsRequest($employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEmployeeForms'
     *
     * @param  string $employee Return forms associated with this employee ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeForms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEmployeeFormsRequest($employee, string $contentType = self::contentTypes['listEmployeeForms'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling listEmployeeForms'
            );
        }


        $resourcePath = '/employees/{employee}/forms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEmployeeJurisdictions
     *
     * List an employee&#39;s jurisdictions
     *
     * @param  string $employee_id ID of the employee used to get the applicable tax param object details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeJurisdictions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listEmployeeJurisdictions($employee_id, string $contentType = self::contentTypes['listEmployeeJurisdictions'][0])
    {
        $this->listEmployeeJurisdictionsWithHttpInfo($employee_id, $contentType);
    }

    /**
     * Operation listEmployeeJurisdictionsWithHttpInfo
     *
     * List an employee&#39;s jurisdictions
     *
     * @param  string $employee_id ID of the employee used to get the applicable tax param object details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeJurisdictions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEmployeeJurisdictionsWithHttpInfo($employee_id, string $contentType = self::contentTypes['listEmployeeJurisdictions'][0])
    {
        $request = $this->listEmployeeJurisdictionsRequest($employee_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEmployeeJurisdictionsAsync
     *
     * List an employee&#39;s jurisdictions
     *
     * @param  string $employee_id ID of the employee used to get the applicable tax param object details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeJurisdictions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeeJurisdictionsAsync($employee_id, string $contentType = self::contentTypes['listEmployeeJurisdictions'][0])
    {
        return $this->listEmployeeJurisdictionsAsyncWithHttpInfo($employee_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEmployeeJurisdictionsAsyncWithHttpInfo
     *
     * List an employee&#39;s jurisdictions
     *
     * @param  string $employee_id ID of the employee used to get the applicable tax param object details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeJurisdictions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeeJurisdictionsAsyncWithHttpInfo($employee_id, string $contentType = self::contentTypes['listEmployeeJurisdictions'][0])
    {
        $returnType = '';
        $request = $this->listEmployeeJurisdictionsRequest($employee_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEmployeeJurisdictions'
     *
     * @param  string $employee_id ID of the employee used to get the applicable tax param object details. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeJurisdictions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEmployeeJurisdictionsRequest($employee_id, string $contentType = self::contentTypes['listEmployeeJurisdictions'][0])
    {

        // verify the required parameter 'employee_id' is set
        if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee_id when calling listEmployeeJurisdictions'
            );
        }


        $resourcePath = '/employee_tax_params/{employee_id}/jurisdictions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee_id !== null) {
            $resourcePath = str_replace(
                '{' . 'employee_id' . '}',
                ObjectSerializer::toPathValue($employee_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEmployeeTaxDocuments
     *
     * List employee tax documents
     *
     * @param  string $employee Return tax documents for this employee ID (optional)
     * @param  string $company Return tax documents for this company ID (optional)
     * @param  int $year List documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listEmployeeTaxDocuments($employee = null, $company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listEmployeeTaxDocuments'][0])
    {
        $this->listEmployeeTaxDocumentsWithHttpInfo($employee, $company, $year, $limit, $contentType);
    }

    /**
     * Operation listEmployeeTaxDocumentsWithHttpInfo
     *
     * List employee tax documents
     *
     * @param  string $employee Return tax documents for this employee ID (optional)
     * @param  string $company Return tax documents for this company ID (optional)
     * @param  int $year List documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEmployeeTaxDocumentsWithHttpInfo($employee = null, $company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listEmployeeTaxDocuments'][0])
    {
        $request = $this->listEmployeeTaxDocumentsRequest($employee, $company, $year, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEmployeeTaxDocumentsAsync
     *
     * List employee tax documents
     *
     * @param  string $employee Return tax documents for this employee ID (optional)
     * @param  string $company Return tax documents for this company ID (optional)
     * @param  int $year List documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeeTaxDocumentsAsync($employee = null, $company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listEmployeeTaxDocuments'][0])
    {
        return $this->listEmployeeTaxDocumentsAsyncWithHttpInfo($employee, $company, $year, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEmployeeTaxDocumentsAsyncWithHttpInfo
     *
     * List employee tax documents
     *
     * @param  string $employee Return tax documents for this employee ID (optional)
     * @param  string $company Return tax documents for this company ID (optional)
     * @param  int $year List documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeeTaxDocumentsAsyncWithHttpInfo($employee = null, $company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listEmployeeTaxDocuments'][0])
    {
        $returnType = '';
        $request = $this->listEmployeeTaxDocumentsRequest($employee, $company, $year, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEmployeeTaxDocuments'
     *
     * @param  string $employee Return tax documents for this employee ID (optional)
     * @param  string $company Return tax documents for this company ID (optional)
     * @param  int $year List documents for this year (must be greater than or equal to &#x60;2019&#x60;) (optional)
     * @param  int $limit Number of tax documents returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEmployeeTaxDocumentsRequest($employee = null, $company = null, $year = null, $limit = null, string $contentType = self::contentTypes['listEmployeeTaxDocuments'][0])
    {






        $resourcePath = '/documents/employee_tax_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $employee,
            'employee', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $year,
            'year', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEmployeeTaxElections
     *
     * List employee tax elections
     *
     * @param  string $company Unique ID for the company. (optional)
     * @param  string $employee Unique ID for the employee. (optional)
     * @param  string $tax Unique ID for the tax. (optional)
     * @param  \DateTime $as_of Used to list tax elections applicable as of the supplied date. Defaults to today. (optional)
     * @param  bool $exemptible Used to filter tax elections to exemptible taxes. (optional)
     * @param  string $jurisdiction Used to filter tax elections by tax jurisdiction. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListEmployeeTaxElections200Response|object
     */
    public function listEmployeeTaxElections($company = null, $employee = null, $tax = null, $as_of = null, $exemptible = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeeTaxElections'][0])
    {
        list($response) = $this->listEmployeeTaxElectionsWithHttpInfo($company, $employee, $tax, $as_of, $exemptible, $jurisdiction, $contentType);
        return $response;
    }

    /**
     * Operation listEmployeeTaxElectionsWithHttpInfo
     *
     * List employee tax elections
     *
     * @param  string $company Unique ID for the company. (optional)
     * @param  string $employee Unique ID for the employee. (optional)
     * @param  string $tax Unique ID for the tax. (optional)
     * @param  \DateTime $as_of Used to list tax elections applicable as of the supplied date. Defaults to today. (optional)
     * @param  bool $exemptible Used to filter tax elections to exemptible taxes. (optional)
     * @param  string $jurisdiction Used to filter tax elections by tax jurisdiction. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListEmployeeTaxElections200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEmployeeTaxElectionsWithHttpInfo($company = null, $employee = null, $tax = null, $as_of = null, $exemptible = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeeTaxElections'][0])
    {
        $request = $this->listEmployeeTaxElectionsRequest($company, $employee, $tax, $as_of, $exemptible, $jurisdiction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListEmployeeTaxElections200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListEmployeeTaxElections200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListEmployeeTaxElections200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListEmployeeTaxElections200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListEmployeeTaxElections200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEmployeeTaxElectionsAsync
     *
     * List employee tax elections
     *
     * @param  string $company Unique ID for the company. (optional)
     * @param  string $employee Unique ID for the employee. (optional)
     * @param  string $tax Unique ID for the tax. (optional)
     * @param  \DateTime $as_of Used to list tax elections applicable as of the supplied date. Defaults to today. (optional)
     * @param  bool $exemptible Used to filter tax elections to exemptible taxes. (optional)
     * @param  string $jurisdiction Used to filter tax elections by tax jurisdiction. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeeTaxElectionsAsync($company = null, $employee = null, $tax = null, $as_of = null, $exemptible = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeeTaxElections'][0])
    {
        return $this->listEmployeeTaxElectionsAsyncWithHttpInfo($company, $employee, $tax, $as_of, $exemptible, $jurisdiction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEmployeeTaxElectionsAsyncWithHttpInfo
     *
     * List employee tax elections
     *
     * @param  string $company Unique ID for the company. (optional)
     * @param  string $employee Unique ID for the employee. (optional)
     * @param  string $tax Unique ID for the tax. (optional)
     * @param  \DateTime $as_of Used to list tax elections applicable as of the supplied date. Defaults to today. (optional)
     * @param  bool $exemptible Used to filter tax elections to exemptible taxes. (optional)
     * @param  string $jurisdiction Used to filter tax elections by tax jurisdiction. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeeTaxElectionsAsyncWithHttpInfo($company = null, $employee = null, $tax = null, $as_of = null, $exemptible = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeeTaxElections'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListEmployeeTaxElections200Response';
        $request = $this->listEmployeeTaxElectionsRequest($company, $employee, $tax, $as_of, $exemptible, $jurisdiction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEmployeeTaxElections'
     *
     * @param  string $company Unique ID for the company. (optional)
     * @param  string $employee Unique ID for the employee. (optional)
     * @param  string $tax Unique ID for the tax. (optional)
     * @param  \DateTime $as_of Used to list tax elections applicable as of the supplied date. Defaults to today. (optional)
     * @param  bool $exemptible Used to filter tax elections to exemptible taxes. (optional)
     * @param  string $jurisdiction Used to filter tax elections by tax jurisdiction. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEmployeeTaxElectionsRequest($company = null, $employee = null, $tax = null, $as_of = null, $exemptible = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeeTaxElections'][0])
    {








        $resourcePath = '/employee_tax_elections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $employee,
            'employee', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tax,
            'tax', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_of,
            'as_of', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exemptible,
            'exemptible', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $jurisdiction,
            'jurisdiction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEmployeeTaxParameterSettings
     *
     * List an employee&#39;s tax parameter settings
     *
     * @param  string $employee_id ID of the employee used to list the applicable tax parameter details. (required)
     * @param  \DateTime $as_of Used to show the list of tax parameter with the list of effective dated details. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameter details to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listEmployeeTaxParameterSettings($employee_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeeTaxParameterSettings'][0])
    {
        $this->listEmployeeTaxParameterSettingsWithHttpInfo($employee_id, $as_of, $jurisdiction, $contentType);
    }

    /**
     * Operation listEmployeeTaxParameterSettingsWithHttpInfo
     *
     * List an employee&#39;s tax parameter settings
     *
     * @param  string $employee_id ID of the employee used to list the applicable tax parameter details. (required)
     * @param  \DateTime $as_of Used to show the list of tax parameter with the list of effective dated details. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameter details to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEmployeeTaxParameterSettingsWithHttpInfo($employee_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeeTaxParameterSettings'][0])
    {
        $request = $this->listEmployeeTaxParameterSettingsRequest($employee_id, $as_of, $jurisdiction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEmployeeTaxParameterSettingsAsync
     *
     * List an employee&#39;s tax parameter settings
     *
     * @param  string $employee_id ID of the employee used to list the applicable tax parameter details. (required)
     * @param  \DateTime $as_of Used to show the list of tax parameter with the list of effective dated details. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameter details to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeeTaxParameterSettingsAsync($employee_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeeTaxParameterSettings'][0])
    {
        return $this->listEmployeeTaxParameterSettingsAsyncWithHttpInfo($employee_id, $as_of, $jurisdiction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEmployeeTaxParameterSettingsAsyncWithHttpInfo
     *
     * List an employee&#39;s tax parameter settings
     *
     * @param  string $employee_id ID of the employee used to list the applicable tax parameter details. (required)
     * @param  \DateTime $as_of Used to show the list of tax parameter with the list of effective dated details. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameter details to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeeTaxParameterSettingsAsyncWithHttpInfo($employee_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeeTaxParameterSettings'][0])
    {
        $returnType = '';
        $request = $this->listEmployeeTaxParameterSettingsRequest($employee_id, $as_of, $jurisdiction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEmployeeTaxParameterSettings'
     *
     * @param  string $employee_id ID of the employee used to list the applicable tax parameter details. (required)
     * @param  \DateTime $as_of Used to show the list of tax parameter with the list of effective dated details. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameter details to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeeTaxParameterSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEmployeeTaxParameterSettingsRequest($employee_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeeTaxParameterSettings'][0])
    {

        // verify the required parameter 'employee_id' is set
        if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee_id when calling listEmployeeTaxParameterSettings'
            );
        }




        $resourcePath = '/employee_tax_params/{employee_id}/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_of,
            'as_of', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $jurisdiction,
            'jurisdiction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($employee_id !== null) {
            $resourcePath = str_replace(
                '{' . 'employee_id' . '}',
                ObjectSerializer::toPathValue($employee_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEmployees
     *
     * List employees
     *
     * @param  string $company Return employees for this company ID. (optional)
     * @param  int $limit Number of employees returned per page (optional)
     * @param  string $workplace Return employees who work at these workplaces (can be comma-separated list of workplace IDs) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployees'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listEmployees($company = null, $limit = null, $workplace = null, string $contentType = self::contentTypes['listEmployees'][0])
    {
        $this->listEmployeesWithHttpInfo($company, $limit, $workplace, $contentType);
    }

    /**
     * Operation listEmployeesWithHttpInfo
     *
     * List employees
     *
     * @param  string $company Return employees for this company ID. (optional)
     * @param  int $limit Number of employees returned per page (optional)
     * @param  string $workplace Return employees who work at these workplaces (can be comma-separated list of workplace IDs) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployees'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEmployeesWithHttpInfo($company = null, $limit = null, $workplace = null, string $contentType = self::contentTypes['listEmployees'][0])
    {
        $request = $this->listEmployeesRequest($company, $limit, $workplace, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation listEmployeesAsync
     *
     * List employees
     *
     * @param  string $company Return employees for this company ID. (optional)
     * @param  int $limit Number of employees returned per page (optional)
     * @param  string $workplace Return employees who work at these workplaces (can be comma-separated list of workplace IDs) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeesAsync($company = null, $limit = null, $workplace = null, string $contentType = self::contentTypes['listEmployees'][0])
    {
        return $this->listEmployeesAsyncWithHttpInfo($company, $limit, $workplace, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEmployeesAsyncWithHttpInfo
     *
     * List employees
     *
     * @param  string $company Return employees for this company ID. (optional)
     * @param  int $limit Number of employees returned per page (optional)
     * @param  string $workplace Return employees who work at these workplaces (can be comma-separated list of workplace IDs) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeesAsyncWithHttpInfo($company = null, $limit = null, $workplace = null, string $contentType = self::contentTypes['listEmployees'][0])
    {
        $returnType = '';
        $request = $this->listEmployeesRequest($company, $limit, $workplace, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEmployees'
     *
     * @param  string $company Return employees for this company ID. (optional)
     * @param  int $limit Number of employees returned per page (optional)
     * @param  string $workplace Return employees who work at these workplaces (can be comma-separated list of workplace IDs) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEmployeesRequest($company = null, $limit = null, $workplace = null, string $contentType = self::contentTypes['listEmployees'][0])
    {





        $resourcePath = '/employees';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $workplace,
            'workplace', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEmployeesTaxParameters
     *
     * List an employee&#39;s tax parameters
     *
     * @param  string $employee_id ID of the employee used to list the applicable tax parameter. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeesTaxParameters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listEmployeesTaxParameters($employee_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeesTaxParameters'][0])
    {
        $this->listEmployeesTaxParametersWithHttpInfo($employee_id, $as_of, $jurisdiction, $contentType);
    }

    /**
     * Operation listEmployeesTaxParametersWithHttpInfo
     *
     * List an employee&#39;s tax parameters
     *
     * @param  string $employee_id ID of the employee used to list the applicable tax parameter. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeesTaxParameters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listEmployeesTaxParametersWithHttpInfo($employee_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeesTaxParameters'][0])
    {
        $request = $this->listEmployeesTaxParametersRequest($employee_id, $as_of, $jurisdiction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEmployeesTaxParametersAsync
     *
     * List an employee&#39;s tax parameters
     *
     * @param  string $employee_id ID of the employee used to list the applicable tax parameter. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeesTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeesTaxParametersAsync($employee_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeesTaxParameters'][0])
    {
        return $this->listEmployeesTaxParametersAsyncWithHttpInfo($employee_id, $as_of, $jurisdiction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEmployeesTaxParametersAsyncWithHttpInfo
     *
     * List an employee&#39;s tax parameters
     *
     * @param  string $employee_id ID of the employee used to list the applicable tax parameter. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeesTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEmployeesTaxParametersAsyncWithHttpInfo($employee_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeesTaxParameters'][0])
    {
        $returnType = '';
        $request = $this->listEmployeesTaxParametersRequest($employee_id, $as_of, $jurisdiction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEmployeesTaxParameters'
     *
     * @param  string $employee_id ID of the employee used to list the applicable tax parameter. (required)
     * @param  \DateTime $as_of Used to list tax parameters applicable as of the supplied date. (optional)
     * @param  string $jurisdiction Used to further filter down the list of the employee’s tax parameters to specific jurisdictions. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listEmployeesTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listEmployeesTaxParametersRequest($employee_id, $as_of = null, $jurisdiction = null, string $contentType = self::contentTypes['listEmployeesTaxParameters'][0])
    {

        // verify the required parameter 'employee_id' is set
        if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee_id when calling listEmployeesTaxParameters'
            );
        }




        $resourcePath = '/employee_tax_params/{employee_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $as_of,
            'as_of', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $jurisdiction,
            'jurisdiction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($employee_id !== null) {
            $resourcePath = str_replace(
                '{' . 'employee_id' . '}',
                ObjectSerializer::toPathValue($employee_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFederalEinVerifications
     *
     * List Federal EIN Verifications
     *
     * @param  string $company ID of the company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFederalEinVerifications'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListFederalEinVerifications200Response|object
     */
    public function listFederalEinVerifications($company, string $contentType = self::contentTypes['listFederalEinVerifications'][0])
    {
        list($response) = $this->listFederalEinVerificationsWithHttpInfo($company, $contentType);
        return $response;
    }

    /**
     * Operation listFederalEinVerificationsWithHttpInfo
     *
     * List Federal EIN Verifications
     *
     * @param  string $company ID of the company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFederalEinVerifications'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListFederalEinVerifications200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFederalEinVerificationsWithHttpInfo($company, string $contentType = self::contentTypes['listFederalEinVerifications'][0])
    {
        $request = $this->listFederalEinVerificationsRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListFederalEinVerifications200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListFederalEinVerifications200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListFederalEinVerifications200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListFederalEinVerifications200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListFederalEinVerifications200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listFederalEinVerificationsAsync
     *
     * List Federal EIN Verifications
     *
     * @param  string $company ID of the company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFederalEinVerifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFederalEinVerificationsAsync($company, string $contentType = self::contentTypes['listFederalEinVerifications'][0])
    {
        return $this->listFederalEinVerificationsAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFederalEinVerificationsAsyncWithHttpInfo
     *
     * List Federal EIN Verifications
     *
     * @param  string $company ID of the company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFederalEinVerifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFederalEinVerificationsAsyncWithHttpInfo($company, string $contentType = self::contentTypes['listFederalEinVerifications'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListFederalEinVerifications200Response';
        $request = $this->listFederalEinVerificationsRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFederalEinVerifications'
     *
     * @param  string $company ID of the company (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFederalEinVerifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listFederalEinVerificationsRequest($company, string $contentType = self::contentTypes['listFederalEinVerifications'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling listFederalEinVerifications'
            );
        }


        $resourcePath = '/companies/{company}/federal_ein_verifications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listForms
     *
     * List forms
     *
     * @param  string $state Filter for forms that apply to the provided state. Must be a two-digit state abbreviation. (optional)
     * @param  string $lang Prefer returning forms in the provided ISO 639-1 language code. Fall back to English forms if preferred language form does not exist. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listForms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listForms($state = null, $lang = null, string $contentType = self::contentTypes['listForms'][0])
    {
        $this->listFormsWithHttpInfo($state, $lang, $contentType);
    }

    /**
     * Operation listFormsWithHttpInfo
     *
     * List forms
     *
     * @param  string $state Filter for forms that apply to the provided state. Must be a two-digit state abbreviation. (optional)
     * @param  string $lang Prefer returning forms in the provided ISO 639-1 language code. Fall back to English forms if preferred language form does not exist. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listForms'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFormsWithHttpInfo($state = null, $lang = null, string $contentType = self::contentTypes['listForms'][0])
    {
        $request = $this->listFormsRequest($state, $lang, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listFormsAsync
     *
     * List forms
     *
     * @param  string $state Filter for forms that apply to the provided state. Must be a two-digit state abbreviation. (optional)
     * @param  string $lang Prefer returning forms in the provided ISO 639-1 language code. Fall back to English forms if preferred language form does not exist. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listForms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFormsAsync($state = null, $lang = null, string $contentType = self::contentTypes['listForms'][0])
    {
        return $this->listFormsAsyncWithHttpInfo($state, $lang, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFormsAsyncWithHttpInfo
     *
     * List forms
     *
     * @param  string $state Filter for forms that apply to the provided state. Must be a two-digit state abbreviation. (optional)
     * @param  string $lang Prefer returning forms in the provided ISO 639-1 language code. Fall back to English forms if preferred language form does not exist. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listForms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFormsAsyncWithHttpInfo($state = null, $lang = null, string $contentType = self::contentTypes['listForms'][0])
    {
        $returnType = '';
        $request = $this->listFormsRequest($state, $lang, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listForms'
     *
     * @param  string $state Filter for forms that apply to the provided state. Must be a two-digit state abbreviation. (optional)
     * @param  string $lang Prefer returning forms in the provided ISO 639-1 language code. Fall back to English forms if preferred language form does not exist. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listForms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listFormsRequest($state = null, $lang = null, string $contentType = self::contentTypes['listForms'][0])
    {




        $resourcePath = '/forms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state,
            'state', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang,
            'lang', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listNetPaySplits
     *
     * List net pay splits
     *
     * @param  string $employee ID of the employee whose net pay splits should be listed (optional)
     * @param  string $contractor ID of the contractor whose net pay split should be listed (optional)
     * @param  int $limit Number of net pay splits returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listNetPaySplits'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListNetPaySplits200ResponseInner[]
     */
    public function listNetPaySplits($employee = null, $contractor = null, $limit = null, string $contentType = self::contentTypes['listNetPaySplits'][0])
    {
        list($response) = $this->listNetPaySplitsWithHttpInfo($employee, $contractor, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listNetPaySplitsWithHttpInfo
     *
     * List net pay splits
     *
     * @param  string $employee ID of the employee whose net pay splits should be listed (optional)
     * @param  string $contractor ID of the contractor whose net pay split should be listed (optional)
     * @param  int $limit Number of net pay splits returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listNetPaySplits'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListNetPaySplits200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listNetPaySplitsWithHttpInfo($employee = null, $contractor = null, $limit = null, string $contentType = self::contentTypes['listNetPaySplits'][0])
    {
        $request = $this->listNetPaySplitsRequest($employee, $contractor, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listNetPaySplitsAsync
     *
     * List net pay splits
     *
     * @param  string $employee ID of the employee whose net pay splits should be listed (optional)
     * @param  string $contractor ID of the contractor whose net pay split should be listed (optional)
     * @param  int $limit Number of net pay splits returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listNetPaySplits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNetPaySplitsAsync($employee = null, $contractor = null, $limit = null, string $contentType = self::contentTypes['listNetPaySplits'][0])
    {
        return $this->listNetPaySplitsAsyncWithHttpInfo($employee, $contractor, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listNetPaySplitsAsyncWithHttpInfo
     *
     * List net pay splits
     *
     * @param  string $employee ID of the employee whose net pay splits should be listed (optional)
     * @param  string $contractor ID of the contractor whose net pay split should be listed (optional)
     * @param  int $limit Number of net pay splits returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listNetPaySplits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNetPaySplitsAsyncWithHttpInfo($employee = null, $contractor = null, $limit = null, string $contentType = self::contentTypes['listNetPaySplits'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListNetPaySplits200ResponseInner[]';
        $request = $this->listNetPaySplitsRequest($employee, $contractor, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listNetPaySplits'
     *
     * @param  string $employee ID of the employee whose net pay splits should be listed (optional)
     * @param  string $contractor ID of the contractor whose net pay split should be listed (optional)
     * @param  int $limit Number of net pay splits returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listNetPaySplits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listNetPaySplitsRequest($employee = null, $contractor = null, $limit = null, string $contentType = self::contentTypes['listNetPaySplits'][0])
    {





        $resourcePath = '/net_pay_splits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $employee,
            'employee', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contractor,
            'contractor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPaySchedules
     *
     * List pay schedules
     *
     * @param  string $company company (optional)
     * @param  int $limit Number of pay schedules returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaySchedules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAPaySchedule200Response[]|object
     */
    public function listPaySchedules($company = null, $limit = null, string $contentType = self::contentTypes['listPaySchedules'][0])
    {
        list($response) = $this->listPaySchedulesWithHttpInfo($company, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listPaySchedulesWithHttpInfo
     *
     * List pay schedules
     *
     * @param  string $company (optional)
     * @param  int $limit Number of pay schedules returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaySchedules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAPaySchedule200Response[]|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPaySchedulesWithHttpInfo($company = null, $limit = null, string $contentType = self::contentTypes['listPaySchedules'][0])
    {
        $request = $this->listPaySchedulesRequest($company, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAPaySchedule200Response[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAPaySchedule200Response[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAPaySchedule200Response[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetAPaySchedule200Response[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAPaySchedule200Response[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPaySchedulesAsync
     *
     * List pay schedules
     *
     * @param  string $company (optional)
     * @param  int $limit Number of pay schedules returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaySchedules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaySchedulesAsync($company = null, $limit = null, string $contentType = self::contentTypes['listPaySchedules'][0])
    {
        return $this->listPaySchedulesAsyncWithHttpInfo($company, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPaySchedulesAsyncWithHttpInfo
     *
     * List pay schedules
     *
     * @param  string $company (optional)
     * @param  int $limit Number of pay schedules returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaySchedules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaySchedulesAsyncWithHttpInfo($company = null, $limit = null, string $contentType = self::contentTypes['listPaySchedules'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetAPaySchedule200Response[]';
        $request = $this->listPaySchedulesRequest($company, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPaySchedules'
     *
     * @param  string $company (optional)
     * @param  int $limit Number of pay schedules returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaySchedules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPaySchedulesRequest($company = null, $limit = null, string $contentType = self::contentTypes['listPaySchedules'][0])
    {




        $resourcePath = '/pay_schedules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPayments
     *
     * List payments
     *
     * @param  string $payroll Return all payments, including debits and credits, related to a particular payroll ID (optional)
     * @param  string $payroll_item Return payments related to a particular parent payroll_item ID (optional)
     * @param  string $contractor_payment Return payments related to a particular parent contractor payment ID (optional)
     * @param  string $company Return payments related to a particular company ID (optional)
     * @param  string $direction Return payments with direction (optional)
     * @param  string $amount_min Return payments where amount ≥ an amount (optional)
     * @param  string $amount_max Return payments where amount ≤ an amount (optional)
     * @param  string $type Return payments with type (optional)
     * @param  \DateTime $completion_date_after Return payments whose expected completion date is on or after the specified date (optional)
     * @param  \DateTime $completion_date_before Return payments whose expected completion date is on or before the specified date (optional)
     * @param  int $limit Number of payments returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListPayments200Response|object
     */
    public function listPayments($payroll = null, $payroll_item = null, $contractor_payment = null, $company = null, $direction = null, $amount_min = null, $amount_max = null, $type = null, $completion_date_after = null, $completion_date_before = null, $limit = null, string $contentType = self::contentTypes['listPayments'][0])
    {
        list($response) = $this->listPaymentsWithHttpInfo($payroll, $payroll_item, $contractor_payment, $company, $direction, $amount_min, $amount_max, $type, $completion_date_after, $completion_date_before, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listPaymentsWithHttpInfo
     *
     * List payments
     *
     * @param  string $payroll Return all payments, including debits and credits, related to a particular payroll ID (optional)
     * @param  string $payroll_item Return payments related to a particular parent payroll_item ID (optional)
     * @param  string $contractor_payment Return payments related to a particular parent contractor payment ID (optional)
     * @param  string $company Return payments related to a particular company ID (optional)
     * @param  string $direction Return payments with direction (optional)
     * @param  string $amount_min Return payments where amount ≥ an amount (optional)
     * @param  string $amount_max Return payments where amount ≤ an amount (optional)
     * @param  string $type Return payments with type (optional)
     * @param  \DateTime $completion_date_after Return payments whose expected completion date is on or after the specified date (optional)
     * @param  \DateTime $completion_date_before Return payments whose expected completion date is on or before the specified date (optional)
     * @param  int $limit Number of payments returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListPayments200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPaymentsWithHttpInfo($payroll = null, $payroll_item = null, $contractor_payment = null, $company = null, $direction = null, $amount_min = null, $amount_max = null, $type = null, $completion_date_after = null, $completion_date_before = null, $limit = null, string $contentType = self::contentTypes['listPayments'][0])
    {
        $request = $this->listPaymentsRequest($payroll, $payroll_item, $contractor_payment, $company, $direction, $amount_min, $amount_max, $type, $completion_date_after, $completion_date_before, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListPayments200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListPayments200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListPayments200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListPayments200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListPayments200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPaymentsAsync
     *
     * List payments
     *
     * @param  string $payroll Return all payments, including debits and credits, related to a particular payroll ID (optional)
     * @param  string $payroll_item Return payments related to a particular parent payroll_item ID (optional)
     * @param  string $contractor_payment Return payments related to a particular parent contractor payment ID (optional)
     * @param  string $company Return payments related to a particular company ID (optional)
     * @param  string $direction Return payments with direction (optional)
     * @param  string $amount_min Return payments where amount ≥ an amount (optional)
     * @param  string $amount_max Return payments where amount ≤ an amount (optional)
     * @param  string $type Return payments with type (optional)
     * @param  \DateTime $completion_date_after Return payments whose expected completion date is on or after the specified date (optional)
     * @param  \DateTime $completion_date_before Return payments whose expected completion date is on or before the specified date (optional)
     * @param  int $limit Number of payments returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaymentsAsync($payroll = null, $payroll_item = null, $contractor_payment = null, $company = null, $direction = null, $amount_min = null, $amount_max = null, $type = null, $completion_date_after = null, $completion_date_before = null, $limit = null, string $contentType = self::contentTypes['listPayments'][0])
    {
        return $this->listPaymentsAsyncWithHttpInfo($payroll, $payroll_item, $contractor_payment, $company, $direction, $amount_min, $amount_max, $type, $completion_date_after, $completion_date_before, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPaymentsAsyncWithHttpInfo
     *
     * List payments
     *
     * @param  string $payroll Return all payments, including debits and credits, related to a particular payroll ID (optional)
     * @param  string $payroll_item Return payments related to a particular parent payroll_item ID (optional)
     * @param  string $contractor_payment Return payments related to a particular parent contractor payment ID (optional)
     * @param  string $company Return payments related to a particular company ID (optional)
     * @param  string $direction Return payments with direction (optional)
     * @param  string $amount_min Return payments where amount ≥ an amount (optional)
     * @param  string $amount_max Return payments where amount ≤ an amount (optional)
     * @param  string $type Return payments with type (optional)
     * @param  \DateTime $completion_date_after Return payments whose expected completion date is on or after the specified date (optional)
     * @param  \DateTime $completion_date_before Return payments whose expected completion date is on or before the specified date (optional)
     * @param  int $limit Number of payments returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaymentsAsyncWithHttpInfo($payroll = null, $payroll_item = null, $contractor_payment = null, $company = null, $direction = null, $amount_min = null, $amount_max = null, $type = null, $completion_date_after = null, $completion_date_before = null, $limit = null, string $contentType = self::contentTypes['listPayments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListPayments200Response';
        $request = $this->listPaymentsRequest($payroll, $payroll_item, $contractor_payment, $company, $direction, $amount_min, $amount_max, $type, $completion_date_after, $completion_date_before, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPayments'
     *
     * @param  string $payroll Return all payments, including debits and credits, related to a particular payroll ID (optional)
     * @param  string $payroll_item Return payments related to a particular parent payroll_item ID (optional)
     * @param  string $contractor_payment Return payments related to a particular parent contractor payment ID (optional)
     * @param  string $company Return payments related to a particular company ID (optional)
     * @param  string $direction Return payments with direction (optional)
     * @param  string $amount_min Return payments where amount ≥ an amount (optional)
     * @param  string $amount_max Return payments where amount ≤ an amount (optional)
     * @param  string $type Return payments with type (optional)
     * @param  \DateTime $completion_date_after Return payments whose expected completion date is on or after the specified date (optional)
     * @param  \DateTime $completion_date_before Return payments whose expected completion date is on or before the specified date (optional)
     * @param  int $limit Number of payments returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPaymentsRequest($payroll = null, $payroll_item = null, $contractor_payment = null, $company = null, $direction = null, $amount_min = null, $amount_max = null, $type = null, $completion_date_after = null, $completion_date_before = null, $limit = null, string $contentType = self::contentTypes['listPayments'][0])
    {













        $resourcePath = '/payments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payroll,
            'payroll', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payroll_item,
            'payroll_item', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contractor_payment,
            'contractor_payment', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount_min,
            'amount_min', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount_max,
            'amount_max', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $completion_date_after,
            'completion_date_after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $completion_date_before,
            'completion_date_before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPaymentsCopy
     *
     * List tax filings
     *
     * @param  string $company Filter tax filings related to a particular company ID. (optional)
     * @param  int $year Filter tax filings within a given year (optional)
     * @param  string $period Filter tax filings within a particular period. One of:  &#x60;annual&#x60;, &#x60;q1&#x60;, &#x60;q2&#x60;,&#x60;q3&#x60;, &#x60;q4&#x60;, &#x60;january&#x60;, &#x60;february&#x60;, &#x60;march&#x60;, &#x60;april&#x60;, &#x60;may&#x60;, &#x60;june&#x60;, &#x60;july&#x60;, &#x60;august&#x60; , &#x60;september&#x60;, &#x60;october&#x60; , or &#x60;december&#x60;. (optional)
     * @param  int $limit Number of tax filings returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentsCopy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListPaymentsCopy200Response|object
     */
    public function listPaymentsCopy($company = null, $year = null, $period = null, $limit = null, string $contentType = self::contentTypes['listPaymentsCopy'][0])
    {
        list($response) = $this->listPaymentsCopyWithHttpInfo($company, $year, $period, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listPaymentsCopyWithHttpInfo
     *
     * List tax filings
     *
     * @param  string $company Filter tax filings related to a particular company ID. (optional)
     * @param  int $year Filter tax filings within a given year (optional)
     * @param  string $period Filter tax filings within a particular period. One of:  &#x60;annual&#x60;, &#x60;q1&#x60;, &#x60;q2&#x60;,&#x60;q3&#x60;, &#x60;q4&#x60;, &#x60;january&#x60;, &#x60;february&#x60;, &#x60;march&#x60;, &#x60;april&#x60;, &#x60;may&#x60;, &#x60;june&#x60;, &#x60;july&#x60;, &#x60;august&#x60; , &#x60;september&#x60;, &#x60;october&#x60; , or &#x60;december&#x60;. (optional)
     * @param  int $limit Number of tax filings returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentsCopy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListPaymentsCopy200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPaymentsCopyWithHttpInfo($company = null, $year = null, $period = null, $limit = null, string $contentType = self::contentTypes['listPaymentsCopy'][0])
    {
        $request = $this->listPaymentsCopyRequest($company, $year, $period, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListPaymentsCopy200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListPaymentsCopy200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListPaymentsCopy200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListPaymentsCopy200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListPaymentsCopy200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPaymentsCopyAsync
     *
     * List tax filings
     *
     * @param  string $company Filter tax filings related to a particular company ID. (optional)
     * @param  int $year Filter tax filings within a given year (optional)
     * @param  string $period Filter tax filings within a particular period. One of:  &#x60;annual&#x60;, &#x60;q1&#x60;, &#x60;q2&#x60;,&#x60;q3&#x60;, &#x60;q4&#x60;, &#x60;january&#x60;, &#x60;february&#x60;, &#x60;march&#x60;, &#x60;april&#x60;, &#x60;may&#x60;, &#x60;june&#x60;, &#x60;july&#x60;, &#x60;august&#x60; , &#x60;september&#x60;, &#x60;october&#x60; , or &#x60;december&#x60;. (optional)
     * @param  int $limit Number of tax filings returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentsCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaymentsCopyAsync($company = null, $year = null, $period = null, $limit = null, string $contentType = self::contentTypes['listPaymentsCopy'][0])
    {
        return $this->listPaymentsCopyAsyncWithHttpInfo($company, $year, $period, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPaymentsCopyAsyncWithHttpInfo
     *
     * List tax filings
     *
     * @param  string $company Filter tax filings related to a particular company ID. (optional)
     * @param  int $year Filter tax filings within a given year (optional)
     * @param  string $period Filter tax filings within a particular period. One of:  &#x60;annual&#x60;, &#x60;q1&#x60;, &#x60;q2&#x60;,&#x60;q3&#x60;, &#x60;q4&#x60;, &#x60;january&#x60;, &#x60;february&#x60;, &#x60;march&#x60;, &#x60;april&#x60;, &#x60;may&#x60;, &#x60;june&#x60;, &#x60;july&#x60;, &#x60;august&#x60; , &#x60;september&#x60;, &#x60;october&#x60; , or &#x60;december&#x60;. (optional)
     * @param  int $limit Number of tax filings returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentsCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaymentsCopyAsyncWithHttpInfo($company = null, $year = null, $period = null, $limit = null, string $contentType = self::contentTypes['listPaymentsCopy'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListPaymentsCopy200Response';
        $request = $this->listPaymentsCopyRequest($company, $year, $period, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPaymentsCopy'
     *
     * @param  string $company Filter tax filings related to a particular company ID. (optional)
     * @param  int $year Filter tax filings within a given year (optional)
     * @param  string $period Filter tax filings within a particular period. One of:  &#x60;annual&#x60;, &#x60;q1&#x60;, &#x60;q2&#x60;,&#x60;q3&#x60;, &#x60;q4&#x60;, &#x60;january&#x60;, &#x60;february&#x60;, &#x60;march&#x60;, &#x60;april&#x60;, &#x60;may&#x60;, &#x60;june&#x60;, &#x60;july&#x60;, &#x60;august&#x60; , &#x60;september&#x60;, &#x60;october&#x60; , or &#x60;december&#x60;. (optional)
     * @param  int $limit Number of tax filings returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentsCopy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPaymentsCopyRequest($company = null, $year = null, $period = null, $limit = null, string $contentType = self::contentTypes['listPaymentsCopy'][0])
    {






        $resourcePath = '/tax_filings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $year,
            'year', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPayrollItems
     *
     * List payroll items
     *
     * @param  string $payroll Return payroll_items for this [payroll](ref:payroll) ID. (optional)
     * @param  string $employee Return payroll_items for this employee ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayrollItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listPayrollItems($payroll = null, $employee = null, string $contentType = self::contentTypes['listPayrollItems'][0])
    {
        $this->listPayrollItemsWithHttpInfo($payroll, $employee, $contentType);
    }

    /**
     * Operation listPayrollItemsWithHttpInfo
     *
     * List payroll items
     *
     * @param  string $payroll Return payroll_items for this [payroll](ref:payroll) ID. (optional)
     * @param  string $employee Return payroll_items for this employee ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayrollItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPayrollItemsWithHttpInfo($payroll = null, $employee = null, string $contentType = self::contentTypes['listPayrollItems'][0])
    {
        $request = $this->listPayrollItemsRequest($payroll, $employee, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation listPayrollItemsAsync
     *
     * List payroll items
     *
     * @param  string $payroll Return payroll_items for this [payroll](ref:payroll) ID. (optional)
     * @param  string $employee Return payroll_items for this employee ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayrollItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPayrollItemsAsync($payroll = null, $employee = null, string $contentType = self::contentTypes['listPayrollItems'][0])
    {
        return $this->listPayrollItemsAsyncWithHttpInfo($payroll, $employee, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPayrollItemsAsyncWithHttpInfo
     *
     * List payroll items
     *
     * @param  string $payroll Return payroll_items for this [payroll](ref:payroll) ID. (optional)
     * @param  string $employee Return payroll_items for this employee ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayrollItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPayrollItemsAsyncWithHttpInfo($payroll = null, $employee = null, string $contentType = self::contentTypes['listPayrollItems'][0])
    {
        $returnType = '';
        $request = $this->listPayrollItemsRequest($payroll, $employee, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPayrollItems'
     *
     * @param  string $payroll Return payroll_items for this [payroll](ref:payroll) ID. (optional)
     * @param  string $employee Return payroll_items for this employee ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayrollItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPayrollItemsRequest($payroll = null, $employee = null, string $contentType = self::contentTypes['listPayrollItems'][0])
    {




        $resourcePath = '/payroll_items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payroll,
            'payroll', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $employee,
            'employee', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPayrolls
     *
     * List payrolls
     *
     * @param  string $company Return payrolls for this [company](ref:company) ID. (optional)
     * @param  string $type Return payrolls of this type.&lt;br&gt;&lt;br&gt;One of &#x60;regular&#x60; or &#x60;off_cycle&#x60;. (optional)
     * @param  bool $managed Return payrolls of this &#x60;managed&#x60; status. (optional)
     * @param  int $limit Number of payrolls returned per page (optional)
     * @param  string $payday_after Return payrolls whose payday is on or after the provided date (format: YYYY-MM-DD) (optional)
     * @param  string $payday_before Return payrolls whose payday is on or before the provided date (format: YYYY-MM-DD) (optional)
     * @param  string $status Return payrolls in a given status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayrolls'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListPayrolls200ResponseInner[]
     */
    public function listPayrolls($company = null, $type = null, $managed = null, $limit = null, $payday_after = null, $payday_before = null, $status = null, string $contentType = self::contentTypes['listPayrolls'][0])
    {
        list($response) = $this->listPayrollsWithHttpInfo($company, $type, $managed, $limit, $payday_after, $payday_before, $status, $contentType);
        return $response;
    }

    /**
     * Operation listPayrollsWithHttpInfo
     *
     * List payrolls
     *
     * @param  string $company Return payrolls for this [company](ref:company) ID. (optional)
     * @param  string $type Return payrolls of this type.&lt;br&gt;&lt;br&gt;One of &#x60;regular&#x60; or &#x60;off_cycle&#x60;. (optional)
     * @param  bool $managed Return payrolls of this &#x60;managed&#x60; status. (optional)
     * @param  int $limit Number of payrolls returned per page (optional)
     * @param  string $payday_after Return payrolls whose payday is on or after the provided date (format: YYYY-MM-DD) (optional)
     * @param  string $payday_before Return payrolls whose payday is on or before the provided date (format: YYYY-MM-DD) (optional)
     * @param  string $status Return payrolls in a given status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayrolls'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListPayrolls200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listPayrollsWithHttpInfo($company = null, $type = null, $managed = null, $limit = null, $payday_after = null, $payday_before = null, $status = null, string $contentType = self::contentTypes['listPayrolls'][0])
    {
        $request = $this->listPayrollsRequest($company, $type, $managed, $limit, $payday_after, $payday_before, $status, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListPayrolls200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListPayrolls200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListPayrolls200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListPayrolls200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListPayrolls200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPayrollsAsync
     *
     * List payrolls
     *
     * @param  string $company Return payrolls for this [company](ref:company) ID. (optional)
     * @param  string $type Return payrolls of this type.&lt;br&gt;&lt;br&gt;One of &#x60;regular&#x60; or &#x60;off_cycle&#x60;. (optional)
     * @param  bool $managed Return payrolls of this &#x60;managed&#x60; status. (optional)
     * @param  int $limit Number of payrolls returned per page (optional)
     * @param  string $payday_after Return payrolls whose payday is on or after the provided date (format: YYYY-MM-DD) (optional)
     * @param  string $payday_before Return payrolls whose payday is on or before the provided date (format: YYYY-MM-DD) (optional)
     * @param  string $status Return payrolls in a given status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayrolls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPayrollsAsync($company = null, $type = null, $managed = null, $limit = null, $payday_after = null, $payday_before = null, $status = null, string $contentType = self::contentTypes['listPayrolls'][0])
    {
        return $this->listPayrollsAsyncWithHttpInfo($company, $type, $managed, $limit, $payday_after, $payday_before, $status, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPayrollsAsyncWithHttpInfo
     *
     * List payrolls
     *
     * @param  string $company Return payrolls for this [company](ref:company) ID. (optional)
     * @param  string $type Return payrolls of this type.&lt;br&gt;&lt;br&gt;One of &#x60;regular&#x60; or &#x60;off_cycle&#x60;. (optional)
     * @param  bool $managed Return payrolls of this &#x60;managed&#x60; status. (optional)
     * @param  int $limit Number of payrolls returned per page (optional)
     * @param  string $payday_after Return payrolls whose payday is on or after the provided date (format: YYYY-MM-DD) (optional)
     * @param  string $payday_before Return payrolls whose payday is on or before the provided date (format: YYYY-MM-DD) (optional)
     * @param  string $status Return payrolls in a given status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayrolls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPayrollsAsyncWithHttpInfo($company = null, $type = null, $managed = null, $limit = null, $payday_after = null, $payday_before = null, $status = null, string $contentType = self::contentTypes['listPayrolls'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListPayrolls200ResponseInner[]';
        $request = $this->listPayrollsRequest($company, $type, $managed, $limit, $payday_after, $payday_before, $status, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPayrolls'
     *
     * @param  string $company Return payrolls for this [company](ref:company) ID. (optional)
     * @param  string $type Return payrolls of this type.&lt;br&gt;&lt;br&gt;One of &#x60;regular&#x60; or &#x60;off_cycle&#x60;. (optional)
     * @param  bool $managed Return payrolls of this &#x60;managed&#x60; status. (optional)
     * @param  int $limit Number of payrolls returned per page (optional)
     * @param  string $payday_after Return payrolls whose payday is on or after the provided date (format: YYYY-MM-DD) (optional)
     * @param  string $payday_before Return payrolls whose payday is on or before the provided date (format: YYYY-MM-DD) (optional)
     * @param  string $status Return payrolls in a given status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPayrolls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPayrollsRequest($company = null, $type = null, $managed = null, $limit = null, $payday_after = null, $payday_before = null, $status = null, string $contentType = self::contentTypes['listPayrolls'][0])
    {









        $resourcePath = '/payrolls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $managed,
            'managed', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payday_after,
            'payday_after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payday_before,
            'payday_before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPostTaxDeductions
     *
     * List post-tax deductions
     *
     * @param  string $employee Return post-tax deductions for this employee ID. (optional)
     * @param  string $company Return post-tax deductions for all employees of this company ID. (optional)
     * @param  int $limit Number of post-tax deductions returned per page. Note: this does not override standard pagination. (optional)
     * @param  bool $include_external Flag to indicate if to additionally expose external deductions in the list response. Defaults to false if not included (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPostTaxDeductions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function listPostTaxDeductions($employee = null, $company = null, $limit = null, $include_external = null, string $contentType = self::contentTypes['listPostTaxDeductions'][0])
    {
        list($response) = $this->listPostTaxDeductionsWithHttpInfo($employee, $company, $limit, $include_external, $contentType);
        return $response;
    }

    /**
     * Operation listPostTaxDeductionsWithHttpInfo
     *
     * List post-tax deductions
     *
     * @param  string $employee Return post-tax deductions for this employee ID. (optional)
     * @param  string $company Return post-tax deductions for all employees of this company ID. (optional)
     * @param  int $limit Number of post-tax deductions returned per page. Note: this does not override standard pagination. (optional)
     * @param  bool $include_external Flag to indicate if to additionally expose external deductions in the list response. Defaults to false if not included (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPostTaxDeductions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPostTaxDeductionsWithHttpInfo($employee = null, $company = null, $limit = null, $include_external = null, string $contentType = self::contentTypes['listPostTaxDeductions'][0])
    {
        $request = $this->listPostTaxDeductionsRequest($employee, $company, $limit, $include_external, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPostTaxDeductionsAsync
     *
     * List post-tax deductions
     *
     * @param  string $employee Return post-tax deductions for this employee ID. (optional)
     * @param  string $company Return post-tax deductions for all employees of this company ID. (optional)
     * @param  int $limit Number of post-tax deductions returned per page. Note: this does not override standard pagination. (optional)
     * @param  bool $include_external Flag to indicate if to additionally expose external deductions in the list response. Defaults to false if not included (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPostTaxDeductions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPostTaxDeductionsAsync($employee = null, $company = null, $limit = null, $include_external = null, string $contentType = self::contentTypes['listPostTaxDeductions'][0])
    {
        return $this->listPostTaxDeductionsAsyncWithHttpInfo($employee, $company, $limit, $include_external, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPostTaxDeductionsAsyncWithHttpInfo
     *
     * List post-tax deductions
     *
     * @param  string $employee Return post-tax deductions for this employee ID. (optional)
     * @param  string $company Return post-tax deductions for all employees of this company ID. (optional)
     * @param  int $limit Number of post-tax deductions returned per page. Note: this does not override standard pagination. (optional)
     * @param  bool $include_external Flag to indicate if to additionally expose external deductions in the list response. Defaults to false if not included (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPostTaxDeductions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPostTaxDeductionsAsyncWithHttpInfo($employee = null, $company = null, $limit = null, $include_external = null, string $contentType = self::contentTypes['listPostTaxDeductions'][0])
    {
        $returnType = 'object';
        $request = $this->listPostTaxDeductionsRequest($employee, $company, $limit, $include_external, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPostTaxDeductions'
     *
     * @param  string $employee Return post-tax deductions for this employee ID. (optional)
     * @param  string $company Return post-tax deductions for all employees of this company ID. (optional)
     * @param  int $limit Number of post-tax deductions returned per page. Note: this does not override standard pagination. (optional)
     * @param  bool $include_external Flag to indicate if to additionally expose external deductions in the list response. Defaults to false if not included (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPostTaxDeductions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPostTaxDeductionsRequest($employee = null, $company = null, $limit = null, $include_external = null, string $contentType = self::contentTypes['listPostTaxDeductions'][0])
    {






        $resourcePath = '/post_tax_deductions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $employee,
            'employee', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_external,
            'include_external', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listRequirements
     *
     * List requirements
     *
     * @param  string $category Filter by requirement categories (optional, default to 'company_provided_documents')
     * @param  string $requirement Filter by requirement names (optional, default to 'federal_ein_verification')
     * @param  string $status Filter by requirement statuses (optional, default to 'not_provided')
     * @param  string $company Filter by companies (optional, default to 'Company ID')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRequirements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListRequirements200Response|object
     */
    public function listRequirements($category = 'company_provided_documents', $requirement = 'federal_ein_verification', $status = 'not_provided', $company = 'Company ID', string $contentType = self::contentTypes['listRequirements'][0])
    {
        list($response) = $this->listRequirementsWithHttpInfo($category, $requirement, $status, $company, $contentType);
        return $response;
    }

    /**
     * Operation listRequirementsWithHttpInfo
     *
     * List requirements
     *
     * @param  string $category Filter by requirement categories (optional, default to 'company_provided_documents')
     * @param  string $requirement Filter by requirement names (optional, default to 'federal_ein_verification')
     * @param  string $status Filter by requirement statuses (optional, default to 'not_provided')
     * @param  string $company Filter by companies (optional, default to 'Company ID')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRequirements'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListRequirements200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listRequirementsWithHttpInfo($category = 'company_provided_documents', $requirement = 'federal_ein_verification', $status = 'not_provided', $company = 'Company ID', string $contentType = self::contentTypes['listRequirements'][0])
    {
        $request = $this->listRequirementsRequest($category, $requirement, $status, $company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListRequirements200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListRequirements200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListRequirements200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListRequirements200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListRequirements200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listRequirementsAsync
     *
     * List requirements
     *
     * @param  string $category Filter by requirement categories (optional, default to 'company_provided_documents')
     * @param  string $requirement Filter by requirement names (optional, default to 'federal_ein_verification')
     * @param  string $status Filter by requirement statuses (optional, default to 'not_provided')
     * @param  string $company Filter by companies (optional, default to 'Company ID')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRequirements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRequirementsAsync($category = 'company_provided_documents', $requirement = 'federal_ein_verification', $status = 'not_provided', $company = 'Company ID', string $contentType = self::contentTypes['listRequirements'][0])
    {
        return $this->listRequirementsAsyncWithHttpInfo($category, $requirement, $status, $company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listRequirementsAsyncWithHttpInfo
     *
     * List requirements
     *
     * @param  string $category Filter by requirement categories (optional, default to 'company_provided_documents')
     * @param  string $requirement Filter by requirement names (optional, default to 'federal_ein_verification')
     * @param  string $status Filter by requirement statuses (optional, default to 'not_provided')
     * @param  string $company Filter by companies (optional, default to 'Company ID')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRequirements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listRequirementsAsyncWithHttpInfo($category = 'company_provided_documents', $requirement = 'federal_ein_verification', $status = 'not_provided', $company = 'Company ID', string $contentType = self::contentTypes['listRequirements'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListRequirements200Response';
        $request = $this->listRequirementsRequest($category, $requirement, $status, $company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listRequirements'
     *
     * @param  string $category Filter by requirement categories (optional, default to 'company_provided_documents')
     * @param  string $requirement Filter by requirement names (optional, default to 'federal_ein_verification')
     * @param  string $status Filter by requirement statuses (optional, default to 'not_provided')
     * @param  string $company Filter by companies (optional, default to 'Company ID')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listRequirements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listRequirementsRequest($category = 'company_provided_documents', $requirement = 'federal_ein_verification', $status = 'not_provided', $company = 'Company ID', string $contentType = self::contentTypes['listRequirements'][0])
    {






        $resourcePath = '/requirements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requirement,
            'requirement', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listSetupDocuments
     *
     * List setup documents
     *
     * @param  string $company Company ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSetupDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function listSetupDocuments($company = null, string $contentType = self::contentTypes['listSetupDocuments'][0])
    {
        list($response) = $this->listSetupDocumentsWithHttpInfo($company, $contentType);
        return $response;
    }

    /**
     * Operation listSetupDocumentsWithHttpInfo
     *
     * List setup documents
     *
     * @param  string $company Company ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSetupDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSetupDocumentsWithHttpInfo($company = null, string $contentType = self::contentTypes['listSetupDocuments'][0])
    {
        $request = $this->listSetupDocumentsRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listSetupDocumentsAsync
     *
     * List setup documents
     *
     * @param  string $company Company ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSetupDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSetupDocumentsAsync($company = null, string $contentType = self::contentTypes['listSetupDocuments'][0])
    {
        return $this->listSetupDocumentsAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSetupDocumentsAsyncWithHttpInfo
     *
     * List setup documents
     *
     * @param  string $company Company ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSetupDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSetupDocumentsAsyncWithHttpInfo($company = null, string $contentType = self::contentTypes['listSetupDocuments'][0])
    {
        $returnType = 'object';
        $request = $this->listSetupDocumentsRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listSetupDocuments'
     *
     * @param  string $company Company ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listSetupDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listSetupDocumentsRequest($company = null, string $contentType = self::contentTypes['listSetupDocuments'][0])
    {



        $resourcePath = '/documents/setup_documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTaxDeposits
     *
     * List tax deposits
     *
     * @param  string $company ID of the company (required)
     * @param  \DateTime $payroll_payday_start Filter for tax deposits with payroll paydays on or after this day. (optional)
     * @param  \DateTime $payroll_payday_end Filter for tax deposits with payroll paydays before or on this day. (optional)
     * @param  string $accept Provide &#x60;text/csv&#x60; for a CSV response. (optional, default to 'application/json')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaxDeposits'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listTaxDeposits($company, $payroll_payday_start = null, $payroll_payday_end = null, $accept = 'application/json', string $contentType = self::contentTypes['listTaxDeposits'][0])
    {
        $this->listTaxDepositsWithHttpInfo($company, $payroll_payday_start, $payroll_payday_end, $accept, $contentType);
    }

    /**
     * Operation listTaxDepositsWithHttpInfo
     *
     * List tax deposits
     *
     * @param  string $company ID of the company (required)
     * @param  \DateTime $payroll_payday_start Filter for tax deposits with payroll paydays on or after this day. (optional)
     * @param  \DateTime $payroll_payday_end Filter for tax deposits with payroll paydays before or on this day. (optional)
     * @param  string $accept Provide &#x60;text/csv&#x60; for a CSV response. (optional, default to 'application/json')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaxDeposits'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTaxDepositsWithHttpInfo($company, $payroll_payday_start = null, $payroll_payday_end = null, $accept = 'application/json', string $contentType = self::contentTypes['listTaxDeposits'][0])
    {
        $request = $this->listTaxDepositsRequest($company, $payroll_payday_start, $payroll_payday_end, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listTaxDepositsAsync
     *
     * List tax deposits
     *
     * @param  string $company ID of the company (required)
     * @param  \DateTime $payroll_payday_start Filter for tax deposits with payroll paydays on or after this day. (optional)
     * @param  \DateTime $payroll_payday_end Filter for tax deposits with payroll paydays before or on this day. (optional)
     * @param  string $accept Provide &#x60;text/csv&#x60; for a CSV response. (optional, default to 'application/json')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaxDeposits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTaxDepositsAsync($company, $payroll_payday_start = null, $payroll_payday_end = null, $accept = 'application/json', string $contentType = self::contentTypes['listTaxDeposits'][0])
    {
        return $this->listTaxDepositsAsyncWithHttpInfo($company, $payroll_payday_start, $payroll_payday_end, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTaxDepositsAsyncWithHttpInfo
     *
     * List tax deposits
     *
     * @param  string $company ID of the company (required)
     * @param  \DateTime $payroll_payday_start Filter for tax deposits with payroll paydays on or after this day. (optional)
     * @param  \DateTime $payroll_payday_end Filter for tax deposits with payroll paydays before or on this day. (optional)
     * @param  string $accept Provide &#x60;text/csv&#x60; for a CSV response. (optional, default to 'application/json')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaxDeposits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTaxDepositsAsyncWithHttpInfo($company, $payroll_payday_start = null, $payroll_payday_end = null, $accept = 'application/json', string $contentType = self::contentTypes['listTaxDeposits'][0])
    {
        $returnType = '';
        $request = $this->listTaxDepositsRequest($company, $payroll_payday_start, $payroll_payday_end, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTaxDeposits'
     *
     * @param  string $company ID of the company (required)
     * @param  \DateTime $payroll_payday_start Filter for tax deposits with payroll paydays on or after this day. (optional)
     * @param  \DateTime $payroll_payday_end Filter for tax deposits with payroll paydays before or on this day. (optional)
     * @param  string $accept Provide &#x60;text/csv&#x60; for a CSV response. (optional, default to 'application/json')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTaxDeposits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listTaxDepositsRequest($company, $payroll_payday_start = null, $payroll_payday_end = null, $accept = 'application/json', string $contentType = self::contentTypes['listTaxDeposits'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling listTaxDeposits'
            );
        }





        $resourcePath = '/companies/{company}/tax_deposits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payroll_payday_start,
            'payroll_payday_start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payroll_payday_end,
            'payroll_payday_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUsageRecords
     *
     * List usage records
     *
     * @param  string $company company (optional)
     * @param  string $category category (optional)
     * @param  string $resource_type resource_type (optional)
     * @param  \DateTime $period_start period_start (optional)
     * @param  \DateTime $period_end period_end (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsageRecords'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListUsageRecords200Response
     */
    public function listUsageRecords($company = null, $category = null, $resource_type = null, $period_start = null, $period_end = null, string $contentType = self::contentTypes['listUsageRecords'][0])
    {
        list($response) = $this->listUsageRecordsWithHttpInfo($company, $category, $resource_type, $period_start, $period_end, $contentType);
        return $response;
    }

    /**
     * Operation listUsageRecordsWithHttpInfo
     *
     * List usage records
     *
     * @param  string $company (optional)
     * @param  string $category (optional)
     * @param  string $resource_type (optional)
     * @param  \DateTime $period_start (optional)
     * @param  \DateTime $period_end (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsageRecords'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListUsageRecords200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function listUsageRecordsWithHttpInfo($company = null, $category = null, $resource_type = null, $period_start = null, $period_end = null, string $contentType = self::contentTypes['listUsageRecords'][0])
    {
        $request = $this->listUsageRecordsRequest($company, $category, $resource_type, $period_start, $period_end, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListUsageRecords200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListUsageRecords200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListUsageRecords200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListUsageRecords200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListUsageRecords200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listUsageRecordsAsync
     *
     * List usage records
     *
     * @param  string $company (optional)
     * @param  string $category (optional)
     * @param  string $resource_type (optional)
     * @param  \DateTime $period_start (optional)
     * @param  \DateTime $period_end (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsageRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsageRecordsAsync($company = null, $category = null, $resource_type = null, $period_start = null, $period_end = null, string $contentType = self::contentTypes['listUsageRecords'][0])
    {
        return $this->listUsageRecordsAsyncWithHttpInfo($company, $category, $resource_type, $period_start, $period_end, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listUsageRecordsAsyncWithHttpInfo
     *
     * List usage records
     *
     * @param  string $company (optional)
     * @param  string $category (optional)
     * @param  string $resource_type (optional)
     * @param  \DateTime $period_start (optional)
     * @param  \DateTime $period_end (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsageRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsageRecordsAsyncWithHttpInfo($company = null, $category = null, $resource_type = null, $period_start = null, $period_end = null, string $contentType = self::contentTypes['listUsageRecords'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListUsageRecords200Response';
        $request = $this->listUsageRecordsRequest($company, $category, $resource_type, $period_start, $period_end, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listUsageRecords'
     *
     * @param  string $company (optional)
     * @param  string $category (optional)
     * @param  string $resource_type (optional)
     * @param  \DateTime $period_start (optional)
     * @param  \DateTime $period_end (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsageRecords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listUsageRecordsRequest($company = null, $category = null, $resource_type = null, $period_start = null, $period_end = null, string $contentType = self::contentTypes['listUsageRecords'][0])
    {







        $resourcePath = '/usage/records';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resource_type,
            'resource_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period_start,
            'period_start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period_end,
            'period_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUsageSummaries
     *
     * List usage summaries
     *
     * @param  string $company company (optional)
     * @param  string $category category (optional)
     * @param  \DateTime $period_start period_start (optional)
     * @param  \DateTime $period_end period_end (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsageSummaries'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListUsageSummaries200Response
     */
    public function listUsageSummaries($company = null, $category = null, $period_start = null, $period_end = null, string $contentType = self::contentTypes['listUsageSummaries'][0])
    {
        list($response) = $this->listUsageSummariesWithHttpInfo($company, $category, $period_start, $period_end, $contentType);
        return $response;
    }

    /**
     * Operation listUsageSummariesWithHttpInfo
     *
     * List usage summaries
     *
     * @param  string $company (optional)
     * @param  string $category (optional)
     * @param  \DateTime $period_start (optional)
     * @param  \DateTime $period_end (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsageSummaries'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListUsageSummaries200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function listUsageSummariesWithHttpInfo($company = null, $category = null, $period_start = null, $period_end = null, string $contentType = self::contentTypes['listUsageSummaries'][0])
    {
        $request = $this->listUsageSummariesRequest($company, $category, $period_start, $period_end, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListUsageSummaries200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListUsageSummaries200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListUsageSummaries200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListUsageSummaries200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListUsageSummaries200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listUsageSummariesAsync
     *
     * List usage summaries
     *
     * @param  string $company (optional)
     * @param  string $category (optional)
     * @param  \DateTime $period_start (optional)
     * @param  \DateTime $period_end (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsageSummaries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsageSummariesAsync($company = null, $category = null, $period_start = null, $period_end = null, string $contentType = self::contentTypes['listUsageSummaries'][0])
    {
        return $this->listUsageSummariesAsyncWithHttpInfo($company, $category, $period_start, $period_end, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listUsageSummariesAsyncWithHttpInfo
     *
     * List usage summaries
     *
     * @param  string $company (optional)
     * @param  string $category (optional)
     * @param  \DateTime $period_start (optional)
     * @param  \DateTime $period_end (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsageSummaries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listUsageSummariesAsyncWithHttpInfo($company = null, $category = null, $period_start = null, $period_end = null, string $contentType = self::contentTypes['listUsageSummaries'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListUsageSummaries200Response';
        $request = $this->listUsageSummariesRequest($company, $category, $period_start, $period_end, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listUsageSummaries'
     *
     * @param  string $company (optional)
     * @param  string $category (optional)
     * @param  \DateTime $period_start (optional)
     * @param  \DateTime $period_end (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsageSummaries'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listUsageSummariesRequest($company = null, $category = null, $period_start = null, $period_end = null, string $contentType = self::contentTypes['listUsageSummaries'][0])
    {






        $resourcePath = '/usage/summaries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category,
            'category', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period_start,
            'period_start', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period_end,
            'period_end', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWorkplaces
     *
     * List workplaces
     *
     * @param  string $company Return workplaces for this company ID. (optional)
     * @param  int $limit Number of workplaces returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWorkplaces'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListWorkplaces200ResponseInner[]
     */
    public function listWorkplaces($company = null, $limit = null, string $contentType = self::contentTypes['listWorkplaces'][0])
    {
        list($response) = $this->listWorkplacesWithHttpInfo($company, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listWorkplacesWithHttpInfo
     *
     * List workplaces
     *
     * @param  string $company Return workplaces for this company ID. (optional)
     * @param  int $limit Number of workplaces returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWorkplaces'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListWorkplaces200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listWorkplacesWithHttpInfo($company = null, $limit = null, string $contentType = self::contentTypes['listWorkplaces'][0])
    {
        $request = $this->listWorkplacesRequest($company, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListWorkplaces200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListWorkplaces200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listWorkplacesAsync
     *
     * List workplaces
     *
     * @param  string $company Return workplaces for this company ID. (optional)
     * @param  int $limit Number of workplaces returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWorkplaces'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWorkplacesAsync($company = null, $limit = null, string $contentType = self::contentTypes['listWorkplaces'][0])
    {
        return $this->listWorkplacesAsyncWithHttpInfo($company, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWorkplacesAsyncWithHttpInfo
     *
     * List workplaces
     *
     * @param  string $company Return workplaces for this company ID. (optional)
     * @param  int $limit Number of workplaces returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWorkplaces'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWorkplacesAsyncWithHttpInfo($company = null, $limit = null, string $contentType = self::contentTypes['listWorkplaces'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner[]';
        $request = $this->listWorkplacesRequest($company, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listWorkplaces'
     *
     * @param  string $company Return workplaces for this company ID. (optional)
     * @param  int $limit Number of workplaces returned per page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWorkplaces'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listWorkplacesRequest($company = null, $limit = null, string $contentType = self::contentTypes['listWorkplaces'][0])
    {




        $resourcePath = '/workplaces';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pingAWebhookConfig
     *
     * Ping a webhook config
     *
     * @param  string $webhook_config webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pingAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function pingAWebhookConfig($webhook_config, string $contentType = self::contentTypes['pingAWebhookConfig'][0])
    {
        list($response) = $this->pingAWebhookConfigWithHttpInfo($webhook_config, $contentType);
        return $response;
    }

    /**
     * Operation pingAWebhookConfigWithHttpInfo
     *
     * Ping a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pingAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function pingAWebhookConfigWithHttpInfo($webhook_config, string $contentType = self::contentTypes['pingAWebhookConfig'][0])
    {
        $request = $this->pingAWebhookConfigRequest($webhook_config, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pingAWebhookConfigAsync
     *
     * Ping a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pingAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pingAWebhookConfigAsync($webhook_config, string $contentType = self::contentTypes['pingAWebhookConfig'][0])
    {
        return $this->pingAWebhookConfigAsyncWithHttpInfo($webhook_config, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pingAWebhookConfigAsyncWithHttpInfo
     *
     * Ping a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pingAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pingAWebhookConfigAsyncWithHttpInfo($webhook_config, string $contentType = self::contentTypes['pingAWebhookConfig'][0])
    {
        $returnType = 'object';
        $request = $this->pingAWebhookConfigRequest($webhook_config, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pingAWebhookConfig'
     *
     * @param  string $webhook_config (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pingAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pingAWebhookConfigRequest($webhook_config, string $contentType = self::contentTypes['pingAWebhookConfig'][0])
    {

        // verify the required parameter 'webhook_config' is set
        if ($webhook_config === null || (is_array($webhook_config) && count($webhook_config) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_config when calling pingAWebhookConfig'
            );
        }


        $resourcePath = '/webhook_configs/{webhook_config}/ping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_config !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_config' . '}',
                ObjectSerializer::toPathValue($webhook_config),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation previewPayroll
     *
     * Preview a payroll
     *
     * @param  string $payroll ID of the payroll to preview. (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $item ID of a payroll item to preview instead of the whole payroll. Multiple of this param may be passed to preview multiple items. *Please note that concurrent requests to this endpoint for the same payroll will complete sequentially.* (optional)
     * @param  string $include_contractors include_contractors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetPayroll200Response
     */
    public function previewPayroll($payroll, $accept = null, $item = null, $include_contractors = null, string $contentType = self::contentTypes['previewPayroll'][0])
    {
        list($response) = $this->previewPayrollWithHttpInfo($payroll, $accept, $item, $include_contractors, $contentType);
        return $response;
    }

    /**
     * Operation previewPayrollWithHttpInfo
     *
     * Preview a payroll
     *
     * @param  string $payroll ID of the payroll to preview. (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $item ID of a payroll item to preview instead of the whole payroll. Multiple of this param may be passed to preview multiple items. *Please note that concurrent requests to this endpoint for the same payroll will complete sequentially.* (optional)
     * @param  string $include_contractors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetPayroll200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function previewPayrollWithHttpInfo($payroll, $accept = null, $item = null, $include_contractors = null, string $contentType = self::contentTypes['previewPayroll'][0])
    {
        $request = $this->previewPayrollRequest($payroll, $accept, $item, $include_contractors, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetPayroll200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetPayroll200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetPayroll200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetPayroll200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetPayroll200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation previewPayrollAsync
     *
     * Preview a payroll
     *
     * @param  string $payroll ID of the payroll to preview. (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $item ID of a payroll item to preview instead of the whole payroll. Multiple of this param may be passed to preview multiple items. *Please note that concurrent requests to this endpoint for the same payroll will complete sequentially.* (optional)
     * @param  string $include_contractors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function previewPayrollAsync($payroll, $accept = null, $item = null, $include_contractors = null, string $contentType = self::contentTypes['previewPayroll'][0])
    {
        return $this->previewPayrollAsyncWithHttpInfo($payroll, $accept, $item, $include_contractors, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation previewPayrollAsyncWithHttpInfo
     *
     * Preview a payroll
     *
     * @param  string $payroll ID of the payroll to preview. (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $item ID of a payroll item to preview instead of the whole payroll. Multiple of this param may be passed to preview multiple items. *Please note that concurrent requests to this endpoint for the same payroll will complete sequentially.* (optional)
     * @param  string $include_contractors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function previewPayrollAsyncWithHttpInfo($payroll, $accept = null, $item = null, $include_contractors = null, string $contentType = self::contentTypes['previewPayroll'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetPayroll200Response';
        $request = $this->previewPayrollRequest($payroll, $accept, $item, $include_contractors, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'previewPayroll'
     *
     * @param  string $payroll ID of the payroll to preview. (required)
     * @param  string $accept Either &#x60;application/json&#x60; or &#x60;text/csv&#x60; (optional)
     * @param  string $item ID of a payroll item to preview instead of the whole payroll. Multiple of this param may be passed to preview multiple items. *Please note that concurrent requests to this endpoint for the same payroll will complete sequentially.* (optional)
     * @param  string $include_contractors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function previewPayrollRequest($payroll, $accept = null, $item = null, $include_contractors = null, string $contentType = self::contentTypes['previewPayroll'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling previewPayroll'
            );
        }





        $resourcePath = '/payrolls/{payroll}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item,
            'item', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_contractors,
            'include_contractors', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation previousPayrollProviderAccess
     *
     * Company Previous Payroll Provider Access
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previousPayrollProviderAccess'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object
     */
    public function previousPayrollProviderAccess($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['previousPayrollProviderAccess'][0])
    {
        list($response) = $this->previousPayrollProviderAccessWithHttpInfo($company, $generate_onboard_link_request, $contentType);
        return $response;
    }

    /**
     * Operation previousPayrollProviderAccessWithHttpInfo
     *
     * Company Previous Payroll Provider Access
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previousPayrollProviderAccess'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GenerateOnboardLink1200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function previousPayrollProviderAccessWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['previousPayrollProviderAccess'][0])
    {
        $request = $this->previousPayrollProviderAccessRequest($company, $generate_onboard_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GenerateOnboardLink1200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GenerateOnboardLink1200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GenerateOnboardLink1200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation previousPayrollProviderAccessAsync
     *
     * Company Previous Payroll Provider Access
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previousPayrollProviderAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function previousPayrollProviderAccessAsync($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['previousPayrollProviderAccess'][0])
    {
        return $this->previousPayrollProviderAccessAsyncWithHttpInfo($company, $generate_onboard_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation previousPayrollProviderAccessAsyncWithHttpInfo
     *
     * Company Previous Payroll Provider Access
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previousPayrollProviderAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function previousPayrollProviderAccessAsyncWithHttpInfo($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['previousPayrollProviderAccess'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GenerateOnboardLink1200Response';
        $request = $this->previousPayrollProviderAccessRequest($company, $generate_onboard_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'previousPayrollProviderAccess'
     *
     * @param  string $company ID of the company for which an onboard link will be generated (required)
     * @param  \OpenAPI\Client\Model\GenerateOnboardLinkRequest $generate_onboard_link_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previousPayrollProviderAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function previousPayrollProviderAccessRequest($company, $generate_onboard_link_request = null, string $contentType = self::contentTypes['previousPayrollProviderAccess'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling previousPayrollProviderAccess'
            );
        }



        $resourcePath = '/companies/{company}/components/previous_provider_access';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($generate_onboard_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($generate_onboard_link_request));
            } else {
                $httpBody = $generate_onboard_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation refundAPayment
     *
     * Refund a payment
     *
     * @param  string $payment ID of payment desired for refund (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundAPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function refundAPayment($payment, string $contentType = self::contentTypes['refundAPayment'][0])
    {
        $this->refundAPaymentWithHttpInfo($payment, $contentType);
    }

    /**
     * Operation refundAPaymentWithHttpInfo
     *
     * Refund a payment
     *
     * @param  string $payment ID of payment desired for refund (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundAPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function refundAPaymentWithHttpInfo($payment, string $contentType = self::contentTypes['refundAPayment'][0])
    {
        $request = $this->refundAPaymentRequest($payment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation refundAPaymentAsync
     *
     * Refund a payment
     *
     * @param  string $payment ID of payment desired for refund (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refundAPaymentAsync($payment, string $contentType = self::contentTypes['refundAPayment'][0])
    {
        return $this->refundAPaymentAsyncWithHttpInfo($payment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refundAPaymentAsyncWithHttpInfo
     *
     * Refund a payment
     *
     * @param  string $payment ID of payment desired for refund (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refundAPaymentAsyncWithHttpInfo($payment, string $contentType = self::contentTypes['refundAPayment'][0])
    {
        $returnType = '';
        $request = $this->refundAPaymentRequest($payment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refundAPayment'
     *
     * @param  string $payment ID of payment desired for refund (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refundAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refundAPaymentRequest($payment, string $contentType = self::contentTypes['refundAPayment'][0])
    {

        // verify the required parameter 'payment' is set
        if ($payment === null || (is_array($payment) && count($payment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment when calling refundAPayment'
            );
        }


        $resourcePath = '/payments/{payment}/refund';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment !== null) {
            $resourcePath = str_replace(
                '{' . 'payment' . '}',
                ObjectSerializer::toPathValue($payment),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renderAForm
     *
     * Render a form
     *
     * @param  string $form form (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  \OpenAPI\Client\Model\RenderAFormRequest $render_a_form_request render_a_form_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renderAForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function renderAForm($form, $accept = null, $render_a_form_request = null, string $contentType = self::contentTypes['renderAForm'][0])
    {
        list($response) = $this->renderAFormWithHttpInfo($form, $accept, $render_a_form_request, $contentType);
        return $response;
    }

    /**
     * Operation renderAFormWithHttpInfo
     *
     * Render a form
     *
     * @param  string $form (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  \OpenAPI\Client\Model\RenderAFormRequest $render_a_form_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renderAForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function renderAFormWithHttpInfo($form, $accept = null, $render_a_form_request = null, string $contentType = self::contentTypes['renderAForm'][0])
    {
        $request = $this->renderAFormRequest($form, $accept, $render_a_form_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation renderAFormAsync
     *
     * Render a form
     *
     * @param  string $form (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  \OpenAPI\Client\Model\RenderAFormRequest $render_a_form_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renderAForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderAFormAsync($form, $accept = null, $render_a_form_request = null, string $contentType = self::contentTypes['renderAForm'][0])
    {
        return $this->renderAFormAsyncWithHttpInfo($form, $accept, $render_a_form_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renderAFormAsyncWithHttpInfo
     *
     * Render a form
     *
     * @param  string $form (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  \OpenAPI\Client\Model\RenderAFormRequest $render_a_form_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renderAForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderAFormAsyncWithHttpInfo($form, $accept = null, $render_a_form_request = null, string $contentType = self::contentTypes['renderAForm'][0])
    {
        $returnType = 'object';
        $request = $this->renderAFormRequest($form, $accept, $render_a_form_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renderAForm'
     *
     * @param  string $form (required)
     * @param  string $accept Either &#x60;application/pdf&#x60; or &#x60;application/json&#x60; (optional)
     * @param  \OpenAPI\Client\Model\RenderAFormRequest $render_a_form_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renderAForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function renderAFormRequest($form, $accept = null, $render_a_form_request = null, string $contentType = self::contentTypes['renderAForm'][0])
    {

        // verify the required parameter 'form' is set
        if ($form === null || (is_array($form) && count($form) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $form when calling renderAForm'
            );
        }




        $resourcePath = '/forms/{form}/render';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($form !== null) {
            $resourcePath = str_replace(
                '{' . 'form' . '}',
                ObjectSerializer::toPathValue($form),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($render_a_form_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($render_a_form_request));
            } else {
                $httpBody = $render_a_form_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reopenAPendingPayroll
     *
     * Reopen an external payroll
     *
     * @param  string $payroll ID of the payroll to reopen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenAPendingPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reopenAPendingPayroll($payroll, string $contentType = self::contentTypes['reopenAPendingPayroll'][0])
    {
        $this->reopenAPendingPayrollWithHttpInfo($payroll, $contentType);
    }

    /**
     * Operation reopenAPendingPayrollWithHttpInfo
     *
     * Reopen an external payroll
     *
     * @param  string $payroll ID of the payroll to reopen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenAPendingPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reopenAPendingPayrollWithHttpInfo($payroll, string $contentType = self::contentTypes['reopenAPendingPayroll'][0])
    {
        $request = $this->reopenAPendingPayrollRequest($payroll, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reopenAPendingPayrollAsync
     *
     * Reopen an external payroll
     *
     * @param  string $payroll ID of the payroll to reopen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenAPendingPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reopenAPendingPayrollAsync($payroll, string $contentType = self::contentTypes['reopenAPendingPayroll'][0])
    {
        return $this->reopenAPendingPayrollAsyncWithHttpInfo($payroll, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reopenAPendingPayrollAsyncWithHttpInfo
     *
     * Reopen an external payroll
     *
     * @param  string $payroll ID of the payroll to reopen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenAPendingPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reopenAPendingPayrollAsyncWithHttpInfo($payroll, string $contentType = self::contentTypes['reopenAPendingPayroll'][0])
    {
        $returnType = '';
        $request = $this->reopenAPendingPayrollRequest($payroll, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reopenAPendingPayroll'
     *
     * @param  string $payroll ID of the payroll to reopen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenAPendingPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reopenAPendingPayrollRequest($payroll, string $contentType = self::contentTypes['reopenAPendingPayroll'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling reopenAPendingPayroll'
            );
        }


        $resourcePath = '/external_payrolls/{payroll}/reopen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reopenPayroll
     *
     * Reopen a pending payroll
     *
     * @param  string $payroll ID of the payroll to reopen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reopenPayroll($payroll, string $contentType = self::contentTypes['reopenPayroll'][0])
    {
        $this->reopenPayrollWithHttpInfo($payroll, $contentType);
    }

    /**
     * Operation reopenPayrollWithHttpInfo
     *
     * Reopen a pending payroll
     *
     * @param  string $payroll ID of the payroll to reopen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reopenPayrollWithHttpInfo($payroll, string $contentType = self::contentTypes['reopenPayroll'][0])
    {
        $request = $this->reopenPayrollRequest($payroll, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reopenPayrollAsync
     *
     * Reopen a pending payroll
     *
     * @param  string $payroll ID of the payroll to reopen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reopenPayrollAsync($payroll, string $contentType = self::contentTypes['reopenPayroll'][0])
    {
        return $this->reopenPayrollAsyncWithHttpInfo($payroll, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reopenPayrollAsyncWithHttpInfo
     *
     * Reopen a pending payroll
     *
     * @param  string $payroll ID of the payroll to reopen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reopenPayrollAsyncWithHttpInfo($payroll, string $contentType = self::contentTypes['reopenPayroll'][0])
    {
        $returnType = '';
        $request = $this->reopenPayrollRequest($payroll, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reopenPayroll'
     *
     * @param  string $payroll ID of the payroll to reopen (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reopenPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reopenPayrollRequest($payroll, string $contentType = self::contentTypes['reopenPayroll'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling reopenPayroll'
            );
        }


        $resourcePath = '/payrolls/{payroll}/reopen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation requestEmbeddedSetup
     *
     * Request Embedded Setup
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestEmbeddedSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\RequestEmbeddedSetup400Response
     */
    public function requestEmbeddedSetup(string $contentType = self::contentTypes['requestEmbeddedSetup'][0])
    {
        list($response) = $this->requestEmbeddedSetupWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation requestEmbeddedSetupWithHttpInfo
     *
     * Request Embedded Setup
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestEmbeddedSetup'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\RequestEmbeddedSetup400Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function requestEmbeddedSetupWithHttpInfo(string $contentType = self::contentTypes['requestEmbeddedSetup'][0])
    {
        $request = $this->requestEmbeddedSetupRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\RequestEmbeddedSetup400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RequestEmbeddedSetup400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RequestEmbeddedSetup400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RequestEmbeddedSetup400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation requestEmbeddedSetupAsync
     *
     * Request Embedded Setup
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestEmbeddedSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestEmbeddedSetupAsync(string $contentType = self::contentTypes['requestEmbeddedSetup'][0])
    {
        return $this->requestEmbeddedSetupAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation requestEmbeddedSetupAsyncWithHttpInfo
     *
     * Request Embedded Setup
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestEmbeddedSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function requestEmbeddedSetupAsyncWithHttpInfo(string $contentType = self::contentTypes['requestEmbeddedSetup'][0])
    {
        $returnType = 'object';
        $request = $this->requestEmbeddedSetupRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'requestEmbeddedSetup'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['requestEmbeddedSetup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function requestEmbeddedSetupRequest(string $contentType = self::contentTypes['requestEmbeddedSetup'][0])
    {


        $resourcePath = '/companies/{company_id}/request_embedded_setup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retryAPayment
     *
     * Retry a payment
     *
     * @param  string $payment ID of the payment desired for retry. (required)
     * @param  \OpenAPI\Client\Model\RetryAPaymentRequest $retry_a_payment_request retry_a_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retryAPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RetryAPayment200Response|object
     */
    public function retryAPayment($payment, $retry_a_payment_request = null, string $contentType = self::contentTypes['retryAPayment'][0])
    {
        list($response) = $this->retryAPaymentWithHttpInfo($payment, $retry_a_payment_request, $contentType);
        return $response;
    }

    /**
     * Operation retryAPaymentWithHttpInfo
     *
     * Retry a payment
     *
     * @param  string $payment ID of the payment desired for retry. (required)
     * @param  \OpenAPI\Client\Model\RetryAPaymentRequest $retry_a_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retryAPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RetryAPayment200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function retryAPaymentWithHttpInfo($payment, $retry_a_payment_request = null, string $contentType = self::contentTypes['retryAPayment'][0])
    {
        $request = $this->retryAPaymentRequest($payment, $retry_a_payment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RetryAPayment200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RetryAPayment200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RetryAPayment200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\RetryAPayment200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RetryAPayment200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retryAPaymentAsync
     *
     * Retry a payment
     *
     * @param  string $payment ID of the payment desired for retry. (required)
     * @param  \OpenAPI\Client\Model\RetryAPaymentRequest $retry_a_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retryAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retryAPaymentAsync($payment, $retry_a_payment_request = null, string $contentType = self::contentTypes['retryAPayment'][0])
    {
        return $this->retryAPaymentAsyncWithHttpInfo($payment, $retry_a_payment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retryAPaymentAsyncWithHttpInfo
     *
     * Retry a payment
     *
     * @param  string $payment ID of the payment desired for retry. (required)
     * @param  \OpenAPI\Client\Model\RetryAPaymentRequest $retry_a_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retryAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retryAPaymentAsyncWithHttpInfo($payment, $retry_a_payment_request = null, string $contentType = self::contentTypes['retryAPayment'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RetryAPayment200Response';
        $request = $this->retryAPaymentRequest($payment, $retry_a_payment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retryAPayment'
     *
     * @param  string $payment ID of the payment desired for retry. (required)
     * @param  \OpenAPI\Client\Model\RetryAPaymentRequest $retry_a_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retryAPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function retryAPaymentRequest($payment, $retry_a_payment_request = null, string $contentType = self::contentTypes['retryAPayment'][0])
    {

        // verify the required parameter 'payment' is set
        if ($payment === null || (is_array($payment) && count($payment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment when calling retryAPayment'
            );
        }



        $resourcePath = '/payments/{payment}/retry';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment !== null) {
            $resourcePath = str_replace(
                '{' . 'payment' . '}',
                ObjectSerializer::toPathValue($payment),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($retry_a_payment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($retry_a_payment_request));
            } else {
                $httpBody = $retry_a_payment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retryWebhookEventsInSandbox
     *
     * Retry webhook event in sandbox
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retryWebhookEventsInSandbox'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function retryWebhookEventsInSandbox(string $contentType = self::contentTypes['retryWebhookEventsInSandbox'][0])
    {
        $this->retryWebhookEventsInSandboxWithHttpInfo($contentType);
    }

    /**
     * Operation retryWebhookEventsInSandboxWithHttpInfo
     *
     * Retry webhook event in sandbox
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retryWebhookEventsInSandbox'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function retryWebhookEventsInSandboxWithHttpInfo(string $contentType = self::contentTypes['retryWebhookEventsInSandbox'][0])
    {
        $request = $this->retryWebhookEventsInSandboxRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RetryWebhookEventsInSandbox400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retryWebhookEventsInSandboxAsync
     *
     * Retry webhook event in sandbox
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retryWebhookEventsInSandbox'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retryWebhookEventsInSandboxAsync(string $contentType = self::contentTypes['retryWebhookEventsInSandbox'][0])
    {
        return $this->retryWebhookEventsInSandboxAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retryWebhookEventsInSandboxAsyncWithHttpInfo
     *
     * Retry webhook event in sandbox
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retryWebhookEventsInSandbox'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retryWebhookEventsInSandboxAsyncWithHttpInfo(string $contentType = self::contentTypes['retryWebhookEventsInSandbox'][0])
    {
        $returnType = '';
        $request = $this->retryWebhookEventsInSandboxRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retryWebhookEventsInSandbox'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retryWebhookEventsInSandbox'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function retryWebhookEventsInSandboxRequest(string $contentType = self::contentTypes['retryWebhookEventsInSandbox'][0])
    {


        $resourcePath = '/webhook_events/{webhook_id}/retry';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation runPayroll
     *
     * Run Payroll
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $payroll ID of the payroll. This launches the component directly in edit view. In order to do this, the payroll needs to be formatted in a way the Run Payroll Component expects with a single earning rate tied to hourly or salaried earnings in the payroll item. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['runPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmployeePaystub200Response|object
     */
    public function runPayroll($company, $payroll = null, string $contentType = self::contentTypes['runPayroll'][0])
    {
        list($response) = $this->runPayrollWithHttpInfo($company, $payroll, $contentType);
        return $response;
    }

    /**
     * Operation runPayrollWithHttpInfo
     *
     * Run Payroll
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $payroll ID of the payroll. This launches the component directly in edit view. In order to do this, the payroll needs to be formatted in a way the Run Payroll Component expects with a single earning rate tied to hourly or salaried earnings in the payroll item. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['runPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmployeePaystub200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function runPayrollWithHttpInfo($company, $payroll = null, string $contentType = self::contentTypes['runPayroll'][0])
    {
        $request = $this->runPayrollRequest($company, $payroll, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmployeePaystub200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmployeePaystub200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmployeePaystub200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmployeePaystub200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation runPayrollAsync
     *
     * Run Payroll
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $payroll ID of the payroll. This launches the component directly in edit view. In order to do this, the payroll needs to be formatted in a way the Run Payroll Component expects with a single earning rate tied to hourly or salaried earnings in the payroll item. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['runPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runPayrollAsync($company, $payroll = null, string $contentType = self::contentTypes['runPayroll'][0])
    {
        return $this->runPayrollAsyncWithHttpInfo($company, $payroll, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation runPayrollAsyncWithHttpInfo
     *
     * Run Payroll
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $payroll ID of the payroll. This launches the component directly in edit view. In order to do this, the payroll needs to be formatted in a way the Run Payroll Component expects with a single earning rate tied to hourly or salaried earnings in the payroll item. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['runPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runPayrollAsyncWithHttpInfo($company, $payroll = null, string $contentType = self::contentTypes['runPayroll'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmployeePaystub200Response';
        $request = $this->runPayrollRequest($company, $payroll, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'runPayroll'
     *
     * @param  string $company ID of the company for which a component link will be generated (required)
     * @param  string $payroll ID of the payroll. This launches the component directly in edit view. In order to do this, the payroll needs to be formatted in a way the Run Payroll Component expects with a single earning rate tied to hourly or salaried earnings in the payroll item. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['runPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function runPayrollRequest($company, $payroll = null, string $contentType = self::contentTypes['runPayroll'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling runPayroll'
            );
        }



        $resourcePath = '/companies/{company}/components/run_payroll';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payroll,
            'payroll', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startImplementation
     *
     * Start implementation
     *
     * @param  string $company ID of the company to start implementation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startImplementation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function startImplementation($company, string $contentType = self::contentTypes['startImplementation'][0])
    {
        $this->startImplementationWithHttpInfo($company, $contentType);
    }

    /**
     * Operation startImplementationWithHttpInfo
     *
     * Start implementation
     *
     * @param  string $company ID of the company to start implementation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startImplementation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function startImplementationWithHttpInfo($company, string $contentType = self::contentTypes['startImplementation'][0])
    {
        $request = $this->startImplementationRequest($company, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startImplementationAsync
     *
     * Start implementation
     *
     * @param  string $company ID of the company to start implementation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startImplementation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startImplementationAsync($company, string $contentType = self::contentTypes['startImplementation'][0])
    {
        return $this->startImplementationAsyncWithHttpInfo($company, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startImplementationAsyncWithHttpInfo
     *
     * Start implementation
     *
     * @param  string $company ID of the company to start implementation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startImplementation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startImplementationAsyncWithHttpInfo($company, string $contentType = self::contentTypes['startImplementation'][0])
    {
        $returnType = '';
        $request = $this->startImplementationRequest($company, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startImplementation'
     *
     * @param  string $company ID of the company to start implementation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startImplementation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function startImplementationRequest($company, string $contentType = self::contentTypes['startImplementation'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling startImplementation'
            );
        }


        $resourcePath = '/companies/{company}/start_implementation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation submitAnEmployeeForm
     *
     * Submit an employee form
     *
     * @param  string $employee Submit a form to this employee ID (required)
     * @param  string $form ID of the form to submit (required)
     * @param  \OpenAPI\Client\Model\SubmitAnEmployeeFormRequest $submit_an_employee_form_request submit_an_employee_form_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitAnEmployeeForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function submitAnEmployeeForm($employee, $form, $submit_an_employee_form_request = null, string $contentType = self::contentTypes['submitAnEmployeeForm'][0])
    {
        $this->submitAnEmployeeFormWithHttpInfo($employee, $form, $submit_an_employee_form_request, $contentType);
    }

    /**
     * Operation submitAnEmployeeFormWithHttpInfo
     *
     * Submit an employee form
     *
     * @param  string $employee Submit a form to this employee ID (required)
     * @param  string $form ID of the form to submit (required)
     * @param  \OpenAPI\Client\Model\SubmitAnEmployeeFormRequest $submit_an_employee_form_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitAnEmployeeForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function submitAnEmployeeFormWithHttpInfo($employee, $form, $submit_an_employee_form_request = null, string $contentType = self::contentTypes['submitAnEmployeeForm'][0])
    {
        $request = $this->submitAnEmployeeFormRequest($employee, $form, $submit_an_employee_form_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation submitAnEmployeeFormAsync
     *
     * Submit an employee form
     *
     * @param  string $employee Submit a form to this employee ID (required)
     * @param  string $form ID of the form to submit (required)
     * @param  \OpenAPI\Client\Model\SubmitAnEmployeeFormRequest $submit_an_employee_form_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitAnEmployeeForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitAnEmployeeFormAsync($employee, $form, $submit_an_employee_form_request = null, string $contentType = self::contentTypes['submitAnEmployeeForm'][0])
    {
        return $this->submitAnEmployeeFormAsyncWithHttpInfo($employee, $form, $submit_an_employee_form_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation submitAnEmployeeFormAsyncWithHttpInfo
     *
     * Submit an employee form
     *
     * @param  string $employee Submit a form to this employee ID (required)
     * @param  string $form ID of the form to submit (required)
     * @param  \OpenAPI\Client\Model\SubmitAnEmployeeFormRequest $submit_an_employee_form_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitAnEmployeeForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitAnEmployeeFormAsyncWithHttpInfo($employee, $form, $submit_an_employee_form_request = null, string $contentType = self::contentTypes['submitAnEmployeeForm'][0])
    {
        $returnType = '';
        $request = $this->submitAnEmployeeFormRequest($employee, $form, $submit_an_employee_form_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'submitAnEmployeeForm'
     *
     * @param  string $employee Submit a form to this employee ID (required)
     * @param  string $form ID of the form to submit (required)
     * @param  \OpenAPI\Client\Model\SubmitAnEmployeeFormRequest $submit_an_employee_form_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitAnEmployeeForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function submitAnEmployeeFormRequest($employee, $form, $submit_an_employee_form_request = null, string $contentType = self::contentTypes['submitAnEmployeeForm'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling submitAnEmployeeForm'
            );
        }

        // verify the required parameter 'form' is set
        if ($form === null || (is_array($form) && count($form) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $form when calling submitAnEmployeeForm'
            );
        }



        $resourcePath = '/employees/{employee}/forms/{form}/submit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }
        // path params
        if ($form !== null) {
            $resourcePath = str_replace(
                '{' . 'form' . '}',
                ObjectSerializer::toPathValue($form),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($submit_an_employee_form_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($submit_an_employee_form_request));
            } else {
                $httpBody = $submit_an_employee_form_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateABankAccount
     *
     * Update a bank account
     *
     * @param  string $bank_account ID of the bank account (required)
     * @param  \OpenAPI\Client\Model\UpdateABankAccountRequest $update_a_bank_account_request update_a_bank_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateABankAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateABankAccount($bank_account, $update_a_bank_account_request = null, string $contentType = self::contentTypes['updateABankAccount'][0])
    {
        $this->updateABankAccountWithHttpInfo($bank_account, $update_a_bank_account_request, $contentType);
    }

    /**
     * Operation updateABankAccountWithHttpInfo
     *
     * Update a bank account
     *
     * @param  string $bank_account ID of the bank account (required)
     * @param  \OpenAPI\Client\Model\UpdateABankAccountRequest $update_a_bank_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateABankAccount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateABankAccountWithHttpInfo($bank_account, $update_a_bank_account_request = null, string $contentType = self::contentTypes['updateABankAccount'][0])
    {
        $request = $this->updateABankAccountRequest($bank_account, $update_a_bank_account_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateABankAccountAsync
     *
     * Update a bank account
     *
     * @param  string $bank_account ID of the bank account (required)
     * @param  \OpenAPI\Client\Model\UpdateABankAccountRequest $update_a_bank_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateABankAccountAsync($bank_account, $update_a_bank_account_request = null, string $contentType = self::contentTypes['updateABankAccount'][0])
    {
        return $this->updateABankAccountAsyncWithHttpInfo($bank_account, $update_a_bank_account_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateABankAccountAsyncWithHttpInfo
     *
     * Update a bank account
     *
     * @param  string $bank_account ID of the bank account (required)
     * @param  \OpenAPI\Client\Model\UpdateABankAccountRequest $update_a_bank_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateABankAccountAsyncWithHttpInfo($bank_account, $update_a_bank_account_request = null, string $contentType = self::contentTypes['updateABankAccount'][0])
    {
        $returnType = '';
        $request = $this->updateABankAccountRequest($bank_account, $update_a_bank_account_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateABankAccount'
     *
     * @param  string $bank_account ID of the bank account (required)
     * @param  \OpenAPI\Client\Model\UpdateABankAccountRequest $update_a_bank_account_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateABankAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateABankAccountRequest($bank_account, $update_a_bank_account_request = null, string $contentType = self::contentTypes['updateABankAccount'][0])
    {

        // verify the required parameter 'bank_account' is set
        if ($bank_account === null || (is_array($bank_account) && count($bank_account) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bank_account when calling updateABankAccount'
            );
        }



        $resourcePath = '/bank_accounts/{bank_account}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($bank_account !== null) {
            $resourcePath = str_replace(
                '{' . 'bank_account' . '}',
                ObjectSerializer::toPathValue($bank_account),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_a_bank_account_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_a_bank_account_request));
            } else {
                $httpBody = $update_a_bank_account_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateACompany
     *
     * Update a company
     *
     * @param  string $company ID of the company to update (required)
     * @param  \OpenAPI\Client\Model\UpdateACompanyRequest $update_a_company_request update_a_company_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateACompany'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function updateACompany($company, $update_a_company_request = null, string $contentType = self::contentTypes['updateACompany'][0])
    {
        list($response) = $this->updateACompanyWithHttpInfo($company, $update_a_company_request, $contentType);
        return $response;
    }

    /**
     * Operation updateACompanyWithHttpInfo
     *
     * Update a company
     *
     * @param  string $company ID of the company to update (required)
     * @param  \OpenAPI\Client\Model\UpdateACompanyRequest $update_a_company_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateACompany'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateACompanyWithHttpInfo($company, $update_a_company_request = null, string $contentType = self::contentTypes['updateACompany'][0])
    {
        $request = $this->updateACompanyRequest($company, $update_a_company_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateACompanyAsync
     *
     * Update a company
     *
     * @param  string $company ID of the company to update (required)
     * @param  \OpenAPI\Client\Model\UpdateACompanyRequest $update_a_company_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateACompany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateACompanyAsync($company, $update_a_company_request = null, string $contentType = self::contentTypes['updateACompany'][0])
    {
        return $this->updateACompanyAsyncWithHttpInfo($company, $update_a_company_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateACompanyAsyncWithHttpInfo
     *
     * Update a company
     *
     * @param  string $company ID of the company to update (required)
     * @param  \OpenAPI\Client\Model\UpdateACompanyRequest $update_a_company_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateACompany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateACompanyAsyncWithHttpInfo($company, $update_a_company_request = null, string $contentType = self::contentTypes['updateACompany'][0])
    {
        $returnType = 'object';
        $request = $this->updateACompanyRequest($company, $update_a_company_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateACompany'
     *
     * @param  string $company ID of the company to update (required)
     * @param  \OpenAPI\Client\Model\UpdateACompanyRequest $update_a_company_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateACompany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateACompanyRequest($company, $update_a_company_request = null, string $contentType = self::contentTypes['updateACompany'][0])
    {

        // verify the required parameter 'company' is set
        if ($company === null || (is_array($company) && count($company) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company when calling updateACompany'
            );
        }



        $resourcePath = '/companies/{company}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company !== null) {
            $resourcePath = str_replace(
                '{' . 'company' . '}',
                ObjectSerializer::toPathValue($company),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_a_company_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_a_company_request));
            } else {
                $httpBody = $update_a_company_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateACompanyBenefit
     *
     * Update a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to update (required)
     * @param  \OpenAPI\Client\Model\UpdateACompanyBenefitRequest $update_a_company_benefit_request update_a_company_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function updateACompanyBenefit($company_benefit, $update_a_company_benefit_request = null, string $contentType = self::contentTypes['updateACompanyBenefit'][0])
    {
        list($response) = $this->updateACompanyBenefitWithHttpInfo($company_benefit, $update_a_company_benefit_request, $contentType);
        return $response;
    }

    /**
     * Operation updateACompanyBenefitWithHttpInfo
     *
     * Update a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to update (required)
     * @param  \OpenAPI\Client\Model\UpdateACompanyBenefitRequest $update_a_company_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateACompanyBenefitWithHttpInfo($company_benefit, $update_a_company_benefit_request = null, string $contentType = self::contentTypes['updateACompanyBenefit'][0])
    {
        $request = $this->updateACompanyBenefitRequest($company_benefit, $update_a_company_benefit_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateACompanyBenefitAsync
     *
     * Update a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to update (required)
     * @param  \OpenAPI\Client\Model\UpdateACompanyBenefitRequest $update_a_company_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateACompanyBenefitAsync($company_benefit, $update_a_company_benefit_request = null, string $contentType = self::contentTypes['updateACompanyBenefit'][0])
    {
        return $this->updateACompanyBenefitAsyncWithHttpInfo($company_benefit, $update_a_company_benefit_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateACompanyBenefitAsyncWithHttpInfo
     *
     * Update a company benefit
     *
     * @param  string $company_benefit ID of the company benefit to update (required)
     * @param  \OpenAPI\Client\Model\UpdateACompanyBenefitRequest $update_a_company_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateACompanyBenefitAsyncWithHttpInfo($company_benefit, $update_a_company_benefit_request = null, string $contentType = self::contentTypes['updateACompanyBenefit'][0])
    {
        $returnType = 'object';
        $request = $this->updateACompanyBenefitRequest($company_benefit, $update_a_company_benefit_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateACompanyBenefit'
     *
     * @param  string $company_benefit ID of the company benefit to update (required)
     * @param  \OpenAPI\Client\Model\UpdateACompanyBenefitRequest $update_a_company_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateACompanyBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateACompanyBenefitRequest($company_benefit, $update_a_company_benefit_request = null, string $contentType = self::contentTypes['updateACompanyBenefit'][0])
    {

        // verify the required parameter 'company_benefit' is set
        if ($company_benefit === null || (is_array($company_benefit) && count($company_benefit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company_benefit when calling updateACompanyBenefit'
            );
        }



        $resourcePath = '/company_benefits/{company_benefit}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company_benefit !== null) {
            $resourcePath = str_replace(
                '{' . 'company_benefit' . '}',
                ObjectSerializer::toPathValue($company_benefit),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_a_company_benefit_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_a_company_benefit_request));
            } else {
                $httpBody = $update_a_company_benefit_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAContractor
     *
     * Update a contractor
     *
     * @param  string $contractor ID of the contractor to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAContractorRequest $update_a_contractor_request update_a_contractor_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAContractor'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function updateAContractor($contractor, $update_a_contractor_request = null, string $contentType = self::contentTypes['updateAContractor'][0])
    {
        list($response) = $this->updateAContractorWithHttpInfo($contractor, $update_a_contractor_request, $contentType);
        return $response;
    }

    /**
     * Operation updateAContractorWithHttpInfo
     *
     * Update a contractor
     *
     * @param  string $contractor ID of the contractor to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAContractorRequest $update_a_contractor_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAContractor'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAContractorWithHttpInfo($contractor, $update_a_contractor_request = null, string $contentType = self::contentTypes['updateAContractor'][0])
    {
        $request = $this->updateAContractorRequest($contractor, $update_a_contractor_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAContractorAsync
     *
     * Update a contractor
     *
     * @param  string $contractor ID of the contractor to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAContractorRequest $update_a_contractor_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAContractor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAContractorAsync($contractor, $update_a_contractor_request = null, string $contentType = self::contentTypes['updateAContractor'][0])
    {
        return $this->updateAContractorAsyncWithHttpInfo($contractor, $update_a_contractor_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAContractorAsyncWithHttpInfo
     *
     * Update a contractor
     *
     * @param  string $contractor ID of the contractor to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAContractorRequest $update_a_contractor_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAContractor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAContractorAsyncWithHttpInfo($contractor, $update_a_contractor_request = null, string $contentType = self::contentTypes['updateAContractor'][0])
    {
        $returnType = 'object';
        $request = $this->updateAContractorRequest($contractor, $update_a_contractor_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAContractor'
     *
     * @param  string $contractor ID of the contractor to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAContractorRequest $update_a_contractor_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAContractor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAContractorRequest($contractor, $update_a_contractor_request = null, string $contentType = self::contentTypes['updateAContractor'][0])
    {

        // verify the required parameter 'contractor' is set
        if ($contractor === null || (is_array($contractor) && count($contractor) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractor when calling updateAContractor'
            );
        }



        $resourcePath = '/contractors/{contractor}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contractor !== null) {
            $resourcePath = str_replace(
                '{' . 'contractor' . '}',
                ObjectSerializer::toPathValue($contractor),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_a_contractor_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_a_contractor_request));
            } else {
                $httpBody = $update_a_contractor_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAContractorPayment
     *
     * Update a contractor payment
     *
     * @param  string $contractor_payment ID of the contractor payment to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAContractorPaymentRequest $update_a_contractor_payment_request update_a_contractor_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAContractorPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function updateAContractorPayment($contractor_payment, $update_a_contractor_payment_request = null, string $contentType = self::contentTypes['updateAContractorPayment'][0])
    {
        list($response) = $this->updateAContractorPaymentWithHttpInfo($contractor_payment, $update_a_contractor_payment_request, $contentType);
        return $response;
    }

    /**
     * Operation updateAContractorPaymentWithHttpInfo
     *
     * Update a contractor payment
     *
     * @param  string $contractor_payment ID of the contractor payment to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAContractorPaymentRequest $update_a_contractor_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAContractorPayment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAContractorPaymentWithHttpInfo($contractor_payment, $update_a_contractor_payment_request = null, string $contentType = self::contentTypes['updateAContractorPayment'][0])
    {
        $request = $this->updateAContractorPaymentRequest($contractor_payment, $update_a_contractor_payment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAContractorPaymentAsync
     *
     * Update a contractor payment
     *
     * @param  string $contractor_payment ID of the contractor payment to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAContractorPaymentRequest $update_a_contractor_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAContractorPaymentAsync($contractor_payment, $update_a_contractor_payment_request = null, string $contentType = self::contentTypes['updateAContractorPayment'][0])
    {
        return $this->updateAContractorPaymentAsyncWithHttpInfo($contractor_payment, $update_a_contractor_payment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAContractorPaymentAsyncWithHttpInfo
     *
     * Update a contractor payment
     *
     * @param  string $contractor_payment ID of the contractor payment to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAContractorPaymentRequest $update_a_contractor_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAContractorPaymentAsyncWithHttpInfo($contractor_payment, $update_a_contractor_payment_request = null, string $contentType = self::contentTypes['updateAContractorPayment'][0])
    {
        $returnType = 'object';
        $request = $this->updateAContractorPaymentRequest($contractor_payment, $update_a_contractor_payment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAContractorPayment'
     *
     * @param  string $contractor_payment ID of the contractor payment to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAContractorPaymentRequest $update_a_contractor_payment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAContractorPayment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAContractorPaymentRequest($contractor_payment, $update_a_contractor_payment_request = null, string $contentType = self::contentTypes['updateAContractorPayment'][0])
    {

        // verify the required parameter 'contractor_payment' is set
        if ($contractor_payment === null || (is_array($contractor_payment) && count($contractor_payment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractor_payment when calling updateAContractorPayment'
            );
        }



        $resourcePath = '/contractor_payments/{contractor_payment}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contractor_payment !== null) {
            $resourcePath = str_replace(
                '{' . 'contractor_payment' . '}',
                ObjectSerializer::toPathValue($contractor_payment),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_a_contractor_payment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_a_contractor_payment_request));
            } else {
                $httpBody = $update_a_contractor_payment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAPaySchedule
     *
     * Update a pay schedule
     *
     * @param  string $pay_schedule pay_schedule (required)
     * @param  \OpenAPI\Client\Model\UpdateAPayScheduleRequest $update_a_pay_schedule_request update_a_pay_schedule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPaySchedule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function updateAPaySchedule($pay_schedule, $update_a_pay_schedule_request = null, string $contentType = self::contentTypes['updateAPaySchedule'][0])
    {
        list($response) = $this->updateAPayScheduleWithHttpInfo($pay_schedule, $update_a_pay_schedule_request, $contentType);
        return $response;
    }

    /**
     * Operation updateAPayScheduleWithHttpInfo
     *
     * Update a pay schedule
     *
     * @param  string $pay_schedule (required)
     * @param  \OpenAPI\Client\Model\UpdateAPayScheduleRequest $update_a_pay_schedule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPaySchedule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAPayScheduleWithHttpInfo($pay_schedule, $update_a_pay_schedule_request = null, string $contentType = self::contentTypes['updateAPaySchedule'][0])
    {
        $request = $this->updateAPayScheduleRequest($pay_schedule, $update_a_pay_schedule_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAPayScheduleAsync
     *
     * Update a pay schedule
     *
     * @param  string $pay_schedule (required)
     * @param  \OpenAPI\Client\Model\UpdateAPayScheduleRequest $update_a_pay_schedule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPaySchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAPayScheduleAsync($pay_schedule, $update_a_pay_schedule_request = null, string $contentType = self::contentTypes['updateAPaySchedule'][0])
    {
        return $this->updateAPayScheduleAsyncWithHttpInfo($pay_schedule, $update_a_pay_schedule_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAPayScheduleAsyncWithHttpInfo
     *
     * Update a pay schedule
     *
     * @param  string $pay_schedule (required)
     * @param  \OpenAPI\Client\Model\UpdateAPayScheduleRequest $update_a_pay_schedule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPaySchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAPayScheduleAsyncWithHttpInfo($pay_schedule, $update_a_pay_schedule_request = null, string $contentType = self::contentTypes['updateAPaySchedule'][0])
    {
        $returnType = 'object';
        $request = $this->updateAPayScheduleRequest($pay_schedule, $update_a_pay_schedule_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAPaySchedule'
     *
     * @param  string $pay_schedule (required)
     * @param  \OpenAPI\Client\Model\UpdateAPayScheduleRequest $update_a_pay_schedule_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPaySchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAPayScheduleRequest($pay_schedule, $update_a_pay_schedule_request = null, string $contentType = self::contentTypes['updateAPaySchedule'][0])
    {

        // verify the required parameter 'pay_schedule' is set
        if ($pay_schedule === null || (is_array($pay_schedule) && count($pay_schedule) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pay_schedule when calling updateAPaySchedule'
            );
        }



        $resourcePath = '/pay_schedules/{pay_schedule}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pay_schedule !== null) {
            $resourcePath = str_replace(
                '{' . 'pay_schedule' . '}',
                ObjectSerializer::toPathValue($pay_schedule),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_a_pay_schedule_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_a_pay_schedule_request));
            } else {
                $httpBody = $update_a_pay_schedule_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAPayrollItem
     *
     * Update a payroll item
     *
     * @param  string $payroll_item payroll_item (required)
     * @param  \OpenAPI\Client\Model\UpdateAPayrollItemRequest $update_a_payroll_item_request update_a_payroll_item_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPayrollItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateAPayrollItem($payroll_item, $update_a_payroll_item_request = null, string $contentType = self::contentTypes['updateAPayrollItem'][0])
    {
        $this->updateAPayrollItemWithHttpInfo($payroll_item, $update_a_payroll_item_request, $contentType);
    }

    /**
     * Operation updateAPayrollItemWithHttpInfo
     *
     * Update a payroll item
     *
     * @param  string $payroll_item (required)
     * @param  \OpenAPI\Client\Model\UpdateAPayrollItemRequest $update_a_payroll_item_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPayrollItem'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAPayrollItemWithHttpInfo($payroll_item, $update_a_payroll_item_request = null, string $contentType = self::contentTypes['updateAPayrollItem'][0])
    {
        $request = $this->updateAPayrollItemRequest($payroll_item, $update_a_payroll_item_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateAPayrollItemAsync
     *
     * Update a payroll item
     *
     * @param  string $payroll_item (required)
     * @param  \OpenAPI\Client\Model\UpdateAPayrollItemRequest $update_a_payroll_item_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAPayrollItemAsync($payroll_item, $update_a_payroll_item_request = null, string $contentType = self::contentTypes['updateAPayrollItem'][0])
    {
        return $this->updateAPayrollItemAsyncWithHttpInfo($payroll_item, $update_a_payroll_item_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAPayrollItemAsyncWithHttpInfo
     *
     * Update a payroll item
     *
     * @param  string $payroll_item (required)
     * @param  \OpenAPI\Client\Model\UpdateAPayrollItemRequest $update_a_payroll_item_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAPayrollItemAsyncWithHttpInfo($payroll_item, $update_a_payroll_item_request = null, string $contentType = self::contentTypes['updateAPayrollItem'][0])
    {
        $returnType = '';
        $request = $this->updateAPayrollItemRequest($payroll_item, $update_a_payroll_item_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAPayrollItem'
     *
     * @param  string $payroll_item (required)
     * @param  \OpenAPI\Client\Model\UpdateAPayrollItemRequest $update_a_payroll_item_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPayrollItem'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAPayrollItemRequest($payroll_item, $update_a_payroll_item_request = null, string $contentType = self::contentTypes['updateAPayrollItem'][0])
    {

        // verify the required parameter 'payroll_item' is set
        if ($payroll_item === null || (is_array($payroll_item) && count($payroll_item) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll_item when calling updateAPayrollItem'
            );
        }



        $resourcePath = '/payroll_items/{payroll_item}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll_item !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll_item' . '}',
                ObjectSerializer::toPathValue($payroll_item),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_a_payroll_item_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_a_payroll_item_request));
            } else {
                $httpBody = $update_a_payroll_item_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAPostTaxDeduction
     *
     * Update a post-tax deduction
     *
     * @param  string $post_tax_deduction ID of the post tax deduction to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAPostTaxDeductionRequest $update_a_post_tax_deduction_request update_a_post_tax_deduction_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateAPostTaxDeduction($post_tax_deduction, $update_a_post_tax_deduction_request = null, string $contentType = self::contentTypes['updateAPostTaxDeduction'][0])
    {
        $this->updateAPostTaxDeductionWithHttpInfo($post_tax_deduction, $update_a_post_tax_deduction_request, $contentType);
    }

    /**
     * Operation updateAPostTaxDeductionWithHttpInfo
     *
     * Update a post-tax deduction
     *
     * @param  string $post_tax_deduction ID of the post tax deduction to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAPostTaxDeductionRequest $update_a_post_tax_deduction_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAPostTaxDeductionWithHttpInfo($post_tax_deduction, $update_a_post_tax_deduction_request = null, string $contentType = self::contentTypes['updateAPostTaxDeduction'][0])
    {
        $request = $this->updateAPostTaxDeductionRequest($post_tax_deduction, $update_a_post_tax_deduction_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateAPostTaxDeductionAsync
     *
     * Update a post-tax deduction
     *
     * @param  string $post_tax_deduction ID of the post tax deduction to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAPostTaxDeductionRequest $update_a_post_tax_deduction_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAPostTaxDeductionAsync($post_tax_deduction, $update_a_post_tax_deduction_request = null, string $contentType = self::contentTypes['updateAPostTaxDeduction'][0])
    {
        return $this->updateAPostTaxDeductionAsyncWithHttpInfo($post_tax_deduction, $update_a_post_tax_deduction_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAPostTaxDeductionAsyncWithHttpInfo
     *
     * Update a post-tax deduction
     *
     * @param  string $post_tax_deduction ID of the post tax deduction to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAPostTaxDeductionRequest $update_a_post_tax_deduction_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAPostTaxDeductionAsyncWithHttpInfo($post_tax_deduction, $update_a_post_tax_deduction_request = null, string $contentType = self::contentTypes['updateAPostTaxDeduction'][0])
    {
        $returnType = '';
        $request = $this->updateAPostTaxDeductionRequest($post_tax_deduction, $update_a_post_tax_deduction_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAPostTaxDeduction'
     *
     * @param  string $post_tax_deduction ID of the post tax deduction to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAPostTaxDeductionRequest $update_a_post_tax_deduction_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAPostTaxDeduction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAPostTaxDeductionRequest($post_tax_deduction, $update_a_post_tax_deduction_request = null, string $contentType = self::contentTypes['updateAPostTaxDeduction'][0])
    {

        // verify the required parameter 'post_tax_deduction' is set
        if ($post_tax_deduction === null || (is_array($post_tax_deduction) && count($post_tax_deduction) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_tax_deduction when calling updateAPostTaxDeduction'
            );
        }



        $resourcePath = '/post_tax_deductions/{post_tax_deduction}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($post_tax_deduction !== null) {
            $resourcePath = str_replace(
                '{' . 'post_tax_deduction' . '}',
                ObjectSerializer::toPathValue($post_tax_deduction),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_a_post_tax_deduction_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_a_post_tax_deduction_request));
            } else {
                $httpBody = $update_a_post_tax_deduction_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAWebhookConfig
     *
     * Update a webhook config
     *
     * @param  string $webhook_config webhook_config (required)
     * @param  \OpenAPI\Client\Model\UpdateAWebhookConfigRequest $update_a_webhook_config_request update_a_webhook_config_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateAWebhookConfig($webhook_config, $update_a_webhook_config_request = null, string $contentType = self::contentTypes['updateAWebhookConfig'][0])
    {
        $this->updateAWebhookConfigWithHttpInfo($webhook_config, $update_a_webhook_config_request, $contentType);
    }

    /**
     * Operation updateAWebhookConfigWithHttpInfo
     *
     * Update a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  \OpenAPI\Client\Model\UpdateAWebhookConfigRequest $update_a_webhook_config_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAWebhookConfigWithHttpInfo($webhook_config, $update_a_webhook_config_request = null, string $contentType = self::contentTypes['updateAWebhookConfig'][0])
    {
        $request = $this->updateAWebhookConfigRequest($webhook_config, $update_a_webhook_config_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateAWebhookConfigAsync
     *
     * Update a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  \OpenAPI\Client\Model\UpdateAWebhookConfigRequest $update_a_webhook_config_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAWebhookConfigAsync($webhook_config, $update_a_webhook_config_request = null, string $contentType = self::contentTypes['updateAWebhookConfig'][0])
    {
        return $this->updateAWebhookConfigAsyncWithHttpInfo($webhook_config, $update_a_webhook_config_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAWebhookConfigAsyncWithHttpInfo
     *
     * Update a webhook config
     *
     * @param  string $webhook_config (required)
     * @param  \OpenAPI\Client\Model\UpdateAWebhookConfigRequest $update_a_webhook_config_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAWebhookConfigAsyncWithHttpInfo($webhook_config, $update_a_webhook_config_request = null, string $contentType = self::contentTypes['updateAWebhookConfig'][0])
    {
        $returnType = '';
        $request = $this->updateAWebhookConfigRequest($webhook_config, $update_a_webhook_config_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAWebhookConfig'
     *
     * @param  string $webhook_config (required)
     * @param  \OpenAPI\Client\Model\UpdateAWebhookConfigRequest $update_a_webhook_config_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAWebhookConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAWebhookConfigRequest($webhook_config, $update_a_webhook_config_request = null, string $contentType = self::contentTypes['updateAWebhookConfig'][0])
    {

        // verify the required parameter 'webhook_config' is set
        if ($webhook_config === null || (is_array($webhook_config) && count($webhook_config) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_config when calling updateAWebhookConfig'
            );
        }



        $resourcePath = '/webhook_configs/{webhook_config}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_config !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_config' . '}',
                ObjectSerializer::toPathValue($webhook_config),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_a_webhook_config_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_a_webhook_config_request));
            } else {
                $httpBody = $update_a_webhook_config_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAWorkplace
     *
     * Update a workplace
     *
     * @param  string $workplace workplace (required)
     * @param  \OpenAPI\Client\Model\UpdateAWorkplaceRequest $update_a_workplace_request update_a_workplace_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAWorkplace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListWorkplaces200ResponseInner
     */
    public function updateAWorkplace($workplace, $update_a_workplace_request = null, string $contentType = self::contentTypes['updateAWorkplace'][0])
    {
        list($response) = $this->updateAWorkplaceWithHttpInfo($workplace, $update_a_workplace_request, $contentType);
        return $response;
    }

    /**
     * Operation updateAWorkplaceWithHttpInfo
     *
     * Update a workplace
     *
     * @param  string $workplace (required)
     * @param  \OpenAPI\Client\Model\UpdateAWorkplaceRequest $update_a_workplace_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAWorkplace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListWorkplaces200ResponseInner, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAWorkplaceWithHttpInfo($workplace, $update_a_workplace_request = null, string $contentType = self::contentTypes['updateAWorkplace'][0])
    {
        $request = $this->updateAWorkplaceRequest($workplace, $update_a_workplace_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListWorkplaces200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListWorkplaces200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAWorkplaceAsync
     *
     * Update a workplace
     *
     * @param  string $workplace (required)
     * @param  \OpenAPI\Client\Model\UpdateAWorkplaceRequest $update_a_workplace_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAWorkplace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAWorkplaceAsync($workplace, $update_a_workplace_request = null, string $contentType = self::contentTypes['updateAWorkplace'][0])
    {
        return $this->updateAWorkplaceAsyncWithHttpInfo($workplace, $update_a_workplace_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAWorkplaceAsyncWithHttpInfo
     *
     * Update a workplace
     *
     * @param  string $workplace (required)
     * @param  \OpenAPI\Client\Model\UpdateAWorkplaceRequest $update_a_workplace_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAWorkplace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAWorkplaceAsyncWithHttpInfo($workplace, $update_a_workplace_request = null, string $contentType = self::contentTypes['updateAWorkplace'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListWorkplaces200ResponseInner';
        $request = $this->updateAWorkplaceRequest($workplace, $update_a_workplace_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAWorkplace'
     *
     * @param  string $workplace (required)
     * @param  \OpenAPI\Client\Model\UpdateAWorkplaceRequest $update_a_workplace_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAWorkplace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAWorkplaceRequest($workplace, $update_a_workplace_request = null, string $contentType = self::contentTypes['updateAWorkplace'][0])
    {

        // verify the required parameter 'workplace' is set
        if ($workplace === null || (is_array($workplace) && count($workplace) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workplace when calling updateAWorkplace'
            );
        }



        $resourcePath = '/workplaces/{workplace}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($workplace !== null) {
            $resourcePath = str_replace(
                '{' . 'workplace' . '}',
                ObjectSerializer::toPathValue($workplace),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_a_workplace_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_a_workplace_request));
            } else {
                $httpBody = $update_a_workplace_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAnEarningCode
     *
     * Update an earning code
     *
     * @param  string $earning_code earning_code (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEarningCodeRequest $update_an_earning_code_request update_an_earning_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEarningCode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function updateAnEarningCode($earning_code, $update_an_earning_code_request = null, string $contentType = self::contentTypes['updateAnEarningCode'][0])
    {
        list($response) = $this->updateAnEarningCodeWithHttpInfo($earning_code, $update_an_earning_code_request, $contentType);
        return $response;
    }

    /**
     * Operation updateAnEarningCodeWithHttpInfo
     *
     * Update an earning code
     *
     * @param  string $earning_code (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEarningCodeRequest $update_an_earning_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEarningCode'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAnEarningCodeWithHttpInfo($earning_code, $update_an_earning_code_request = null, string $contentType = self::contentTypes['updateAnEarningCode'][0])
    {
        $request = $this->updateAnEarningCodeRequest($earning_code, $update_an_earning_code_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAnEarningCodeAsync
     *
     * Update an earning code
     *
     * @param  string $earning_code (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEarningCodeRequest $update_an_earning_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEarningCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnEarningCodeAsync($earning_code, $update_an_earning_code_request = null, string $contentType = self::contentTypes['updateAnEarningCode'][0])
    {
        return $this->updateAnEarningCodeAsyncWithHttpInfo($earning_code, $update_an_earning_code_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAnEarningCodeAsyncWithHttpInfo
     *
     * Update an earning code
     *
     * @param  string $earning_code (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEarningCodeRequest $update_an_earning_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEarningCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnEarningCodeAsyncWithHttpInfo($earning_code, $update_an_earning_code_request = null, string $contentType = self::contentTypes['updateAnEarningCode'][0])
    {
        $returnType = 'object';
        $request = $this->updateAnEarningCodeRequest($earning_code, $update_an_earning_code_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAnEarningCode'
     *
     * @param  string $earning_code (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEarningCodeRequest $update_an_earning_code_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEarningCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAnEarningCodeRequest($earning_code, $update_an_earning_code_request = null, string $contentType = self::contentTypes['updateAnEarningCode'][0])
    {

        // verify the required parameter 'earning_code' is set
        if ($earning_code === null || (is_array($earning_code) && count($earning_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $earning_code when calling updateAnEarningCode'
            );
        }



        $resourcePath = '/earning_codes/{earning_code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($earning_code !== null) {
            $resourcePath = str_replace(
                '{' . 'earning_code' . '}',
                ObjectSerializer::toPathValue($earning_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_an_earning_code_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_an_earning_code_request));
            } else {
                $httpBody = $update_an_earning_code_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAnEarningRate
     *
     * Update an earning rate
     *
     * @param  string $earning_rate earning_rate (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEarningRateRequest $update_an_earning_rate_request update_an_earning_rate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEarningRate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function updateAnEarningRate($earning_rate, $update_an_earning_rate_request = null, string $contentType = self::contentTypes['updateAnEarningRate'][0])
    {
        list($response) = $this->updateAnEarningRateWithHttpInfo($earning_rate, $update_an_earning_rate_request, $contentType);
        return $response;
    }

    /**
     * Operation updateAnEarningRateWithHttpInfo
     *
     * Update an earning rate
     *
     * @param  string $earning_rate (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEarningRateRequest $update_an_earning_rate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEarningRate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAnEarningRateWithHttpInfo($earning_rate, $update_an_earning_rate_request = null, string $contentType = self::contentTypes['updateAnEarningRate'][0])
    {
        $request = $this->updateAnEarningRateRequest($earning_rate, $update_an_earning_rate_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAnEarningRateAsync
     *
     * Update an earning rate
     *
     * @param  string $earning_rate (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEarningRateRequest $update_an_earning_rate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEarningRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnEarningRateAsync($earning_rate, $update_an_earning_rate_request = null, string $contentType = self::contentTypes['updateAnEarningRate'][0])
    {
        return $this->updateAnEarningRateAsyncWithHttpInfo($earning_rate, $update_an_earning_rate_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAnEarningRateAsyncWithHttpInfo
     *
     * Update an earning rate
     *
     * @param  string $earning_rate (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEarningRateRequest $update_an_earning_rate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEarningRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnEarningRateAsyncWithHttpInfo($earning_rate, $update_an_earning_rate_request = null, string $contentType = self::contentTypes['updateAnEarningRate'][0])
    {
        $returnType = 'object';
        $request = $this->updateAnEarningRateRequest($earning_rate, $update_an_earning_rate_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAnEarningRate'
     *
     * @param  string $earning_rate (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEarningRateRequest $update_an_earning_rate_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEarningRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAnEarningRateRequest($earning_rate, $update_an_earning_rate_request = null, string $contentType = self::contentTypes['updateAnEarningRate'][0])
    {

        // verify the required parameter 'earning_rate' is set
        if ($earning_rate === null || (is_array($earning_rate) && count($earning_rate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $earning_rate when calling updateAnEarningRate'
            );
        }



        $resourcePath = '/earning_rates/{earning_rate}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($earning_rate !== null) {
            $resourcePath = str_replace(
                '{' . 'earning_rate' . '}',
                ObjectSerializer::toPathValue($earning_rate),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_an_earning_rate_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_an_earning_rate_request));
            } else {
                $httpBody = $update_an_earning_rate_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAnEmployee
     *
     * Update an employee
     *
     * @param  string $employee ID of the employee to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEmployeeRequest $update_an_employee_request update_an_employee_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEmployee'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateAnEmployee($employee, $update_an_employee_request = null, string $contentType = self::contentTypes['updateAnEmployee'][0])
    {
        $this->updateAnEmployeeWithHttpInfo($employee, $update_an_employee_request, $contentType);
    }

    /**
     * Operation updateAnEmployeeWithHttpInfo
     *
     * Update an employee
     *
     * @param  string $employee ID of the employee to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEmployeeRequest $update_an_employee_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEmployee'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAnEmployeeWithHttpInfo($employee, $update_an_employee_request = null, string $contentType = self::contentTypes['updateAnEmployee'][0])
    {
        $request = $this->updateAnEmployeeRequest($employee, $update_an_employee_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateAnEmployeeAsync
     *
     * Update an employee
     *
     * @param  string $employee ID of the employee to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEmployeeRequest $update_an_employee_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEmployee'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnEmployeeAsync($employee, $update_an_employee_request = null, string $contentType = self::contentTypes['updateAnEmployee'][0])
    {
        return $this->updateAnEmployeeAsyncWithHttpInfo($employee, $update_an_employee_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAnEmployeeAsyncWithHttpInfo
     *
     * Update an employee
     *
     * @param  string $employee ID of the employee to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEmployeeRequest $update_an_employee_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEmployee'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnEmployeeAsyncWithHttpInfo($employee, $update_an_employee_request = null, string $contentType = self::contentTypes['updateAnEmployee'][0])
    {
        $returnType = '';
        $request = $this->updateAnEmployeeRequest($employee, $update_an_employee_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAnEmployee'
     *
     * @param  string $employee ID of the employee to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEmployeeRequest $update_an_employee_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEmployee'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAnEmployeeRequest($employee, $update_an_employee_request = null, string $contentType = self::contentTypes['updateAnEmployee'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling updateAnEmployee'
            );
        }



        $resourcePath = '/employees/{employee}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_an_employee_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_an_employee_request));
            } else {
                $httpBody = $update_an_employee_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAnEmployeeBenefit
     *
     * Update a benefit
     *
     * @param  string $benefit ID of the benefit to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEmployeeBenefitRequest $update_an_employee_benefit_request update_an_employee_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateAnEmployeeBenefit($benefit, $update_an_employee_benefit_request = null, string $contentType = self::contentTypes['updateAnEmployeeBenefit'][0])
    {
        list($response) = $this->updateAnEmployeeBenefitWithHttpInfo($benefit, $update_an_employee_benefit_request, $contentType);
        return $response;
    }

    /**
     * Operation updateAnEmployeeBenefitWithHttpInfo
     *
     * Update a benefit
     *
     * @param  string $benefit ID of the benefit to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEmployeeBenefitRequest $update_an_employee_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAnEmployeeBenefitWithHttpInfo($benefit, $update_an_employee_benefit_request = null, string $contentType = self::contentTypes['updateAnEmployeeBenefit'][0])
    {
        $request = $this->updateAnEmployeeBenefitRequest($benefit, $update_an_employee_benefit_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAnEmployeeBenefitAsync
     *
     * Update a benefit
     *
     * @param  string $benefit ID of the benefit to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEmployeeBenefitRequest $update_an_employee_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnEmployeeBenefitAsync($benefit, $update_an_employee_benefit_request = null, string $contentType = self::contentTypes['updateAnEmployeeBenefit'][0])
    {
        return $this->updateAnEmployeeBenefitAsyncWithHttpInfo($benefit, $update_an_employee_benefit_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAnEmployeeBenefitAsyncWithHttpInfo
     *
     * Update a benefit
     *
     * @param  string $benefit ID of the benefit to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEmployeeBenefitRequest $update_an_employee_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnEmployeeBenefitAsyncWithHttpInfo($benefit, $update_an_employee_benefit_request = null, string $contentType = self::contentTypes['updateAnEmployeeBenefit'][0])
    {
        $returnType = 'object';
        $request = $this->updateAnEmployeeBenefitRequest($benefit, $update_an_employee_benefit_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAnEmployeeBenefit'
     *
     * @param  string $benefit ID of the benefit to update (required)
     * @param  \OpenAPI\Client\Model\UpdateAnEmployeeBenefitRequest $update_an_employee_benefit_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnEmployeeBenefit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAnEmployeeBenefitRequest($benefit, $update_an_employee_benefit_request = null, string $contentType = self::contentTypes['updateAnEmployeeBenefit'][0])
    {

        // verify the required parameter 'benefit' is set
        if ($benefit === null || (is_array($benefit) && count($benefit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $benefit when calling updateAnEmployeeBenefit'
            );
        }



        $resourcePath = '/benefits/{benefit}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($benefit !== null) {
            $resourcePath = str_replace(
                '{' . 'benefit' . '}',
                ObjectSerializer::toPathValue($benefit),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_an_employee_benefit_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_an_employee_benefit_request));
            } else {
                $httpBody = $update_an_employee_benefit_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAnExternalPayroll
     *
     * Update an external payroll
     *
     * @param  string $payroll payroll (required)
     * @param  \OpenAPI\Client\Model\UpdateAnExternalPayrollRequest $update_an_external_payroll_request update_an_external_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateAnExternalPayroll($payroll, $update_an_external_payroll_request = null, string $contentType = self::contentTypes['updateAnExternalPayroll'][0])
    {
        $this->updateAnExternalPayrollWithHttpInfo($payroll, $update_an_external_payroll_request, $contentType);
    }

    /**
     * Operation updateAnExternalPayrollWithHttpInfo
     *
     * Update an external payroll
     *
     * @param  string $payroll (required)
     * @param  \OpenAPI\Client\Model\UpdateAnExternalPayrollRequest $update_an_external_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAnExternalPayrollWithHttpInfo($payroll, $update_an_external_payroll_request = null, string $contentType = self::contentTypes['updateAnExternalPayroll'][0])
    {
        $request = $this->updateAnExternalPayrollRequest($payroll, $update_an_external_payroll_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateAnExternalPayrollAsync
     *
     * Update an external payroll
     *
     * @param  string $payroll (required)
     * @param  \OpenAPI\Client\Model\UpdateAnExternalPayrollRequest $update_an_external_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnExternalPayrollAsync($payroll, $update_an_external_payroll_request = null, string $contentType = self::contentTypes['updateAnExternalPayroll'][0])
    {
        return $this->updateAnExternalPayrollAsyncWithHttpInfo($payroll, $update_an_external_payroll_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAnExternalPayrollAsyncWithHttpInfo
     *
     * Update an external payroll
     *
     * @param  string $payroll (required)
     * @param  \OpenAPI\Client\Model\UpdateAnExternalPayrollRequest $update_an_external_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAnExternalPayrollAsyncWithHttpInfo($payroll, $update_an_external_payroll_request = null, string $contentType = self::contentTypes['updateAnExternalPayroll'][0])
    {
        $returnType = '';
        $request = $this->updateAnExternalPayrollRequest($payroll, $update_an_external_payroll_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAnExternalPayroll'
     *
     * @param  string $payroll (required)
     * @param  \OpenAPI\Client\Model\UpdateAnExternalPayrollRequest $update_an_external_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAnExternalPayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAnExternalPayrollRequest($payroll, $update_an_external_payroll_request = null, string $contentType = self::contentTypes['updateAnExternalPayroll'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling updateAnExternalPayroll'
            );
        }



        $resourcePath = '/external_payrolls/{payroll}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_an_external_payroll_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_an_external_payroll_request));
            } else {
                $httpBody = $update_an_external_payroll_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCompanyDefinedAttributes
     *
     * Update company-defined attributes
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyDefinedAttributesRequest $update_company_defined_attributes_request update_company_defined_attributes_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyDefinedAttributes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UpdateCompanyDefinedAttributes200Response
     */
    public function updateCompanyDefinedAttributes($employee, $update_company_defined_attributes_request = null, string $contentType = self::contentTypes['updateCompanyDefinedAttributes'][0])
    {
        list($response) = $this->updateCompanyDefinedAttributesWithHttpInfo($employee, $update_company_defined_attributes_request, $contentType);
        return $response;
    }

    /**
     * Operation updateCompanyDefinedAttributesWithHttpInfo
     *
     * Update company-defined attributes
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyDefinedAttributesRequest $update_company_defined_attributes_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyDefinedAttributes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UpdateCompanyDefinedAttributes200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCompanyDefinedAttributesWithHttpInfo($employee, $update_company_defined_attributes_request = null, string $contentType = self::contentTypes['updateCompanyDefinedAttributes'][0])
    {
        $request = $this->updateCompanyDefinedAttributesRequest($employee, $update_company_defined_attributes_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\UpdateCompanyDefinedAttributes200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UpdateCompanyDefinedAttributes200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UpdateCompanyDefinedAttributes200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\UpdateCompanyDefinedAttributes200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UpdateCompanyDefinedAttributes200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCompanyDefinedAttributesAsync
     *
     * Update company-defined attributes
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyDefinedAttributesRequest $update_company_defined_attributes_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyDefinedAttributes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCompanyDefinedAttributesAsync($employee, $update_company_defined_attributes_request = null, string $contentType = self::contentTypes['updateCompanyDefinedAttributes'][0])
    {
        return $this->updateCompanyDefinedAttributesAsyncWithHttpInfo($employee, $update_company_defined_attributes_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCompanyDefinedAttributesAsyncWithHttpInfo
     *
     * Update company-defined attributes
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyDefinedAttributesRequest $update_company_defined_attributes_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyDefinedAttributes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCompanyDefinedAttributesAsyncWithHttpInfo($employee, $update_company_defined_attributes_request = null, string $contentType = self::contentTypes['updateCompanyDefinedAttributes'][0])
    {
        $returnType = '\OpenAPI\Client\Model\UpdateCompanyDefinedAttributes200Response';
        $request = $this->updateCompanyDefinedAttributesRequest($employee, $update_company_defined_attributes_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCompanyDefinedAttributes'
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyDefinedAttributesRequest $update_company_defined_attributes_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyDefinedAttributes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCompanyDefinedAttributesRequest($employee, $update_company_defined_attributes_request = null, string $contentType = self::contentTypes['updateCompanyDefinedAttributes'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling updateCompanyDefinedAttributes'
            );
        }



        $resourcePath = '/employees/{employee}/company_defined_attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_company_defined_attributes_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_company_defined_attributes_request));
            } else {
                $httpBody = $update_company_defined_attributes_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCompanyTaxElections
     *
     * Update company tax elections
     *
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxElectionsRequest $update_company_tax_elections_request update_company_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateCompanyTaxElections($update_company_tax_elections_request = null, string $contentType = self::contentTypes['updateCompanyTaxElections'][0])
    {
        $this->updateCompanyTaxElectionsWithHttpInfo($update_company_tax_elections_request, $contentType);
    }

    /**
     * Operation updateCompanyTaxElectionsWithHttpInfo
     *
     * Update company tax elections
     *
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxElectionsRequest $update_company_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCompanyTaxElectionsWithHttpInfo($update_company_tax_elections_request = null, string $contentType = self::contentTypes['updateCompanyTaxElections'][0])
    {
        $request = $this->updateCompanyTaxElectionsRequest($update_company_tax_elections_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCompanyTaxElectionsAsync
     *
     * Update company tax elections
     *
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxElectionsRequest $update_company_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCompanyTaxElectionsAsync($update_company_tax_elections_request = null, string $contentType = self::contentTypes['updateCompanyTaxElections'][0])
    {
        return $this->updateCompanyTaxElectionsAsyncWithHttpInfo($update_company_tax_elections_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCompanyTaxElectionsAsyncWithHttpInfo
     *
     * Update company tax elections
     *
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxElectionsRequest $update_company_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCompanyTaxElectionsAsyncWithHttpInfo($update_company_tax_elections_request = null, string $contentType = self::contentTypes['updateCompanyTaxElections'][0])
    {
        $returnType = '';
        $request = $this->updateCompanyTaxElectionsRequest($update_company_tax_elections_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCompanyTaxElections'
     *
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxElectionsRequest $update_company_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCompanyTaxElectionsRequest($update_company_tax_elections_request = null, string $contentType = self::contentTypes['updateCompanyTaxElections'][0])
    {



        $resourcePath = '/company_tax_elections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_company_tax_elections_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_company_tax_elections_request));
            } else {
                $httpBody = $update_company_tax_elections_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCompanyTaxParameters
     *
     * Update a company&#39;s tax parameters
     *
     * @param  string $company_id ID of the company used to update the applicable tax parameters. (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxParametersRequest $update_company_tax_parameters_request update_company_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyTaxParameters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateCompanyTaxParameters($company_id, $update_company_tax_parameters_request = null, string $contentType = self::contentTypes['updateCompanyTaxParameters'][0])
    {
        $this->updateCompanyTaxParametersWithHttpInfo($company_id, $update_company_tax_parameters_request, $contentType);
    }

    /**
     * Operation updateCompanyTaxParametersWithHttpInfo
     *
     * Update a company&#39;s tax parameters
     *
     * @param  string $company_id ID of the company used to update the applicable tax parameters. (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxParametersRequest $update_company_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyTaxParameters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCompanyTaxParametersWithHttpInfo($company_id, $update_company_tax_parameters_request = null, string $contentType = self::contentTypes['updateCompanyTaxParameters'][0])
    {
        $request = $this->updateCompanyTaxParametersRequest($company_id, $update_company_tax_parameters_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCompanyTaxParametersAsync
     *
     * Update a company&#39;s tax parameters
     *
     * @param  string $company_id ID of the company used to update the applicable tax parameters. (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxParametersRequest $update_company_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCompanyTaxParametersAsync($company_id, $update_company_tax_parameters_request = null, string $contentType = self::contentTypes['updateCompanyTaxParameters'][0])
    {
        return $this->updateCompanyTaxParametersAsyncWithHttpInfo($company_id, $update_company_tax_parameters_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCompanyTaxParametersAsyncWithHttpInfo
     *
     * Update a company&#39;s tax parameters
     *
     * @param  string $company_id ID of the company used to update the applicable tax parameters. (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxParametersRequest $update_company_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCompanyTaxParametersAsyncWithHttpInfo($company_id, $update_company_tax_parameters_request = null, string $contentType = self::contentTypes['updateCompanyTaxParameters'][0])
    {
        $returnType = '';
        $request = $this->updateCompanyTaxParametersRequest($company_id, $update_company_tax_parameters_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCompanyTaxParameters'
     *
     * @param  string $company_id ID of the company used to update the applicable tax parameters. (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxParametersRequest $update_company_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCompanyTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCompanyTaxParametersRequest($company_id, $update_company_tax_parameters_request = null, string $contentType = self::contentTypes['updateCompanyTaxParameters'][0])
    {

        // verify the required parameter 'company_id' is set
        if ($company_id === null || (is_array($company_id) && count($company_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $company_id when calling updateCompanyTaxParameters'
            );
        }



        $resourcePath = '/company_tax_params/{company_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($company_id !== null) {
            $resourcePath = str_replace(
                '{' . 'company_id' . '}',
                ObjectSerializer::toPathValue($company_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_company_tax_parameters_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_company_tax_parameters_request));
            } else {
                $httpBody = $update_company_tax_parameters_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEmployeeTaxElections
     *
     * Update employee tax elections
     *
     * @param  \OpenAPI\Client\Model\UpdateEmployeeTaxElectionsRequest $update_employee_tax_elections_request update_employee_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmployeeTaxElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateEmployeeTaxElections($update_employee_tax_elections_request = null, string $contentType = self::contentTypes['updateEmployeeTaxElections'][0])
    {
        $this->updateEmployeeTaxElectionsWithHttpInfo($update_employee_tax_elections_request, $contentType);
    }

    /**
     * Operation updateEmployeeTaxElectionsWithHttpInfo
     *
     * Update employee tax elections
     *
     * @param  \OpenAPI\Client\Model\UpdateEmployeeTaxElectionsRequest $update_employee_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmployeeTaxElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEmployeeTaxElectionsWithHttpInfo($update_employee_tax_elections_request = null, string $contentType = self::contentTypes['updateEmployeeTaxElections'][0])
    {
        $request = $this->updateEmployeeTaxElectionsRequest($update_employee_tax_elections_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateEmployeeTaxElectionsAsync
     *
     * Update employee tax elections
     *
     * @param  \OpenAPI\Client\Model\UpdateEmployeeTaxElectionsRequest $update_employee_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmployeeTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmployeeTaxElectionsAsync($update_employee_tax_elections_request = null, string $contentType = self::contentTypes['updateEmployeeTaxElections'][0])
    {
        return $this->updateEmployeeTaxElectionsAsyncWithHttpInfo($update_employee_tax_elections_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEmployeeTaxElectionsAsyncWithHttpInfo
     *
     * Update employee tax elections
     *
     * @param  \OpenAPI\Client\Model\UpdateEmployeeTaxElectionsRequest $update_employee_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmployeeTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmployeeTaxElectionsAsyncWithHttpInfo($update_employee_tax_elections_request = null, string $contentType = self::contentTypes['updateEmployeeTaxElections'][0])
    {
        $returnType = '';
        $request = $this->updateEmployeeTaxElectionsRequest($update_employee_tax_elections_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEmployeeTaxElections'
     *
     * @param  \OpenAPI\Client\Model\UpdateEmployeeTaxElectionsRequest $update_employee_tax_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmployeeTaxElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateEmployeeTaxElectionsRequest($update_employee_tax_elections_request = null, string $contentType = self::contentTypes['updateEmployeeTaxElections'][0])
    {



        $resourcePath = '/employee_tax_elections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_employee_tax_elections_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_employee_tax_elections_request));
            } else {
                $httpBody = $update_employee_tax_elections_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEmployeeTaxParameters
     *
     * Update an employee&#39;s tax parameter
     *
     * @param  string $employee_id ID of the employee used to update the applicable tax parameter. (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxParametersRequest $update_company_tax_parameters_request update_company_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmployeeTaxParameters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateEmployeeTaxParameters($employee_id, $update_company_tax_parameters_request = null, string $contentType = self::contentTypes['updateEmployeeTaxParameters'][0])
    {
        $this->updateEmployeeTaxParametersWithHttpInfo($employee_id, $update_company_tax_parameters_request, $contentType);
    }

    /**
     * Operation updateEmployeeTaxParametersWithHttpInfo
     *
     * Update an employee&#39;s tax parameter
     *
     * @param  string $employee_id ID of the employee used to update the applicable tax parameter. (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxParametersRequest $update_company_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmployeeTaxParameters'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEmployeeTaxParametersWithHttpInfo($employee_id, $update_company_tax_parameters_request = null, string $contentType = self::contentTypes['updateEmployeeTaxParameters'][0])
    {
        $request = $this->updateEmployeeTaxParametersRequest($employee_id, $update_company_tax_parameters_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateEmployeeTaxParametersAsync
     *
     * Update an employee&#39;s tax parameter
     *
     * @param  string $employee_id ID of the employee used to update the applicable tax parameter. (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxParametersRequest $update_company_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmployeeTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmployeeTaxParametersAsync($employee_id, $update_company_tax_parameters_request = null, string $contentType = self::contentTypes['updateEmployeeTaxParameters'][0])
    {
        return $this->updateEmployeeTaxParametersAsyncWithHttpInfo($employee_id, $update_company_tax_parameters_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEmployeeTaxParametersAsyncWithHttpInfo
     *
     * Update an employee&#39;s tax parameter
     *
     * @param  string $employee_id ID of the employee used to update the applicable tax parameter. (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxParametersRequest $update_company_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmployeeTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmployeeTaxParametersAsyncWithHttpInfo($employee_id, $update_company_tax_parameters_request = null, string $contentType = self::contentTypes['updateEmployeeTaxParameters'][0])
    {
        $returnType = '';
        $request = $this->updateEmployeeTaxParametersRequest($employee_id, $update_company_tax_parameters_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEmployeeTaxParameters'
     *
     * @param  string $employee_id ID of the employee used to update the applicable tax parameter. (required)
     * @param  \OpenAPI\Client\Model\UpdateCompanyTaxParametersRequest $update_company_tax_parameters_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmployeeTaxParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateEmployeeTaxParametersRequest($employee_id, $update_company_tax_parameters_request = null, string $contentType = self::contentTypes['updateEmployeeTaxParameters'][0])
    {

        // verify the required parameter 'employee_id' is set
        if ($employee_id === null || (is_array($employee_id) && count($employee_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee_id when calling updateEmployeeTaxParameters'
            );
        }



        $resourcePath = '/employee_tax_params/{employee_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee_id !== null) {
            $resourcePath = str_replace(
                '{' . 'employee_id' . '}',
                ObjectSerializer::toPathValue($employee_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_company_tax_parameters_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_company_tax_parameters_request));
            } else {
                $httpBody = $update_company_tax_parameters_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePayroll
     *
     * Update a payroll
     *
     * @param  string $payroll ID of the payroll to update. (required)
     * @param  \OpenAPI\Client\Model\UpdatePayrollRequest $update_payroll_request update_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function updatePayroll($payroll, $update_payroll_request = null, string $contentType = self::contentTypes['updatePayroll'][0])
    {
        list($response) = $this->updatePayrollWithHttpInfo($payroll, $update_payroll_request, $contentType);
        return $response;
    }

    /**
     * Operation updatePayrollWithHttpInfo
     *
     * Update a payroll
     *
     * @param  string $payroll ID of the payroll to update. (required)
     * @param  \OpenAPI\Client\Model\UpdatePayrollRequest $update_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePayroll'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePayrollWithHttpInfo($payroll, $update_payroll_request = null, string $contentType = self::contentTypes['updatePayroll'][0])
    {
        $request = $this->updatePayrollRequest($payroll, $update_payroll_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePayrollAsync
     *
     * Update a payroll
     *
     * @param  string $payroll ID of the payroll to update. (required)
     * @param  \OpenAPI\Client\Model\UpdatePayrollRequest $update_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePayrollAsync($payroll, $update_payroll_request = null, string $contentType = self::contentTypes['updatePayroll'][0])
    {
        return $this->updatePayrollAsyncWithHttpInfo($payroll, $update_payroll_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePayrollAsyncWithHttpInfo
     *
     * Update a payroll
     *
     * @param  string $payroll ID of the payroll to update. (required)
     * @param  \OpenAPI\Client\Model\UpdatePayrollRequest $update_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePayrollAsyncWithHttpInfo($payroll, $update_payroll_request = null, string $contentType = self::contentTypes['updatePayroll'][0])
    {
        $returnType = 'object';
        $request = $this->updatePayrollRequest($payroll, $update_payroll_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePayroll'
     *
     * @param  string $payroll ID of the payroll to update. (required)
     * @param  \OpenAPI\Client\Model\UpdatePayrollRequest $update_payroll_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePayroll'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updatePayrollRequest($payroll, $update_payroll_request = null, string $contentType = self::contentTypes['updatePayroll'][0])
    {

        // verify the required parameter 'payroll' is set
        if ($payroll === null || (is_array($payroll) && count($payroll) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payroll when calling updatePayroll'
            );
        }



        $resourcePath = '/payrolls/{payroll}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payroll !== null) {
            $resourcePath = str_replace(
                '{' . 'payroll' . '}',
                ObjectSerializer::toPathValue($payroll),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_payroll_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_payroll_request));
            } else {
                $httpBody = $update_payroll_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateReciprocityElections
     *
     * Update reciprocity elections
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  \OpenAPI\Client\Model\UpdateReciprocityElectionsRequest $update_reciprocity_elections_request update_reciprocity_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateReciprocityElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetReciprocityElections200Response|object
     */
    public function updateReciprocityElections($employee, $update_reciprocity_elections_request = null, string $contentType = self::contentTypes['updateReciprocityElections'][0])
    {
        list($response) = $this->updateReciprocityElectionsWithHttpInfo($employee, $update_reciprocity_elections_request, $contentType);
        return $response;
    }

    /**
     * Operation updateReciprocityElectionsWithHttpInfo
     *
     * Update reciprocity elections
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  \OpenAPI\Client\Model\UpdateReciprocityElectionsRequest $update_reciprocity_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateReciprocityElections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetReciprocityElections200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateReciprocityElectionsWithHttpInfo($employee, $update_reciprocity_elections_request = null, string $contentType = self::contentTypes['updateReciprocityElections'][0])
    {
        $request = $this->updateReciprocityElectionsRequest($employee, $update_reciprocity_elections_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetReciprocityElections200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetReciprocityElections200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetReciprocityElections200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetReciprocityElections200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetReciprocityElections200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateReciprocityElectionsAsync
     *
     * Update reciprocity elections
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  \OpenAPI\Client\Model\UpdateReciprocityElectionsRequest $update_reciprocity_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateReciprocityElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateReciprocityElectionsAsync($employee, $update_reciprocity_elections_request = null, string $contentType = self::contentTypes['updateReciprocityElections'][0])
    {
        return $this->updateReciprocityElectionsAsyncWithHttpInfo($employee, $update_reciprocity_elections_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateReciprocityElectionsAsyncWithHttpInfo
     *
     * Update reciprocity elections
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  \OpenAPI\Client\Model\UpdateReciprocityElectionsRequest $update_reciprocity_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateReciprocityElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateReciprocityElectionsAsyncWithHttpInfo($employee, $update_reciprocity_elections_request = null, string $contentType = self::contentTypes['updateReciprocityElections'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetReciprocityElections200Response';
        $request = $this->updateReciprocityElectionsRequest($employee, $update_reciprocity_elections_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateReciprocityElections'
     *
     * @param  string $employee ID of the employee to return (required)
     * @param  \OpenAPI\Client\Model\UpdateReciprocityElectionsRequest $update_reciprocity_elections_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateReciprocityElections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateReciprocityElectionsRequest($employee, $update_reciprocity_elections_request = null, string $contentType = self::contentTypes['updateReciprocityElections'][0])
    {

        // verify the required parameter 'employee' is set
        if ($employee === null || (is_array($employee) && count($employee) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $employee when calling updateReciprocityElections'
            );
        }



        $resourcePath = '/employees/{employee}/reciprocity_elections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employee !== null) {
            $resourcePath = str_replace(
                '{' . 'employee' . '}',
                ObjectSerializer::toPathValue($employee),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_reciprocity_elections_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_reciprocity_elections_request));
            } else {
                $httpBody = $update_reciprocity_elections_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTheEnrollmentProfile
     *
     * Update the enrollment profile
     *
     * @param  \OpenAPI\Client\Model\UpdateTheEnrollmentProfileRequest $update_the_enrollment_profile_request update_the_enrollment_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateTheEnrollmentProfile($update_the_enrollment_profile_request = null, string $contentType = self::contentTypes['updateTheEnrollmentProfile'][0])
    {
        $this->updateTheEnrollmentProfileWithHttpInfo($update_the_enrollment_profile_request, $contentType);
    }

    /**
     * Operation updateTheEnrollmentProfileWithHttpInfo
     *
     * Update the enrollment profile
     *
     * @param  \OpenAPI\Client\Model\UpdateTheEnrollmentProfileRequest $update_the_enrollment_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTheEnrollmentProfileWithHttpInfo($update_the_enrollment_profile_request = null, string $contentType = self::contentTypes['updateTheEnrollmentProfile'][0])
    {
        $request = $this->updateTheEnrollmentProfileRequest($update_the_enrollment_profile_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTheEnrollmentProfileAsync
     *
     * Update the enrollment profile
     *
     * @param  \OpenAPI\Client\Model\UpdateTheEnrollmentProfileRequest $update_the_enrollment_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTheEnrollmentProfileAsync($update_the_enrollment_profile_request = null, string $contentType = self::contentTypes['updateTheEnrollmentProfile'][0])
    {
        return $this->updateTheEnrollmentProfileAsyncWithHttpInfo($update_the_enrollment_profile_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTheEnrollmentProfileAsyncWithHttpInfo
     *
     * Update the enrollment profile
     *
     * @param  \OpenAPI\Client\Model\UpdateTheEnrollmentProfileRequest $update_the_enrollment_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTheEnrollmentProfileAsyncWithHttpInfo($update_the_enrollment_profile_request = null, string $contentType = self::contentTypes['updateTheEnrollmentProfile'][0])
    {
        $returnType = '';
        $request = $this->updateTheEnrollmentProfileRequest($update_the_enrollment_profile_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTheEnrollmentProfile'
     *
     * @param  \OpenAPI\Client\Model\UpdateTheEnrollmentProfileRequest $update_the_enrollment_profile_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTheEnrollmentProfile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTheEnrollmentProfileRequest($update_the_enrollment_profile_request = null, string $contentType = self::contentTypes['updateTheEnrollmentProfile'][0])
    {



        $resourcePath = '/companies/{company}/enrollment_profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_the_enrollment_profile_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_the_enrollment_profile_request));
            } else {
                $httpBody = $update_the_enrollment_profile_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadAFileForACompanyProvidedDocument
     *
     * Upload a file for a company provided document.
     *
     * @param  string $document ID of the company provided document to associate the uploaded file with. (required)
     * @param  string $content_type content_type (optional, default to 'application/pdf')
     * @param  \OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocumentRequest $upload_a_file_for_a_company_provided_document_request upload_a_file_for_a_company_provided_document_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAFileForACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocument200Response|object
     */
    public function uploadAFileForACompanyProvidedDocument($document, $content_type = 'application/pdf', $upload_a_file_for_a_company_provided_document_request = null, string $contentType = self::contentTypes['uploadAFileForACompanyProvidedDocument'][0])
    {
        list($response) = $this->uploadAFileForACompanyProvidedDocumentWithHttpInfo($document, $content_type, $upload_a_file_for_a_company_provided_document_request, $contentType);
        return $response;
    }

    /**
     * Operation uploadAFileForACompanyProvidedDocumentWithHttpInfo
     *
     * Upload a file for a company provided document.
     *
     * @param  string $document ID of the company provided document to associate the uploaded file with. (required)
     * @param  string $content_type (optional, default to 'application/pdf')
     * @param  \OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocumentRequest $upload_a_file_for_a_company_provided_document_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAFileForACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocument200Response|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadAFileForACompanyProvidedDocumentWithHttpInfo($document, $content_type = 'application/pdf', $upload_a_file_for_a_company_provided_document_request = null, string $contentType = self::contentTypes['uploadAFileForACompanyProvidedDocument'][0])
    {
        $request = $this->uploadAFileForACompanyProvidedDocumentRequest($document, $content_type, $upload_a_file_for_a_company_provided_document_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocument200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocument200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocument200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocument200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocument200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadAFileForACompanyProvidedDocumentAsync
     *
     * Upload a file for a company provided document.
     *
     * @param  string $document ID of the company provided document to associate the uploaded file with. (required)
     * @param  string $content_type (optional, default to 'application/pdf')
     * @param  \OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocumentRequest $upload_a_file_for_a_company_provided_document_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAFileForACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAFileForACompanyProvidedDocumentAsync($document, $content_type = 'application/pdf', $upload_a_file_for_a_company_provided_document_request = null, string $contentType = self::contentTypes['uploadAFileForACompanyProvidedDocument'][0])
    {
        return $this->uploadAFileForACompanyProvidedDocumentAsyncWithHttpInfo($document, $content_type, $upload_a_file_for_a_company_provided_document_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadAFileForACompanyProvidedDocumentAsyncWithHttpInfo
     *
     * Upload a file for a company provided document.
     *
     * @param  string $document ID of the company provided document to associate the uploaded file with. (required)
     * @param  string $content_type (optional, default to 'application/pdf')
     * @param  \OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocumentRequest $upload_a_file_for_a_company_provided_document_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAFileForACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAFileForACompanyProvidedDocumentAsyncWithHttpInfo($document, $content_type = 'application/pdf', $upload_a_file_for_a_company_provided_document_request = null, string $contentType = self::contentTypes['uploadAFileForACompanyProvidedDocument'][0])
    {
        $returnType = '\OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocument200Response';
        $request = $this->uploadAFileForACompanyProvidedDocumentRequest($document, $content_type, $upload_a_file_for_a_company_provided_document_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadAFileForACompanyProvidedDocument'
     *
     * @param  string $document ID of the company provided document to associate the uploaded file with. (required)
     * @param  string $content_type (optional, default to 'application/pdf')
     * @param  \OpenAPI\Client\Model\UploadAFileForACompanyProvidedDocumentRequest $upload_a_file_for_a_company_provided_document_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadAFileForACompanyProvidedDocument'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadAFileForACompanyProvidedDocumentRequest($document, $content_type = 'application/pdf', $upload_a_file_for_a_company_provided_document_request = null, string $contentType = self::contentTypes['uploadAFileForACompanyProvidedDocument'][0])
    {

        // verify the required parameter 'document' is set
        if ($document === null || (is_array($document) && count($document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document when calling uploadAFileForACompanyProvidedDocument'
            );
        }




        $resourcePath = '/company_provided_documents/{document}/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }

        // path params
        if ($document !== null) {
            $resourcePath = str_replace(
                '{' . 'document' . '}',
                ObjectSerializer::toPathValue($document),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($upload_a_file_for_a_company_provided_document_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($upload_a_file_for_a_company_provided_document_request));
            } else {
                $httpBody = $upload_a_file_for_a_company_provided_document_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation validateAddress
     *
     * Validate address
     *
     * @param  \OpenAPI\Client\Model\ValidateAddressRequest $validate_address_request validate_address_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAddress'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|object
     */
    public function validateAddress($validate_address_request = null, string $contentType = self::contentTypes['validateAddress'][0])
    {
        list($response) = $this->validateAddressWithHttpInfo($validate_address_request, $contentType);
        return $response;
    }

    /**
     * Operation validateAddressWithHttpInfo
     *
     * Validate address
     *
     * @param  \OpenAPI\Client\Model\ValidateAddressRequest $validate_address_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAddress'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function validateAddressWithHttpInfo($validate_address_request = null, string $contentType = self::contentTypes['validateAddress'][0])
    {
        $request = $this->validateAddressRequest($validate_address_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation validateAddressAsync
     *
     * Validate address
     *
     * @param  \OpenAPI\Client\Model\ValidateAddressRequest $validate_address_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateAddressAsync($validate_address_request = null, string $contentType = self::contentTypes['validateAddress'][0])
    {
        return $this->validateAddressAsyncWithHttpInfo($validate_address_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation validateAddressAsyncWithHttpInfo
     *
     * Validate address
     *
     * @param  \OpenAPI\Client\Model\ValidateAddressRequest $validate_address_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function validateAddressAsyncWithHttpInfo($validate_address_request = null, string $contentType = self::contentTypes['validateAddress'][0])
    {
        $returnType = 'object';
        $request = $this->validateAddressRequest($validate_address_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'validateAddress'
     *
     * @param  \OpenAPI\Client\Model\ValidateAddressRequest $validate_address_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['validateAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function validateAddressRequest($validate_address_request = null, string $contentType = self::contentTypes['validateAddress'][0])
    {



        $resourcePath = '/addresses/validate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($validate_address_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($validate_address_request));
            } else {
                $httpBody = $validate_address_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
